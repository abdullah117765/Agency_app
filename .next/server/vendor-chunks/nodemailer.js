"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nodemailer";
exports.ids = ["vendor-chunks/nodemailer"];
exports.modules = {

/***/ "(rsc)/./node_modules/nodemailer/lib/addressparser/index.js":
/*!************************************************************!*\
  !*** ./node_modules/nodemailer/lib/addressparser/index.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @return {Object} Address object\n */\nfunction _handleAddress(tokens) {\n    let token;\n    let isGroup = false;\n    let state = 'text';\n    let address;\n    let addresses = [];\n    let data = {\n        address: [],\n        comment: [],\n        group: [],\n        text: []\n    };\n    let i;\n    let len;\n\n    // Filter out <addresses>, (comments) and regular text\n    for (i = 0, len = tokens.length; i < len; i++) {\n        token = tokens[i];\n        if (token.type === 'operator') {\n            switch (token.value) {\n                case '<':\n                    state = 'address';\n                    break;\n                case '(':\n                    state = 'comment';\n                    break;\n                case ':':\n                    state = 'group';\n                    isGroup = true;\n                    break;\n                default:\n                    state = 'text';\n            }\n        } else if (token.value) {\n            if (state === 'address') {\n                // handle use case where unquoted name includes a \"<\"\n                // Apple Mail truncates everything between an unexpected < and an address\n                // and so will we\n                token.value = token.value.replace(/^[^<]*<\\s*/, '');\n            }\n            data[state].push(token.value);\n        }\n    }\n\n    // If there is no text but a comment, replace the two\n    if (!data.text.length && data.comment.length) {\n        data.text = data.comment;\n        data.comment = [];\n    }\n\n    if (isGroup) {\n        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n        data.text = data.text.join(' ');\n        addresses.push({\n            name: data.text || (address && address.name),\n            group: data.group.length ? addressparser(data.group.join(',')) : []\n        });\n    } else {\n        // If no address was found, try to detect one from regular text\n        if (!data.address.length && data.text.length) {\n            for (i = data.text.length - 1; i >= 0; i--) {\n                if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n                    data.address = data.text.splice(i, 1);\n                    break;\n                }\n            }\n\n            let _regexHandler = function (address) {\n                if (!data.address.length) {\n                    data.address = [address.trim()];\n                    return ' ';\n                } else {\n                    return address;\n                }\n            };\n\n            // still no address\n            if (!data.address.length) {\n                for (i = data.text.length - 1; i >= 0; i--) {\n                    // fixed the regex to parse email address correctly when email address has more than one @\n                    data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim();\n                    if (data.address.length) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // If there's still is no text but a comment exixts, replace the two\n        if (!data.text.length && data.comment.length) {\n            data.text = data.comment;\n            data.comment = [];\n        }\n\n        // Keep only the first address occurence, push others to regular text\n        if (data.address.length > 1) {\n            data.text = data.text.concat(data.address.splice(1));\n        }\n\n        // Join values with spaces\n        data.text = data.text.join(' ');\n        data.address = data.address.join(' ');\n\n        if (!data.address && isGroup) {\n            return [];\n        } else {\n            address = {\n                address: data.address || data.text || '',\n                name: data.text || data.address || ''\n            };\n\n            if (address.address === address.name) {\n                if ((address.address || '').match(/@/)) {\n                    address.name = '';\n                } else {\n                    address.address = '';\n                }\n            }\n\n            addresses.push(address);\n        }\n    }\n\n    return addresses;\n}\n\n/**\n * Creates a Tokenizer object for tokenizing address field strings\n *\n * @constructor\n * @param {String} str Address field string\n */\nclass Tokenizer {\n    constructor(str) {\n        this.str = (str || '').toString();\n        this.operatorCurrent = '';\n        this.operatorExpecting = '';\n        this.node = null;\n        this.escaped = false;\n\n        this.list = [];\n        /**\n         * Operator tokens and which tokens are expected to end the sequence\n         */\n        this.operators = {\n            '\"': '\"',\n            '(': ')',\n            '<': '>',\n            ',': '',\n            ':': ';',\n            // Semicolons are not a legal delimiter per the RFC2822 grammar other\n            // than for terminating a group, but they are also not valid for any\n            // other use in this context.  Given that some mail clients have\n            // historically allowed the semicolon as a delimiter equivalent to the\n            // comma in their UI, it makes sense to treat them the same as a comma\n            // when used outside of a group.\n            ';': ''\n        };\n    }\n\n    /**\n     * Tokenizes the original input string\n     *\n     * @return {Array} An array of operator|text tokens\n     */\n    tokenize() {\n        let chr,\n            list = [];\n        for (let i = 0, len = this.str.length; i < len; i++) {\n            chr = this.str.charAt(i);\n            this.checkChar(chr);\n        }\n\n        this.list.forEach(node => {\n            node.value = (node.value || '').toString().trim();\n            if (node.value) {\n                list.push(node);\n            }\n        });\n\n        return list;\n    }\n\n    /**\n     * Checks if a character is an operator or text and acts accordingly\n     *\n     * @param {String} chr Character from the address field\n     */\n    checkChar(chr) {\n        if (this.escaped) {\n            // ignore next condition blocks\n        } else if (chr === this.operatorExpecting) {\n            this.node = {\n                type: 'operator',\n                value: chr\n            };\n            this.list.push(this.node);\n            this.node = null;\n            this.operatorExpecting = '';\n            this.escaped = false;\n            return;\n        } else if (!this.operatorExpecting && chr in this.operators) {\n            this.node = {\n                type: 'operator',\n                value: chr\n            };\n            this.list.push(this.node);\n            this.node = null;\n            this.operatorExpecting = this.operators[chr];\n            this.escaped = false;\n            return;\n        } else if (['\"', \"'\"].includes(this.operatorExpecting) && chr === '\\\\') {\n            this.escaped = true;\n            return;\n        }\n\n        if (!this.node) {\n            this.node = {\n                type: 'text',\n                value: ''\n            };\n            this.list.push(this.node);\n        }\n\n        if (chr === '\\n') {\n            // Convert newlines to spaces. Carriage return is ignored as \\r and \\n usually\n            // go together anyway and there already is a WS for \\n. Lone \\r means something is fishy.\n            chr = ' ';\n        }\n\n        if (chr.charCodeAt(0) >= 0x21 || [' ', '\\t'].includes(chr)) {\n            // skip command bytes\n            this.node.value += chr;\n        }\n\n        this.escaped = false;\n    }\n}\n\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    'Name <address@domain>'\n *\n * will be converted to\n *\n *     [{name: 'Name', address: 'address@domain'}]\n *\n * @param {String} str Address field\n * @return {Array} An array of address objects\n */\nfunction addressparser(str, options) {\n    options = options || {};\n\n    let tokenizer = new Tokenizer(str);\n    let tokens = tokenizer.tokenize();\n\n    let addresses = [];\n    let address = [];\n    let parsedAddresses = [];\n\n    tokens.forEach(token => {\n        if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n            if (address.length) {\n                addresses.push(address);\n            }\n            address = [];\n        } else {\n            address.push(token);\n        }\n    });\n\n    if (address.length) {\n        addresses.push(address);\n    }\n\n    addresses.forEach(address => {\n        address = _handleAddress(address);\n        if (address.length) {\n            parsedAddresses = parsedAddresses.concat(address);\n        }\n    });\n\n    if (options.flatten) {\n        let addresses = [];\n        let walkAddressList = list => {\n            list.forEach(address => {\n                if (address.group) {\n                    return walkAddressList(address.group);\n                } else {\n                    addresses.push(address);\n                }\n            });\n        };\n        walkAddressList(parsedAddresses);\n        return addresses;\n    }\n\n    return parsedAddresses;\n}\n\n// expose to the world\nmodule.exports = addressparser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvYWRkcmVzc3BhcnNlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdDQUF3QztBQUNqRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9hZGRyZXNzcGFyc2VyL2luZGV4LmpzP2ZjNTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbnZlcnRzIHRva2VucyBmb3IgYSBzaW5nbGUgYWRkcmVzcyBpbnRvIGFuIGFkZHJlc3Mgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIFRva2VucyBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gQWRkcmVzcyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gX2hhbmRsZUFkZHJlc3ModG9rZW5zKSB7XG4gICAgbGV0IHRva2VuO1xuICAgIGxldCBpc0dyb3VwID0gZmFsc2U7XG4gICAgbGV0IHN0YXRlID0gJ3RleHQnO1xuICAgIGxldCBhZGRyZXNzO1xuICAgIGxldCBhZGRyZXNzZXMgPSBbXTtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgYWRkcmVzczogW10sXG4gICAgICAgIGNvbW1lbnQ6IFtdLFxuICAgICAgICBncm91cDogW10sXG4gICAgICAgIHRleHQ6IFtdXG4gICAgfTtcbiAgICBsZXQgaTtcbiAgICBsZXQgbGVuO1xuXG4gICAgLy8gRmlsdGVyIG91dCA8YWRkcmVzc2VzPiwgKGNvbW1lbnRzKSBhbmQgcmVndWxhciB0ZXh0XG4gICAgZm9yIChpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ29wZXJhdG9yJykge1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9ICdhZGRyZXNzJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gJ2NvbW1lbnQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAnZ3JvdXAnO1xuICAgICAgICAgICAgICAgICAgICBpc0dyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAndGV4dCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHVzZSBjYXNlIHdoZXJlIHVucXVvdGVkIG5hbWUgaW5jbHVkZXMgYSBcIjxcIlxuICAgICAgICAgICAgICAgIC8vIEFwcGxlIE1haWwgdHJ1bmNhdGVzIGV2ZXJ5dGhpbmcgYmV0d2VlbiBhbiB1bmV4cGVjdGVkIDwgYW5kIGFuIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAvLyBhbmQgc28gd2lsbCB3ZVxuICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4udmFsdWUucmVwbGFjZSgvXltePF0qPFxccyovLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhW3N0YXRlXS5wdXNoKHRva2VuLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIHRleHQgYnV0IGEgY29tbWVudCwgcmVwbGFjZSB0aGUgdHdvXG4gICAgaWYgKCFkYXRhLnRleHQubGVuZ3RoICYmIGRhdGEuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgZGF0YS50ZXh0ID0gZGF0YS5jb21tZW50O1xuICAgICAgICBkYXRhLmNvbW1lbnQgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI2FwcGVuZGl4LUEuMS4zXG4gICAgICAgIGRhdGEudGV4dCA9IGRhdGEudGV4dC5qb2luKCcgJyk7XG4gICAgICAgIGFkZHJlc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGRhdGEudGV4dCB8fCAoYWRkcmVzcyAmJiBhZGRyZXNzLm5hbWUpLFxuICAgICAgICAgICAgZ3JvdXA6IGRhdGEuZ3JvdXAubGVuZ3RoID8gYWRkcmVzc3BhcnNlcihkYXRhLmdyb3VwLmpvaW4oJywnKSkgOiBbXVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBubyBhZGRyZXNzIHdhcyBmb3VuZCwgdHJ5IHRvIGRldGVjdCBvbmUgZnJvbSByZWd1bGFyIHRleHRcbiAgICAgICAgaWYgKCFkYXRhLmFkZHJlc3MubGVuZ3RoICYmIGRhdGEudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IGRhdGEudGV4dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnRleHRbaV0ubWF0Y2goL15bXkBcXHNdK0BbXkBcXHNdKyQvKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmFkZHJlc3MgPSBkYXRhLnRleHQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBfcmVnZXhIYW5kbGVyID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hZGRyZXNzID0gW2FkZHJlc3MudHJpbSgpXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcgJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBzdGlsbCBubyBhZGRyZXNzXG4gICAgICAgICAgICBpZiAoIWRhdGEuYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBkYXRhLnRleHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZml4ZWQgdGhlIHJlZ2V4IHRvIHBhcnNlIGVtYWlsIGFkZHJlc3MgY29ycmVjdGx5IHdoZW4gZW1haWwgYWRkcmVzcyBoYXMgbW9yZSB0aGFuIG9uZSBAXG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGV4dFtpXSA9IGRhdGEudGV4dFtpXS5yZXBsYWNlKC9cXHMqXFxiW15AXFxzXStAW15cXHNdK1xcYlxccyovLCBfcmVnZXhIYW5kbGVyKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgc3RpbGwgaXMgbm8gdGV4dCBidXQgYSBjb21tZW50IGV4aXh0cywgcmVwbGFjZSB0aGUgdHdvXG4gICAgICAgIGlmICghZGF0YS50ZXh0Lmxlbmd0aCAmJiBkYXRhLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhLnRleHQgPSBkYXRhLmNvbW1lbnQ7XG4gICAgICAgICAgICBkYXRhLmNvbW1lbnQgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEtlZXAgb25seSB0aGUgZmlyc3QgYWRkcmVzcyBvY2N1cmVuY2UsIHB1c2ggb3RoZXJzIHRvIHJlZ3VsYXIgdGV4dFxuICAgICAgICBpZiAoZGF0YS5hZGRyZXNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGRhdGEudGV4dCA9IGRhdGEudGV4dC5jb25jYXQoZGF0YS5hZGRyZXNzLnNwbGljZSgxKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBKb2luIHZhbHVlcyB3aXRoIHNwYWNlc1xuICAgICAgICBkYXRhLnRleHQgPSBkYXRhLnRleHQuam9pbignICcpO1xuICAgICAgICBkYXRhLmFkZHJlc3MgPSBkYXRhLmFkZHJlc3Muam9pbignICcpO1xuXG4gICAgICAgIGlmICghZGF0YS5hZGRyZXNzICYmIGlzR3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogZGF0YS5hZGRyZXNzIHx8IGRhdGEudGV4dCB8fCAnJyxcbiAgICAgICAgICAgICAgICBuYW1lOiBkYXRhLnRleHQgfHwgZGF0YS5hZGRyZXNzIHx8ICcnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoYWRkcmVzcy5hZGRyZXNzID09PSBhZGRyZXNzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGFkZHJlc3MuYWRkcmVzcyB8fCAnJykubWF0Y2goL0AvKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLm5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmFkZHJlc3MgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZHJlc3Nlcztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgVG9rZW5pemVyIG9iamVjdCBmb3IgdG9rZW5pemluZyBhZGRyZXNzIGZpZWxkIHN0cmluZ3NcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQWRkcmVzcyBmaWVsZCBzdHJpbmdcbiAqL1xuY2xhc3MgVG9rZW5pemVyIHtcbiAgICBjb25zdHJ1Y3RvcihzdHIpIHtcbiAgICAgICAgdGhpcy5zdHIgPSAoc3RyIHx8ICcnKS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLm9wZXJhdG9yQ3VycmVudCA9ICcnO1xuICAgICAgICB0aGlzLm9wZXJhdG9yRXhwZWN0aW5nID0gJyc7XG4gICAgICAgIHRoaXMubm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZXNjYXBlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMubGlzdCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3BlcmF0b3IgdG9rZW5zIGFuZCB3aGljaCB0b2tlbnMgYXJlIGV4cGVjdGVkIHRvIGVuZCB0aGUgc2VxdWVuY2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlcmF0b3JzID0ge1xuICAgICAgICAgICAgJ1wiJzogJ1wiJyxcbiAgICAgICAgICAgICcoJzogJyknLFxuICAgICAgICAgICAgJzwnOiAnPicsXG4gICAgICAgICAgICAnLCc6ICcnLFxuICAgICAgICAgICAgJzonOiAnOycsXG4gICAgICAgICAgICAvLyBTZW1pY29sb25zIGFyZSBub3QgYSBsZWdhbCBkZWxpbWl0ZXIgcGVyIHRoZSBSRkMyODIyIGdyYW1tYXIgb3RoZXJcbiAgICAgICAgICAgIC8vIHRoYW4gZm9yIHRlcm1pbmF0aW5nIGEgZ3JvdXAsIGJ1dCB0aGV5IGFyZSBhbHNvIG5vdCB2YWxpZCBmb3IgYW55XG4gICAgICAgICAgICAvLyBvdGhlciB1c2UgaW4gdGhpcyBjb250ZXh0LiAgR2l2ZW4gdGhhdCBzb21lIG1haWwgY2xpZW50cyBoYXZlXG4gICAgICAgICAgICAvLyBoaXN0b3JpY2FsbHkgYWxsb3dlZCB0aGUgc2VtaWNvbG9uIGFzIGEgZGVsaW1pdGVyIGVxdWl2YWxlbnQgdG8gdGhlXG4gICAgICAgICAgICAvLyBjb21tYSBpbiB0aGVpciBVSSwgaXQgbWFrZXMgc2Vuc2UgdG8gdHJlYXQgdGhlbSB0aGUgc2FtZSBhcyBhIGNvbW1hXG4gICAgICAgICAgICAvLyB3aGVuIHVzZWQgb3V0c2lkZSBvZiBhIGdyb3VwLlxuICAgICAgICAgICAgJzsnOiAnJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRva2VuaXplcyB0aGUgb3JpZ2luYWwgaW5wdXQgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2Ygb3BlcmF0b3J8dGV4dCB0b2tlbnNcbiAgICAgKi9cbiAgICB0b2tlbml6ZSgpIHtcbiAgICAgICAgbGV0IGNocixcbiAgICAgICAgICAgIGxpc3QgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaHIgPSB0aGlzLnN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ2hhcihjaHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5saXN0LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gKG5vZGUudmFsdWUgfHwgJycpLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICAgICAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGNoYXJhY3RlciBpcyBhbiBvcGVyYXRvciBvciB0ZXh0IGFuZCBhY3RzIGFjY29yZGluZ2x5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hyIENoYXJhY3RlciBmcm9tIHRoZSBhZGRyZXNzIGZpZWxkXG4gICAgICovXG4gICAgY2hlY2tDaGFyKGNocikge1xuICAgICAgICBpZiAodGhpcy5lc2NhcGVkKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgbmV4dCBjb25kaXRpb24gYmxvY2tzXG4gICAgICAgIH0gZWxzZSBpZiAoY2hyID09PSB0aGlzLm9wZXJhdG9yRXhwZWN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29wZXJhdG9yJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2hyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5saXN0LnB1c2godGhpcy5ub2RlKTtcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yRXhwZWN0aW5nID0gJyc7XG4gICAgICAgICAgICB0aGlzLmVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcGVyYXRvckV4cGVjdGluZyAmJiBjaHIgaW4gdGhpcy5vcGVyYXRvcnMpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlcmF0b3InLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaHJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmxpc3QucHVzaCh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgdGhpcy5ub2RlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3JFeHBlY3RpbmcgPSB0aGlzLm9wZXJhdG9yc1tjaHJdO1xuICAgICAgICAgICAgdGhpcy5lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoWydcIicsIFwiJ1wiXS5pbmNsdWRlcyh0aGlzLm9wZXJhdG9yRXhwZWN0aW5nKSAmJiBjaHIgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgdGhpcy5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5ub2RlKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubGlzdC5wdXNoKHRoaXMubm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hyID09PSAnXFxuJykge1xuICAgICAgICAgICAgLy8gQ29udmVydCBuZXdsaW5lcyB0byBzcGFjZXMuIENhcnJpYWdlIHJldHVybiBpcyBpZ25vcmVkIGFzIFxcciBhbmQgXFxuIHVzdWFsbHlcbiAgICAgICAgICAgIC8vIGdvIHRvZ2V0aGVyIGFueXdheSBhbmQgdGhlcmUgYWxyZWFkeSBpcyBhIFdTIGZvciBcXG4uIExvbmUgXFxyIG1lYW5zIHNvbWV0aGluZyBpcyBmaXNoeS5cbiAgICAgICAgICAgIGNociA9ICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaHIuY2hhckNvZGVBdCgwKSA+PSAweDIxIHx8IFsnICcsICdcXHQnXS5pbmNsdWRlcyhjaHIpKSB7XG4gICAgICAgICAgICAvLyBza2lwIGNvbW1hbmQgYnl0ZXNcbiAgICAgICAgICAgIHRoaXMubm9kZS52YWx1ZSArPSBjaHI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVzY2FwZWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogUGFyc2VzIHN0cnVjdHVyZWQgZS1tYWlsIGFkZHJlc3NlcyBmcm9tIGFuIGFkZHJlc3MgZmllbGRcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICdOYW1lIDxhZGRyZXNzQGRvbWFpbj4nXG4gKlxuICogd2lsbCBiZSBjb252ZXJ0ZWQgdG9cbiAqXG4gKiAgICAgW3tuYW1lOiAnTmFtZScsIGFkZHJlc3M6ICdhZGRyZXNzQGRvbWFpbid9XVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQWRkcmVzcyBmaWVsZFxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIGFkZHJlc3Mgb2JqZWN0c1xuICovXG5mdW5jdGlvbiBhZGRyZXNzcGFyc2VyKHN0ciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgbGV0IHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoc3RyKTtcbiAgICBsZXQgdG9rZW5zID0gdG9rZW5pemVyLnRva2VuaXplKCk7XG5cbiAgICBsZXQgYWRkcmVzc2VzID0gW107XG4gICAgbGV0IGFkZHJlc3MgPSBbXTtcbiAgICBsZXQgcGFyc2VkQWRkcmVzc2VzID0gW107XG5cbiAgICB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnb3BlcmF0b3InICYmICh0b2tlbi52YWx1ZSA9PT0gJywnIHx8IHRva2VuLnZhbHVlID09PSAnOycpKSB7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHJlc3MgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZHJlc3MucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChhZGRyZXNzLmxlbmd0aCkge1xuICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICB9XG5cbiAgICBhZGRyZXNzZXMuZm9yRWFjaChhZGRyZXNzID0+IHtcbiAgICAgICAgYWRkcmVzcyA9IF9oYW5kbGVBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBpZiAoYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcnNlZEFkZHJlc3NlcyA9IHBhcnNlZEFkZHJlc3Nlcy5jb25jYXQoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgbGV0IGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICBsZXQgd2Fsa0FkZHJlc3NMaXN0ID0gbGlzdCA9PiB7XG4gICAgICAgICAgICBsaXN0LmZvckVhY2goYWRkcmVzcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGtBZGRyZXNzTGlzdChhZGRyZXNzLmdyb3VwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgd2Fsa0FkZHJlc3NMaXN0KHBhcnNlZEFkZHJlc3Nlcyk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZEFkZHJlc3Nlcztcbn1cblxuLy8gZXhwb3NlIHRvIHRoZSB3b3JsZFxubW9kdWxlLmV4cG9ydHMgPSBhZGRyZXNzcGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/addressparser/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/base64/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/nodemailer/lib/base64/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\n\n/**\n * Encodes a Buffer into a base64 encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} base64 encoded string\n */\nfunction encode(buffer) {\n    if (typeof buffer === 'string') {\n        buffer = Buffer.from(buffer, 'utf-8');\n    }\n\n    return buffer.toString('base64');\n}\n\n/**\n * Adds soft line breaks to a base64 string\n *\n * @param {String} str base64 encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped base64 encoded string\n */\nfunction wrap(str, lineLength) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n\n    if (str.length <= lineLength) {\n        return str;\n    }\n\n    let result = [];\n    let pos = 0;\n    let chunkLength = lineLength * 1024;\n    while (pos < str.length) {\n        let wrappedLines = str\n            .substr(pos, chunkLength)\n            .replace(new RegExp('.{' + lineLength + '}', 'g'), '$&\\r\\n')\n            .trim();\n        result.push(wrappedLines);\n        pos += chunkLength;\n    }\n\n    return result.join('\\r\\n').trim();\n}\n\n/**\n * Creates a transform stream for encoding data to base64 encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping\n */\nclass Encoder extends Transform {\n    constructor(options) {\n        super();\n        // init Transform\n        this.options = options || {};\n\n        if (this.options.lineLength !== false) {\n            this.options.lineLength = this.options.lineLength || 76;\n        }\n\n        this._curLine = '';\n        this._remainingBytes = false;\n\n        this.inputBytes = 0;\n        this.outputBytes = 0;\n    }\n\n    _transform(chunk, encoding, done) {\n        if (encoding !== 'buffer') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        if (!chunk || !chunk.length) {\n            return setImmediate(done);\n        }\n\n        this.inputBytes += chunk.length;\n\n        if (this._remainingBytes && this._remainingBytes.length) {\n            chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);\n            this._remainingBytes = false;\n        }\n\n        if (chunk.length % 3) {\n            this._remainingBytes = chunk.slice(chunk.length - (chunk.length % 3));\n            chunk = chunk.slice(0, chunk.length - (chunk.length % 3));\n        } else {\n            this._remainingBytes = false;\n        }\n\n        let b64 = this._curLine + encode(chunk);\n\n        if (this.options.lineLength) {\n            b64 = wrap(b64, this.options.lineLength);\n\n            // remove last line as it is still most probably incomplete\n            let lastLF = b64.lastIndexOf('\\n');\n            if (lastLF < 0) {\n                this._curLine = b64;\n                b64 = '';\n            } else if (lastLF === b64.length - 1) {\n                this._curLine = '';\n            } else {\n                this._curLine = b64.substr(lastLF + 1);\n                b64 = b64.substr(0, lastLF + 1);\n            }\n        }\n\n        if (b64) {\n            this.outputBytes += b64.length;\n            this.push(Buffer.from(b64, 'ascii'));\n        }\n\n        setImmediate(done);\n    }\n\n    _flush(done) {\n        if (this._remainingBytes && this._remainingBytes.length) {\n            this._curLine += encode(this._remainingBytes);\n        }\n\n        if (this._curLine) {\n            this._curLine = wrap(this._curLine, this.options.lineLength);\n            this.outputBytes += this._curLine.length;\n            this.push(this._curLine, 'ascii');\n            this._curLine = '';\n        }\n        done();\n    }\n}\n\n// expose to the world\nmodule.exports = {\n    encode,\n    wrap,\n    Encoder\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvYmFzZTY0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQix1REFBMkI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9iYXNlNjQvaW5kZXguanM/NzIyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgQnVmZmVyIGludG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlcikge1xuICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICBidWZmZXIgPSBCdWZmZXIuZnJvbShidWZmZXIsICd1dGYtOCcpO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufVxuXG4vKipcbiAqIEFkZHMgc29mdCBsaW5lIGJyZWFrcyB0byBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0aGF0IG1pZ2h0IG5lZWQgbGluZSB3cmFwcGluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IFtsaW5lTGVuZ3RoPTc2XSBNYXhpbXVtIGFsbG93ZWQgbGVuZ3RoIGZvciBhIGxpbmVcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFNvZnQtd3JhcHBlZCBiYXNlNjQgZW5jb2RlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gd3JhcChzdHIsIGxpbmVMZW5ndGgpIHtcbiAgICBzdHIgPSAoc3RyIHx8ICcnKS50b1N0cmluZygpO1xuICAgIGxpbmVMZW5ndGggPSBsaW5lTGVuZ3RoIHx8IDc2O1xuXG4gICAgaWYgKHN0ci5sZW5ndGggPD0gbGluZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBsZXQgY2h1bmtMZW5ndGggPSBsaW5lTGVuZ3RoICogMTAyNDtcbiAgICB3aGlsZSAocG9zIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICBsZXQgd3JhcHBlZExpbmVzID0gc3RyXG4gICAgICAgICAgICAuc3Vic3RyKHBvcywgY2h1bmtMZW5ndGgpXG4gICAgICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKCcueycgKyBsaW5lTGVuZ3RoICsgJ30nLCAnZycpLCAnJCZcXHJcXG4nKVxuICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgcmVzdWx0LnB1c2god3JhcHBlZExpbmVzKTtcbiAgICAgICAgcG9zICs9IGNodW5rTGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQuam9pbignXFxyXFxuJykudHJpbSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0cmFuc2Zvcm0gc3RyZWFtIGZvciBlbmNvZGluZyBkYXRhIHRvIGJhc2U2NCBlbmNvZGluZ1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgU3RyZWFtIG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5saW5lTGVuZ3RoPTc2XSBNYXhpbXVtIGxlbmd0aCBmb3IgbGluZXMsIHNldCB0byBmYWxzZSB0byBkaXNhYmxlIHdyYXBwaW5nXG4gKi9cbmNsYXNzIEVuY29kZXIgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaW5pdCBUcmFuc2Zvcm1cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxpbmVMZW5ndGggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubGluZUxlbmd0aCA9IHRoaXMub3B0aW9ucy5saW5lTGVuZ3RoIHx8IDc2O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3VyTGluZSA9ICcnO1xuICAgICAgICB0aGlzLl9yZW1haW5pbmdCeXRlcyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaW5wdXRCeXRlcyA9IDA7XG4gICAgICAgIHRoaXMub3V0cHV0Qnl0ZXMgPSAwO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBkb25lKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyAhPT0gJ2J1ZmZlcicpIHtcbiAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShkb25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5wdXRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZ0J5dGVzICYmIHRoaXMuX3JlbWFpbmluZ0J5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuY29uY2F0KFt0aGlzLl9yZW1haW5pbmdCeXRlcywgY2h1bmtdLCB0aGlzLl9yZW1haW5pbmdCeXRlcy5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5fcmVtYWluaW5nQnl0ZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaHVuay5sZW5ndGggJSAzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1haW5pbmdCeXRlcyA9IGNodW5rLnNsaWNlKGNodW5rLmxlbmd0aCAtIChjaHVuay5sZW5ndGggJSAzKSk7XG4gICAgICAgICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIGNodW5rLmxlbmd0aCAtIChjaHVuay5sZW5ndGggJSAzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1haW5pbmdCeXRlcyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGI2NCA9IHRoaXMuX2N1ckxpbmUgKyBlbmNvZGUoY2h1bmspO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGluZUxlbmd0aCkge1xuICAgICAgICAgICAgYjY0ID0gd3JhcChiNjQsIHRoaXMub3B0aW9ucy5saW5lTGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGxhc3QgbGluZSBhcyBpdCBpcyBzdGlsbCBtb3N0IHByb2JhYmx5IGluY29tcGxldGVcbiAgICAgICAgICAgIGxldCBsYXN0TEYgPSBiNjQubGFzdEluZGV4T2YoJ1xcbicpO1xuICAgICAgICAgICAgaWYgKGxhc3RMRiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJMaW5lID0gYjY0O1xuICAgICAgICAgICAgICAgIGI2NCA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0TEYgPT09IGI2NC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VyTGluZSA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJMaW5lID0gYjY0LnN1YnN0cihsYXN0TEYgKyAxKTtcbiAgICAgICAgICAgICAgICBiNjQgPSBiNjQuc3Vic3RyKDAsIGxhc3RMRiArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGI2NCkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRCeXRlcyArPSBiNjQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5wdXNoKEJ1ZmZlci5mcm9tKGI2NCwgJ2FzY2lpJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlKGRvbmUpO1xuICAgIH1cblxuICAgIF9mbHVzaChkb25lKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZW1haW5pbmdCeXRlcyAmJiB0aGlzLl9yZW1haW5pbmdCeXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1ckxpbmUgKz0gZW5jb2RlKHRoaXMuX3JlbWFpbmluZ0J5dGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jdXJMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJMaW5lID0gd3JhcCh0aGlzLl9jdXJMaW5lLCB0aGlzLm9wdGlvbnMubGluZUxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEJ5dGVzICs9IHRoaXMuX2N1ckxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuX2N1ckxpbmUsICdhc2NpaScpO1xuICAgICAgICAgICAgdGhpcy5fY3VyTGluZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUoKTtcbiAgICB9XG59XG5cbi8vIGV4cG9zZSB0byB0aGUgd29ybGRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVuY29kZSxcbiAgICB3cmFwLFxuICAgIEVuY29kZXJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/base64/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/dkim/index.js":
/*!***************************************************!*\
  !*** ./node_modules/nodemailer/lib/dkim/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// FIXME:\n// replace this Transform mess with a method that pipes input argument to output argument\n\nconst MessageParser = __webpack_require__(/*! ./message-parser */ \"(rsc)/./node_modules/nodemailer/lib/dkim/message-parser.js\");\nconst RelaxedBody = __webpack_require__(/*! ./relaxed-body */ \"(rsc)/./node_modules/nodemailer/lib/dkim/relaxed-body.js\");\nconst sign = __webpack_require__(/*! ./sign */ \"(rsc)/./node_modules/nodemailer/lib/dkim/sign.js\");\nconst PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst DKIM_ALGO = 'sha256';\nconst MAX_MESSAGE_SIZE = 128 * 1024; // buffer messages larger than this to disk\n\n/*\n// Usage:\n\nlet dkim = new DKIM({\n    domainName: 'example.com',\n    keySelector: 'key-selector',\n    privateKey,\n    cacheDir: '/tmp'\n});\ndkim.sign(input).pipe(process.stdout);\n\n// Where inputStream is a rfc822 message (either a stream, string or Buffer)\n// and outputStream is a DKIM signed rfc822 message\n*/\n\nclass DKIMSigner {\n    constructor(options, keys, input, output) {\n        this.options = options || {};\n        this.keys = keys;\n\n        this.cacheTreshold = Number(this.options.cacheTreshold) || MAX_MESSAGE_SIZE;\n        this.hashAlgo = this.options.hashAlgo || DKIM_ALGO;\n\n        this.cacheDir = this.options.cacheDir || false;\n\n        this.chunks = [];\n        this.chunklen = 0;\n        this.readPos = 0;\n        this.cachePath = this.cacheDir ? path.join(this.cacheDir, 'message.' + Date.now() + '-' + crypto.randomBytes(14).toString('hex')) : false;\n        this.cache = false;\n\n        this.headers = false;\n        this.bodyHash = false;\n        this.parser = false;\n        this.relaxedBody = false;\n\n        this.input = input;\n        this.output = output;\n        this.output.usingCache = false;\n\n        this.hasErrored = false;\n\n        this.input.on('error', err => {\n            this.hasErrored = true;\n            this.cleanup();\n            output.emit('error', err);\n        });\n    }\n\n    cleanup() {\n        if (!this.cache || !this.cachePath) {\n            return;\n        }\n        fs.unlink(this.cachePath, () => false);\n    }\n\n    createReadCache() {\n        // pipe remainings to cache file\n        this.cache = fs.createReadStream(this.cachePath);\n        this.cache.once('error', err => {\n            this.cleanup();\n            this.output.emit('error', err);\n        });\n        this.cache.once('close', () => {\n            this.cleanup();\n        });\n        this.cache.pipe(this.output);\n    }\n\n    sendNextChunk() {\n        if (this.hasErrored) {\n            return;\n        }\n\n        if (this.readPos >= this.chunks.length) {\n            if (!this.cache) {\n                return this.output.end();\n            }\n            return this.createReadCache();\n        }\n        let chunk = this.chunks[this.readPos++];\n        if (this.output.write(chunk) === false) {\n            return this.output.once('drain', () => {\n                this.sendNextChunk();\n            });\n        }\n        setImmediate(() => this.sendNextChunk());\n    }\n\n    sendSignedOutput() {\n        let keyPos = 0;\n        let signNextKey = () => {\n            if (keyPos >= this.keys.length) {\n                this.output.write(this.parser.rawHeaders);\n                return setImmediate(() => this.sendNextChunk());\n            }\n            let key = this.keys[keyPos++];\n            let dkimField = sign(this.headers, this.hashAlgo, this.bodyHash, {\n                domainName: key.domainName,\n                keySelector: key.keySelector,\n                privateKey: key.privateKey,\n                headerFieldNames: this.options.headerFieldNames,\n                skipFields: this.options.skipFields\n            });\n            if (dkimField) {\n                this.output.write(Buffer.from(dkimField + '\\r\\n'));\n            }\n            return setImmediate(signNextKey);\n        };\n\n        if (this.bodyHash && this.headers) {\n            return signNextKey();\n        }\n\n        this.output.write(this.parser.rawHeaders);\n        this.sendNextChunk();\n    }\n\n    createWriteCache() {\n        this.output.usingCache = true;\n        // pipe remainings to cache file\n        this.cache = fs.createWriteStream(this.cachePath);\n        this.cache.once('error', err => {\n            this.cleanup();\n            // drain input\n            this.relaxedBody.unpipe(this.cache);\n            this.relaxedBody.on('readable', () => {\n                while (this.relaxedBody.read() !== null) {\n                    // do nothing\n                }\n            });\n            this.hasErrored = true;\n            // emit error\n            this.output.emit('error', err);\n        });\n        this.cache.once('close', () => {\n            this.sendSignedOutput();\n        });\n        this.relaxedBody.removeAllListeners('readable');\n        this.relaxedBody.pipe(this.cache);\n    }\n\n    signStream() {\n        this.parser = new MessageParser();\n        this.relaxedBody = new RelaxedBody({\n            hashAlgo: this.hashAlgo\n        });\n\n        this.parser.on('headers', value => {\n            this.headers = value;\n        });\n\n        this.relaxedBody.on('hash', value => {\n            this.bodyHash = value;\n        });\n\n        this.relaxedBody.on('readable', () => {\n            let chunk;\n            if (this.cache) {\n                return;\n            }\n            while ((chunk = this.relaxedBody.read()) !== null) {\n                this.chunks.push(chunk);\n                this.chunklen += chunk.length;\n                if (this.chunklen >= this.cacheTreshold && this.cachePath) {\n                    return this.createWriteCache();\n                }\n            }\n        });\n\n        this.relaxedBody.on('end', () => {\n            if (this.cache) {\n                return;\n            }\n            this.sendSignedOutput();\n        });\n\n        this.parser.pipe(this.relaxedBody);\n        setImmediate(() => this.input.pipe(this.parser));\n    }\n}\n\nclass DKIM {\n    constructor(options) {\n        this.options = options || {};\n        this.keys = [].concat(\n            this.options.keys || {\n                domainName: options.domainName,\n                keySelector: options.keySelector,\n                privateKey: options.privateKey\n            }\n        );\n    }\n\n    sign(input, extraOptions) {\n        let output = new PassThrough();\n        let inputStream = input;\n        let writeValue = false;\n\n        if (Buffer.isBuffer(input)) {\n            writeValue = input;\n            inputStream = new PassThrough();\n        } else if (typeof input === 'string') {\n            writeValue = Buffer.from(input);\n            inputStream = new PassThrough();\n        }\n\n        let options = this.options;\n        if (extraOptions && Object.keys(extraOptions).length) {\n            options = {};\n            Object.keys(this.options || {}).forEach(key => {\n                options[key] = this.options[key];\n            });\n            Object.keys(extraOptions || {}).forEach(key => {\n                if (!(key in options)) {\n                    options[key] = extraOptions[key];\n                }\n            });\n        }\n\n        let signer = new DKIMSigner(options, this.keys, inputStream, output);\n        setImmediate(() => {\n            signer.signStream();\n            if (writeValue) {\n                setImmediate(() => {\n                    inputStream.end(writeValue);\n                });\n            }\n        });\n\n        return output;\n    }\n}\n\nmodule.exports = DKIM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvZGtpbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFrQjtBQUNoRCxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLGdFQUFRO0FBQzdCLG9CQUFvQix5REFBNkI7QUFDakQsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFL0I7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsYUFBYTtBQUNiLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9ka2ltL2luZGV4LmpzPzcyMGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBGSVhNRTpcbi8vIHJlcGxhY2UgdGhpcyBUcmFuc2Zvcm0gbWVzcyB3aXRoIGEgbWV0aG9kIHRoYXQgcGlwZXMgaW5wdXQgYXJndW1lbnQgdG8gb3V0cHV0IGFyZ3VtZW50XG5cbmNvbnN0IE1lc3NhZ2VQYXJzZXIgPSByZXF1aXJlKCcuL21lc3NhZ2UtcGFyc2VyJyk7XG5jb25zdCBSZWxheGVkQm9keSA9IHJlcXVpcmUoJy4vcmVsYXhlZC1ib2R5Jyk7XG5jb25zdCBzaWduID0gcmVxdWlyZSgnLi9zaWduJyk7XG5jb25zdCBQYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3N0cmVhbScpLlBhc3NUaHJvdWdoO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBES0lNX0FMR08gPSAnc2hhMjU2JztcbmNvbnN0IE1BWF9NRVNTQUdFX1NJWkUgPSAxMjggKiAxMDI0OyAvLyBidWZmZXIgbWVzc2FnZXMgbGFyZ2VyIHRoYW4gdGhpcyB0byBkaXNrXG5cbi8qXG4vLyBVc2FnZTpcblxubGV0IGRraW0gPSBuZXcgREtJTSh7XG4gICAgZG9tYWluTmFtZTogJ2V4YW1wbGUuY29tJyxcbiAgICBrZXlTZWxlY3RvcjogJ2tleS1zZWxlY3RvcicsXG4gICAgcHJpdmF0ZUtleSxcbiAgICBjYWNoZURpcjogJy90bXAnXG59KTtcbmRraW0uc2lnbihpbnB1dCkucGlwZShwcm9jZXNzLnN0ZG91dCk7XG5cbi8vIFdoZXJlIGlucHV0U3RyZWFtIGlzIGEgcmZjODIyIG1lc3NhZ2UgKGVpdGhlciBhIHN0cmVhbSwgc3RyaW5nIG9yIEJ1ZmZlcilcbi8vIGFuZCBvdXRwdXRTdHJlYW0gaXMgYSBES0lNIHNpZ25lZCByZmM4MjIgbWVzc2FnZVxuKi9cblxuY2xhc3MgREtJTVNpZ25lciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywga2V5cywgaW5wdXQsIG91dHB1dCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmtleXMgPSBrZXlzO1xuXG4gICAgICAgIHRoaXMuY2FjaGVUcmVzaG9sZCA9IE51bWJlcih0aGlzLm9wdGlvbnMuY2FjaGVUcmVzaG9sZCkgfHwgTUFYX01FU1NBR0VfU0laRTtcbiAgICAgICAgdGhpcy5oYXNoQWxnbyA9IHRoaXMub3B0aW9ucy5oYXNoQWxnbyB8fCBES0lNX0FMR087XG5cbiAgICAgICAgdGhpcy5jYWNoZURpciA9IHRoaXMub3B0aW9ucy5jYWNoZURpciB8fCBmYWxzZTtcblxuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rbGVuID0gMDtcbiAgICAgICAgdGhpcy5yZWFkUG9zID0gMDtcbiAgICAgICAgdGhpcy5jYWNoZVBhdGggPSB0aGlzLmNhY2hlRGlyID8gcGF0aC5qb2luKHRoaXMuY2FjaGVEaXIsICdtZXNzYWdlLicgKyBEYXRlLm5vdygpICsgJy0nICsgY3J5cHRvLnJhbmRvbUJ5dGVzKDE0KS50b1N0cmluZygnaGV4JykpIDogZmFsc2U7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ib2R5SGFzaCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcnNlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbGF4ZWRCb2R5ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICAgICAgdGhpcy5vdXRwdXQudXNpbmdDYWNoZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaGFzRXJyb3JlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaW5wdXQub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFzRXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgICAgIG91dHB1dC5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZSB8fCAhdGhpcy5jYWNoZVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmcy51bmxpbmsodGhpcy5jYWNoZVBhdGgsICgpID0+IGZhbHNlKTtcbiAgICB9XG5cbiAgICBjcmVhdGVSZWFkQ2FjaGUoKSB7XG4gICAgICAgIC8vIHBpcGUgcmVtYWluaW5ncyB0byBjYWNoZSBmaWxlXG4gICAgICAgIHRoaXMuY2FjaGUgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKHRoaXMuY2FjaGVQYXRoKTtcbiAgICAgICAgdGhpcy5jYWNoZS5vbmNlKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FjaGUub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FjaGUucGlwZSh0aGlzLm91dHB1dCk7XG4gICAgfVxuXG4gICAgc2VuZE5leHRDaHVuaygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRXJyb3JlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucmVhZFBvcyA+PSB0aGlzLmNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm91dHB1dC5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJlYWRDYWNoZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMuY2h1bmtzW3RoaXMucmVhZFBvcysrXTtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0LndyaXRlKGNodW5rKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm91dHB1dC5vbmNlKCdkcmFpbicsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmROZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLnNlbmROZXh0Q2h1bmsoKSk7XG4gICAgfVxuXG4gICAgc2VuZFNpZ25lZE91dHB1dCgpIHtcbiAgICAgICAgbGV0IGtleVBvcyA9IDA7XG4gICAgICAgIGxldCBzaWduTmV4dEtleSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXlQb3MgPj0gdGhpcy5rZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0LndyaXRlKHRoaXMucGFyc2VyLnJhd0hlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5zZW5kTmV4dENodW5rKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMua2V5c1trZXlQb3MrK107XG4gICAgICAgICAgICBsZXQgZGtpbUZpZWxkID0gc2lnbih0aGlzLmhlYWRlcnMsIHRoaXMuaGFzaEFsZ28sIHRoaXMuYm9keUhhc2gsIHtcbiAgICAgICAgICAgICAgICBkb21haW5OYW1lOiBrZXkuZG9tYWluTmFtZSxcbiAgICAgICAgICAgICAgICBrZXlTZWxlY3Rvcjoga2V5LmtleVNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6IGtleS5wcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgIGhlYWRlckZpZWxkTmFtZXM6IHRoaXMub3B0aW9ucy5oZWFkZXJGaWVsZE5hbWVzLFxuICAgICAgICAgICAgICAgIHNraXBGaWVsZHM6IHRoaXMub3B0aW9ucy5za2lwRmllbGRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChka2ltRmllbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dC53cml0ZShCdWZmZXIuZnJvbShka2ltRmllbGQgKyAnXFxyXFxuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShzaWduTmV4dEtleSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuYm9keUhhc2ggJiYgdGhpcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2lnbk5leHRLZXkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3V0cHV0LndyaXRlKHRoaXMucGFyc2VyLnJhd0hlYWRlcnMpO1xuICAgICAgICB0aGlzLnNlbmROZXh0Q2h1bmsoKTtcbiAgICB9XG5cbiAgICBjcmVhdGVXcml0ZUNhY2hlKCkge1xuICAgICAgICB0aGlzLm91dHB1dC51c2luZ0NhY2hlID0gdHJ1ZTtcbiAgICAgICAgLy8gcGlwZSByZW1haW5pbmdzIHRvIGNhY2hlIGZpbGVcbiAgICAgICAgdGhpcy5jYWNoZSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKHRoaXMuY2FjaGVQYXRoKTtcbiAgICAgICAgdGhpcy5jYWNoZS5vbmNlKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgICAgIC8vIGRyYWluIGlucHV0XG4gICAgICAgICAgICB0aGlzLnJlbGF4ZWRCb2R5LnVucGlwZSh0aGlzLmNhY2hlKTtcbiAgICAgICAgICAgIHRoaXMucmVsYXhlZEJvZHkub24oJ3JlYWRhYmxlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLnJlbGF4ZWRCb2R5LnJlYWQoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmhhc0Vycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gZW1pdCBlcnJvclxuICAgICAgICAgICAgdGhpcy5vdXRwdXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWNoZS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFNpZ25lZE91dHB1dCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWxheGVkQm9keS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlYWRhYmxlJyk7XG4gICAgICAgIHRoaXMucmVsYXhlZEJvZHkucGlwZSh0aGlzLmNhY2hlKTtcbiAgICB9XG5cbiAgICBzaWduU3RyZWFtKCkge1xuICAgICAgICB0aGlzLnBhcnNlciA9IG5ldyBNZXNzYWdlUGFyc2VyKCk7XG4gICAgICAgIHRoaXMucmVsYXhlZEJvZHkgPSBuZXcgUmVsYXhlZEJvZHkoe1xuICAgICAgICAgICAgaGFzaEFsZ286IHRoaXMuaGFzaEFsZ29cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5wYXJzZXIub24oJ2hlYWRlcnMnLCB2YWx1ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSB2YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZWxheGVkQm9keS5vbignaGFzaCcsIHZhbHVlID0+IHtcbiAgICAgICAgICAgIHRoaXMuYm9keUhhc2ggPSB2YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZWxheGVkQm9keS5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2h1bms7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICgoY2h1bmsgPSB0aGlzLnJlbGF4ZWRCb2R5LnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rbGVuICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaHVua2xlbiA+PSB0aGlzLmNhY2hlVHJlc2hvbGQgJiYgdGhpcy5jYWNoZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlV3JpdGVDYWNoZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZWxheGVkQm9keS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbmRTaWduZWRPdXRwdXQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5wYXJzZXIucGlwZSh0aGlzLnJlbGF4ZWRCb2R5KTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuaW5wdXQucGlwZSh0aGlzLnBhcnNlcikpO1xuICAgIH1cbn1cblxuY2xhc3MgREtJTSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmtleXMgPSBbXS5jb25jYXQoXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMua2V5cyB8fCB7XG4gICAgICAgICAgICAgICAgZG9tYWluTmFtZTogb3B0aW9ucy5kb21haW5OYW1lLFxuICAgICAgICAgICAgICAgIGtleVNlbGVjdG9yOiBvcHRpb25zLmtleVNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6IG9wdGlvbnMucHJpdmF0ZUtleVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNpZ24oaW5wdXQsIGV4dHJhT3B0aW9ucykge1xuICAgICAgICBsZXQgb3V0cHV0ID0gbmV3IFBhc3NUaHJvdWdoKCk7XG4gICAgICAgIGxldCBpbnB1dFN0cmVhbSA9IGlucHV0O1xuICAgICAgICBsZXQgd3JpdGVWYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICB3cml0ZVZhbHVlID0gaW5wdXQ7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHdyaXRlVmFsdWUgPSBCdWZmZXIuZnJvbShpbnB1dCk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChleHRyYU9wdGlvbnMgJiYgT2JqZWN0LmtleXMoZXh0cmFPcHRpb25zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucyB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHRoaXMub3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhleHRyYU9wdGlvbnMgfHwge30pLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gZXh0cmFPcHRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2lnbmVyID0gbmV3IERLSU1TaWduZXIob3B0aW9ucywgdGhpcy5rZXlzLCBpbnB1dFN0cmVhbSwgb3V0cHV0KTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHNpZ25lci5zaWduU3RyZWFtKCk7XG4gICAgICAgICAgICBpZiAod3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0U3RyZWFtLmVuZCh3cml0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gREtJTTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/dkim/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/dkim/message-parser.js":
/*!************************************************************!*\
  !*** ./node_modules/nodemailer/lib/dkim/message-parser.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\n\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\nclass MessageParser extends Transform {\n    constructor(options) {\n        super(options);\n        this.lastBytes = Buffer.alloc(4);\n        this.headersParsed = false;\n        this.headerBytes = 0;\n        this.headerChunks = [];\n        this.rawHeaders = false;\n        this.bodySize = 0;\n    }\n\n    /**\n     * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n     *\n     * @param {Buffer} data Next data chunk from the stream\n     */\n    updateLastBytes(data) {\n        let lblen = this.lastBytes.length;\n        let nblen = Math.min(data.length, lblen);\n\n        // shift existing bytes\n        for (let i = 0, len = lblen - nblen; i < len; i++) {\n            this.lastBytes[i] = this.lastBytes[i + nblen];\n        }\n\n        // add new bytes\n        for (let i = 1; i <= nblen; i++) {\n            this.lastBytes[lblen - i] = data[data.length - i];\n        }\n    }\n\n    /**\n     * Finds and removes message headers from the remaining body. We want to keep\n     * headers separated until final delivery to be able to modify these\n     *\n     * @param {Buffer} data Next chunk of data\n     * @return {Boolean} Returns true if headers are already found or false otherwise\n     */\n    checkHeaders(data) {\n        if (this.headersParsed) {\n            return true;\n        }\n\n        let lblen = this.lastBytes.length;\n        let headerPos = 0;\n        this.curLinePos = 0;\n        for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n            let chr;\n            if (i < lblen) {\n                chr = this.lastBytes[i];\n            } else {\n                chr = data[i - lblen];\n            }\n            if (chr === 0x0a && i) {\n                let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n                let pr2 = i > 1 ? (i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen]) : false;\n                if (pr1 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                } else if (pr1 === 0x0d && pr2 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                }\n            }\n        }\n\n        if (this.headersParsed) {\n            this.headerChunks.push(data.slice(0, headerPos));\n            this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.headerChunks = null;\n            this.emit('headers', this.parseHeaders());\n            if (data.length - 1 > headerPos) {\n                let chunk = data.slice(headerPos);\n                this.bodySize += chunk.length;\n                // this would be the first chunk of data sent downstream\n                setImmediate(() => this.push(chunk));\n            }\n            return false;\n        } else {\n            this.headerBytes += data.length;\n            this.headerChunks.push(data);\n        }\n\n        // store last 4 bytes to catch header break\n        this.updateLastBytes(data);\n\n        return false;\n    }\n\n    _transform(chunk, encoding, callback) {\n        if (!chunk || !chunk.length) {\n            return callback();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        let headersFound;\n\n        try {\n            headersFound = this.checkHeaders(chunk);\n        } catch (E) {\n            return callback(E);\n        }\n\n        if (headersFound) {\n            this.bodySize += chunk.length;\n            this.push(chunk);\n        }\n\n        setImmediate(callback);\n    }\n\n    _flush(callback) {\n        if (this.headerChunks) {\n            let chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.bodySize += chunk.length;\n            this.push(chunk);\n            this.headerChunks = null;\n        }\n        callback();\n    }\n\n    parseHeaders() {\n        let lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n        for (let i = lines.length - 1; i > 0; i--) {\n            if (/^\\s/.test(lines[i])) {\n                lines[i - 1] += '\\n' + lines[i];\n                lines.splice(i, 1);\n            }\n        }\n        return lines\n            .filter(line => line.trim())\n            .map(line => ({\n                key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n                line\n            }));\n    }\n}\n\nmodule.exports = MessageParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvZGtpbS9tZXNzYWdlLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsdURBQTJCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxTQUFTO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VtYXJrZXQvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvZGtpbS9tZXNzYWdlLXBhcnNlci5qcz9jMjk2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtO1xuXG4vKipcbiAqIE1lc3NhZ2VQYXJzZXIgaW5zdGFuY2UgaXMgYSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgc2VwYXJhdGVzIG1lc3NhZ2UgaGVhZGVyc1xuICogZnJvbSB0aGUgcmVzdCBvZiB0aGUgYm9keS4gSGVhZGVycyBhcmUgZW1pdHRlZCB3aXRoIHRoZSAnaGVhZGVycycgZXZlbnQuIE1lc3NhZ2VcbiAqIGJvZHkgaXMgcGFzc2VkIG9uIGFzIHRoZSByZXN1bHRpbmcgc3RyZWFtLlxuICovXG5jbGFzcyBNZXNzYWdlUGFyc2VyIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxhc3RCeXRlcyA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgdGhpcy5oZWFkZXJzUGFyc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGVhZGVyQnl0ZXMgPSAwO1xuICAgICAgICB0aGlzLmhlYWRlckNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLnJhd0hlYWRlcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ib2R5U2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogS2VlcHMgY291bnQgb2YgdGhlIGxhc3QgNCBieXRlcyBpbiBvcmRlciB0byBkZXRlY3QgbGluZSBicmVha3Mgb24gY2h1bmsgYm91bmRhcmllc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgTmV4dCBkYXRhIGNodW5rIGZyb20gdGhlIHN0cmVhbVxuICAgICAqL1xuICAgIHVwZGF0ZUxhc3RCeXRlcyhkYXRhKSB7XG4gICAgICAgIGxldCBsYmxlbiA9IHRoaXMubGFzdEJ5dGVzLmxlbmd0aDtcbiAgICAgICAgbGV0IG5ibGVuID0gTWF0aC5taW4oZGF0YS5sZW5ndGgsIGxibGVuKTtcblxuICAgICAgICAvLyBzaGlmdCBleGlzdGluZyBieXRlc1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGJsZW4gLSBuYmxlbjsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RCeXRlc1tpXSA9IHRoaXMubGFzdEJ5dGVzW2kgKyBuYmxlbl07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgbmV3IGJ5dGVzXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG5ibGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEJ5dGVzW2xibGVuIC0gaV0gPSBkYXRhW2RhdGEubGVuZ3RoIC0gaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbmQgcmVtb3ZlcyBtZXNzYWdlIGhlYWRlcnMgZnJvbSB0aGUgcmVtYWluaW5nIGJvZHkuIFdlIHdhbnQgdG8ga2VlcFxuICAgICAqIGhlYWRlcnMgc2VwYXJhdGVkIHVudGlsIGZpbmFsIGRlbGl2ZXJ5IHRvIGJlIGFibGUgdG8gbW9kaWZ5IHRoZXNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBOZXh0IGNodW5rIG9mIGRhdGFcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgaGVhZGVycyBhcmUgYWxyZWFkeSBmb3VuZCBvciBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBjaGVja0hlYWRlcnMoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5oZWFkZXJzUGFyc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsYmxlbiA9IHRoaXMubGFzdEJ5dGVzLmxlbmd0aDtcbiAgICAgICAgbGV0IGhlYWRlclBvcyA9IDA7XG4gICAgICAgIHRoaXMuY3VyTGluZVBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmxhc3RCeXRlcy5sZW5ndGggKyBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hyO1xuICAgICAgICAgICAgaWYgKGkgPCBsYmxlbikge1xuICAgICAgICAgICAgICAgIGNociA9IHRoaXMubGFzdEJ5dGVzW2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBkYXRhW2kgLSBsYmxlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hyID09PSAweDBhICYmIGkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHIxID0gaSAtIDEgPCBsYmxlbiA/IHRoaXMubGFzdEJ5dGVzW2kgLSAxXSA6IGRhdGFbaSAtIDEgLSBsYmxlbl07XG4gICAgICAgICAgICAgICAgbGV0IHByMiA9IGkgPiAxID8gKGkgLSAyIDwgbGJsZW4gPyB0aGlzLmxhc3RCeXRlc1tpIC0gMl0gOiBkYXRhW2kgLSAyIC0gbGJsZW5dKSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChwcjEgPT09IDB4MGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzUGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyUG9zID0gaSAtIGxibGVuICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJCeXRlcyArPSBoZWFkZXJQb3M7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHIxID09PSAweDBkICYmIHByMiA9PT0gMHgwYSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnNQYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJQb3MgPSBpIC0gbGJsZW4gKyAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWRlckJ5dGVzICs9IGhlYWRlclBvcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc1BhcnNlZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJDaHVua3MucHVzaChkYXRhLnNsaWNlKDAsIGhlYWRlclBvcykpO1xuICAgICAgICAgICAgdGhpcy5yYXdIZWFkZXJzID0gQnVmZmVyLmNvbmNhdCh0aGlzLmhlYWRlckNodW5rcywgdGhpcy5oZWFkZXJCeXRlcyk7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckNodW5rcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2hlYWRlcnMnLCB0aGlzLnBhcnNlSGVhZGVycygpKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAtIDEgPiBoZWFkZXJQb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2h1bmsgPSBkYXRhLnNsaWNlKGhlYWRlclBvcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5U2l6ZSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3b3VsZCBiZSB0aGUgZmlyc3QgY2h1bmsgb2YgZGF0YSBzZW50IGRvd25zdHJlYW1cbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5wdXNoKGNodW5rKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckJ5dGVzICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJDaHVua3MucHVzaChkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3JlIGxhc3QgNCBieXRlcyB0byBjYXRjaCBoZWFkZXIgYnJlYWtcbiAgICAgICAgdGhpcy51cGRhdGVMYXN0Qnl0ZXMoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBoZWFkZXJzRm91bmQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGhlYWRlcnNGb3VuZCA9IHRoaXMuY2hlY2tIZWFkZXJzKGNodW5rKTtcbiAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlYWRlcnNGb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5ib2R5U2l6ZSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyQ2h1bmtzKSB7XG4gICAgICAgICAgICBsZXQgY2h1bmsgPSBCdWZmZXIuY29uY2F0KHRoaXMuaGVhZGVyQ2h1bmtzLCB0aGlzLmhlYWRlckJ5dGVzKTtcbiAgICAgICAgICAgIHRoaXMuYm9keVNpemUgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyQ2h1bmtzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHBhcnNlSGVhZGVycygpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gKHRoaXMucmF3SGVhZGVycyB8fCAnJykudG9TdHJpbmcoKS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgICAgICBmb3IgKGxldCBpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKC9eXFxzLy50ZXN0KGxpbmVzW2ldKSkge1xuICAgICAgICAgICAgICAgIGxpbmVzW2kgLSAxXSArPSAnXFxuJyArIGxpbmVzW2ldO1xuICAgICAgICAgICAgICAgIGxpbmVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXNcbiAgICAgICAgICAgIC5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSlcbiAgICAgICAgICAgIC5tYXAobGluZSA9PiAoe1xuICAgICAgICAgICAgICAgIGtleTogbGluZS5zdWJzdHIoMCwgbGluZS5pbmRleE9mKCc6JykpLnRyaW0oKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIGxpbmVcbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZVBhcnNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/dkim/message-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/dkim/relaxed-body.js":
/*!**********************************************************!*\
  !*** ./node_modules/nodemailer/lib/dkim/relaxed-body.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// streams through a message body and calculates relaxed body hash\n\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nclass RelaxedBody extends Transform {\n    constructor(options) {\n        super();\n        options = options || {};\n        this.chunkBuffer = [];\n        this.chunkBufferLen = 0;\n        this.bodyHash = crypto.createHash(options.hashAlgo || 'sha1');\n        this.remainder = '';\n        this.byteLength = 0;\n\n        this.debug = options.debug;\n        this._debugBody = options.debug ? [] : false;\n    }\n\n    updateHash(chunk) {\n        let bodyStr;\n\n        // find next remainder\n        let nextRemainder = '';\n\n        // This crux finds and removes the spaces from the last line and the newline characters after the last non-empty line\n        // If we get another chunk that does not match this description then we can restore the previously processed data\n        let state = 'file';\n        for (let i = chunk.length - 1; i >= 0; i--) {\n            let c = chunk[i];\n\n            if (state === 'file' && (c === 0x0a || c === 0x0d)) {\n                // do nothing, found \\n or \\r at the end of chunk, stil end of file\n            } else if (state === 'file' && (c === 0x09 || c === 0x20)) {\n                // switch to line ending mode, this is the last non-empty line\n                state = 'line';\n            } else if (state === 'line' && (c === 0x09 || c === 0x20)) {\n                // do nothing, found ' ' or \\t at the end of line, keep processing the last non-empty line\n            } else if (state === 'file' || state === 'line') {\n                // non line/file ending character found, switch to body mode\n                state = 'body';\n                if (i === chunk.length - 1) {\n                    // final char is not part of line end or file end, so do nothing\n                    break;\n                }\n            }\n\n            if (i === 0) {\n                // reached to the beginning of the chunk, check if it is still about the ending\n                // and if the remainder also matches\n                if (\n                    (state === 'file' && (!this.remainder || /[\\r\\n]$/.test(this.remainder))) ||\n                    (state === 'line' && (!this.remainder || /[ \\t]$/.test(this.remainder)))\n                ) {\n                    // keep everything\n                    this.remainder += chunk.toString('binary');\n                    return;\n                } else if (state === 'line' || state === 'file') {\n                    // process existing remainder as normal line but store the current chunk\n                    nextRemainder = chunk.toString('binary');\n                    chunk = false;\n                    break;\n                }\n            }\n\n            if (state !== 'body') {\n                continue;\n            }\n\n            // reached first non ending byte\n            nextRemainder = chunk.slice(i + 1).toString('binary');\n            chunk = chunk.slice(0, i + 1);\n            break;\n        }\n\n        let needsFixing = !!this.remainder;\n        if (chunk && !needsFixing) {\n            // check if we even need to change anything\n            for (let i = 0, len = chunk.length; i < len; i++) {\n                if (i && chunk[i] === 0x0a && chunk[i - 1] !== 0x0d) {\n                    // missing \\r before \\n\n                    needsFixing = true;\n                    break;\n                } else if (i && chunk[i] === 0x0d && chunk[i - 1] === 0x20) {\n                    // trailing WSP found\n                    needsFixing = true;\n                    break;\n                } else if (i && chunk[i] === 0x20 && chunk[i - 1] === 0x20) {\n                    // multiple spaces found, needs to be replaced with just one\n                    needsFixing = true;\n                    break;\n                } else if (chunk[i] === 0x09) {\n                    // TAB found, needs to be replaced with a space\n                    needsFixing = true;\n                    break;\n                }\n            }\n        }\n\n        if (needsFixing) {\n            bodyStr = this.remainder + (chunk ? chunk.toString('binary') : '');\n            this.remainder = nextRemainder;\n            bodyStr = bodyStr\n                .replace(/\\r?\\n/g, '\\n') // use js line endings\n                .replace(/[ \\t]*$/gm, '') // remove line endings, rtrim\n                .replace(/[ \\t]+/gm, ' ') // single spaces\n                .replace(/\\n/g, '\\r\\n'); // restore rfc822 line endings\n            chunk = Buffer.from(bodyStr, 'binary');\n        } else if (nextRemainder) {\n            this.remainder = nextRemainder;\n        }\n\n        if (this.debug) {\n            this._debugBody.push(chunk);\n        }\n        this.bodyHash.update(chunk);\n    }\n\n    _transform(chunk, encoding, callback) {\n        if (!chunk || !chunk.length) {\n            return callback();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        this.updateHash(chunk);\n\n        this.byteLength += chunk.length;\n        this.push(chunk);\n        callback();\n    }\n\n    _flush(callback) {\n        // generate final hash and emit it\n        if (/[\\r\\n]$/.test(this.remainder) && this.byteLength > 2) {\n            // add terminating line end\n            this.bodyHash.update(Buffer.from('\\r\\n'));\n        }\n        if (!this.byteLength) {\n            // emit empty line buffer to keep the stream flowing\n            this.push(Buffer.from('\\r\\n'));\n            // this.bodyHash.update(Buffer.from('\\r\\n'));\n        }\n\n        this.emit('hash', this.bodyHash.digest('base64'), this.debug ? Buffer.concat(this._debugBody) : false);\n        callback();\n    }\n}\n\nmodule.exports = RelaxedBody;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvZGtpbS9yZWxheGVkLWJvZHkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUEsa0JBQWtCLHVEQUEyQjtBQUM3QyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VtYXJrZXQvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvZGtpbS9yZWxheGVkLWJvZHkuanM/NDA2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIHN0cmVhbXMgdGhyb3VnaCBhIG1lc3NhZ2UgYm9keSBhbmQgY2FsY3VsYXRlcyByZWxheGVkIGJvZHkgaGFzaFxuXG5jb25zdCBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm07XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY2xhc3MgUmVsYXhlZEJvZHkgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuY2h1bmtCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua0J1ZmZlckxlbiA9IDA7XG4gICAgICAgIHRoaXMuYm9keUhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChvcHRpb25zLmhhc2hBbGdvIHx8ICdzaGExJyk7XG4gICAgICAgIHRoaXMucmVtYWluZGVyID0gJyc7XG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IDA7XG5cbiAgICAgICAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAgIHRoaXMuX2RlYnVnQm9keSA9IG9wdGlvbnMuZGVidWcgPyBbXSA6IGZhbHNlO1xuICAgIH1cblxuICAgIHVwZGF0ZUhhc2goY2h1bmspIHtcbiAgICAgICAgbGV0IGJvZHlTdHI7XG5cbiAgICAgICAgLy8gZmluZCBuZXh0IHJlbWFpbmRlclxuICAgICAgICBsZXQgbmV4dFJlbWFpbmRlciA9ICcnO1xuXG4gICAgICAgIC8vIFRoaXMgY3J1eCBmaW5kcyBhbmQgcmVtb3ZlcyB0aGUgc3BhY2VzIGZyb20gdGhlIGxhc3QgbGluZSBhbmQgdGhlIG5ld2xpbmUgY2hhcmFjdGVycyBhZnRlciB0aGUgbGFzdCBub24tZW1wdHkgbGluZVxuICAgICAgICAvLyBJZiB3ZSBnZXQgYW5vdGhlciBjaHVuayB0aGF0IGRvZXMgbm90IG1hdGNoIHRoaXMgZGVzY3JpcHRpb24gdGhlbiB3ZSBjYW4gcmVzdG9yZSB0aGUgcHJldmlvdXNseSBwcm9jZXNzZWQgZGF0YVxuICAgICAgICBsZXQgc3RhdGUgPSAnZmlsZSc7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaHVuay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGMgPSBjaHVua1tpXTtcblxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZmlsZScgJiYgKGMgPT09IDB4MGEgfHwgYyA9PT0gMHgwZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nLCBmb3VuZCBcXG4gb3IgXFxyIGF0IHRoZSBlbmQgb2YgY2h1bmssIHN0aWwgZW5kIG9mIGZpbGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdmaWxlJyAmJiAoYyA9PT0gMHgwOSB8fCBjID09PSAweDIwKSkge1xuICAgICAgICAgICAgICAgIC8vIHN3aXRjaCB0byBsaW5lIGVuZGluZyBtb2RlLCB0aGlzIGlzIHRoZSBsYXN0IG5vbi1lbXB0eSBsaW5lXG4gICAgICAgICAgICAgICAgc3RhdGUgPSAnbGluZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnbGluZScgJiYgKGMgPT09IDB4MDkgfHwgYyA9PT0gMHgyMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nLCBmb3VuZCAnICcgb3IgXFx0IGF0IHRoZSBlbmQgb2YgbGluZSwga2VlcCBwcm9jZXNzaW5nIHRoZSBsYXN0IG5vbi1lbXB0eSBsaW5lXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnZmlsZScgfHwgc3RhdGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgICAgIC8vIG5vbiBsaW5lL2ZpbGUgZW5kaW5nIGNoYXJhY3RlciBmb3VuZCwgc3dpdGNoIHRvIGJvZHkgbW9kZVxuICAgICAgICAgICAgICAgIHN0YXRlID0gJ2JvZHknO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBjaHVuay5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmFsIGNoYXIgaXMgbm90IHBhcnQgb2YgbGluZSBlbmQgb3IgZmlsZSBlbmQsIHNvIGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHJlYWNoZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgY2h1bmssIGNoZWNrIGlmIGl0IGlzIHN0aWxsIGFib3V0IHRoZSBlbmRpbmdcbiAgICAgICAgICAgICAgICAvLyBhbmQgaWYgdGhlIHJlbWFpbmRlciBhbHNvIG1hdGNoZXNcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZSA9PT0gJ2ZpbGUnICYmICghdGhpcy5yZW1haW5kZXIgfHwgL1tcXHJcXG5dJC8udGVzdCh0aGlzLnJlbWFpbmRlcikpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoc3RhdGUgPT09ICdsaW5lJyAmJiAoIXRoaXMucmVtYWluZGVyIHx8IC9bIFxcdF0kLy50ZXN0KHRoaXMucmVtYWluZGVyKSkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgZXZlcnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbWFpbmRlciArPSBjaHVuay50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnbGluZScgfHwgc3RhdGUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGV4aXN0aW5nIHJlbWFpbmRlciBhcyBub3JtYWwgbGluZSBidXQgc3RvcmUgdGhlIGN1cnJlbnQgY2h1bmtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlbWFpbmRlciA9IGNodW5rLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZWFjaGVkIGZpcnN0IG5vbiBlbmRpbmcgYnl0ZVxuICAgICAgICAgICAgbmV4dFJlbWFpbmRlciA9IGNodW5rLnNsaWNlKGkgKyAxKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICAgICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5lZWRzRml4aW5nID0gISF0aGlzLnJlbWFpbmRlcjtcbiAgICAgICAgaWYgKGNodW5rICYmICFuZWVkc0ZpeGluZykge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgZXZlbiBuZWVkIHRvIGNoYW5nZSBhbnl0aGluZ1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNodW5rLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgJiYgY2h1bmtbaV0gPT09IDB4MGEgJiYgY2h1bmtbaSAtIDFdICE9PSAweDBkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1pc3NpbmcgXFxyIGJlZm9yZSBcXG5cbiAgICAgICAgICAgICAgICAgICAgbmVlZHNGaXhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgJiYgY2h1bmtbaV0gPT09IDB4MGQgJiYgY2h1bmtbaSAtIDFdID09PSAweDIwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYWlsaW5nIFdTUCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICBuZWVkc0ZpeGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSAmJiBjaHVua1tpXSA9PT0gMHgyMCAmJiBjaHVua1tpIC0gMV0gPT09IDB4MjApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbXVsdGlwbGUgc3BhY2VzIGZvdW5kLCBuZWVkcyB0byBiZSByZXBsYWNlZCB3aXRoIGp1c3Qgb25lXG4gICAgICAgICAgICAgICAgICAgIG5lZWRzRml4aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaHVua1tpXSA9PT0gMHgwOSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUQUIgZm91bmQsIG5lZWRzIHRvIGJlIHJlcGxhY2VkIHdpdGggYSBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBuZWVkc0ZpeGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZWVkc0ZpeGluZykge1xuICAgICAgICAgICAgYm9keVN0ciA9IHRoaXMucmVtYWluZGVyICsgKGNodW5rID8gY2h1bmsudG9TdHJpbmcoJ2JpbmFyeScpIDogJycpO1xuICAgICAgICAgICAgdGhpcy5yZW1haW5kZXIgPSBuZXh0UmVtYWluZGVyO1xuICAgICAgICAgICAgYm9keVN0ciA9IGJvZHlTdHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxyP1xcbi9nLCAnXFxuJykgLy8gdXNlIGpzIGxpbmUgZW5kaW5nc1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bIFxcdF0qJC9nbSwgJycpIC8vIHJlbW92ZSBsaW5lIGVuZGluZ3MsIHJ0cmltXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1sgXFx0XSsvZ20sICcgJykgLy8gc2luZ2xlIHNwYWNlc1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcclxcbicpOyAvLyByZXN0b3JlIHJmYzgyMiBsaW5lIGVuZGluZ3NcbiAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oYm9keVN0ciwgJ2JpbmFyeScpO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRSZW1haW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVtYWluZGVyID0gbmV4dFJlbWFpbmRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1Z0JvZHkucHVzaChjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5SGFzaC51cGRhdGUoY2h1bmspO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlSGFzaChjaHVuayk7XG5cbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wdXNoKGNodW5rKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgLy8gZ2VuZXJhdGUgZmluYWwgaGFzaCBhbmQgZW1pdCBpdFxuICAgICAgICBpZiAoL1tcXHJcXG5dJC8udGVzdCh0aGlzLnJlbWFpbmRlcikgJiYgdGhpcy5ieXRlTGVuZ3RoID4gMikge1xuICAgICAgICAgICAgLy8gYWRkIHRlcm1pbmF0aW5nIGxpbmUgZW5kXG4gICAgICAgICAgICB0aGlzLmJvZHlIYXNoLnVwZGF0ZShCdWZmZXIuZnJvbSgnXFxyXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBlbWl0IGVtcHR5IGxpbmUgYnVmZmVyIHRvIGtlZXAgdGhlIHN0cmVhbSBmbG93aW5nXG4gICAgICAgICAgICB0aGlzLnB1c2goQnVmZmVyLmZyb20oJ1xcclxcbicpKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYm9keUhhc2gudXBkYXRlKEJ1ZmZlci5mcm9tKCdcXHJcXG4nKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ2hhc2gnLCB0aGlzLmJvZHlIYXNoLmRpZ2VzdCgnYmFzZTY0JyksIHRoaXMuZGVidWcgPyBCdWZmZXIuY29uY2F0KHRoaXMuX2RlYnVnQm9keSkgOiBmYWxzZSk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbGF4ZWRCb2R5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/dkim/relaxed-body.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/dkim/sign.js":
/*!**************************************************!*\
  !*** ./node_modules/nodemailer/lib/dkim/sign.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst punycode = __webpack_require__(/*! ../punycode */ \"(rsc)/./node_modules/nodemailer/lib/punycode/index.js\");\nconst mimeFuncs = __webpack_require__(/*! ../mime-funcs */ \"(rsc)/./node_modules/nodemailer/lib/mime-funcs/index.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\n/**\n * Returns DKIM signature header line\n *\n * @param {Object} headers Parsed headers object from MessageParser\n * @param {String} bodyHash Base64 encoded hash of the message\n * @param {Object} options DKIM options\n * @param {String} options.domainName Domain name to be signed for\n * @param {String} options.keySelector DKIM key selector to use\n * @param {String} options.privateKey DKIM private key to use\n * @return {String} Complete header line\n */\n\nmodule.exports = (headers, hashAlgo, bodyHash, options) => {\n    options = options || {};\n\n    // all listed fields from RFC4871 #5.5\n    let defaultFieldNames =\n        'From:Sender:Reply-To:Subject:Date:Message-ID:To:' +\n        'Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:' +\n        'Content-Description:Resent-Date:Resent-From:Resent-Sender:' +\n        'Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:' +\n        'List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:' +\n        'List-Owner:List-Archive';\n\n    let fieldNames = options.headerFieldNames || defaultFieldNames;\n\n    let canonicalizedHeaderData = relaxedHeaders(headers, fieldNames, options.skipFields);\n    let dkimHeader = generateDKIMHeader(options.domainName, options.keySelector, canonicalizedHeaderData.fieldNames, hashAlgo, bodyHash);\n\n    let signer, signature;\n\n    canonicalizedHeaderData.headers += 'dkim-signature:' + relaxedHeaderLine(dkimHeader);\n\n    signer = crypto.createSign(('rsa-' + hashAlgo).toUpperCase());\n    signer.update(canonicalizedHeaderData.headers);\n    try {\n        signature = signer.sign(options.privateKey, 'base64');\n    } catch (E) {\n        return false;\n    }\n\n    return dkimHeader + signature.replace(/(^.{73}|.{75}(?!\\r?\\n|\\r))/g, '$&\\r\\n ').trim();\n};\n\nmodule.exports.relaxedHeaders = relaxedHeaders;\n\nfunction generateDKIMHeader(domainName, keySelector, fieldNames, hashAlgo, bodyHash) {\n    let dkim = [\n        'v=1',\n        'a=rsa-' + hashAlgo,\n        'c=relaxed/relaxed',\n        'd=' + punycode.toASCII(domainName),\n        'q=dns/txt',\n        's=' + keySelector,\n        'bh=' + bodyHash,\n        'h=' + fieldNames\n    ].join('; ');\n\n    return mimeFuncs.foldLines('DKIM-Signature: ' + dkim, 76) + ';\\r\\n b=';\n}\n\nfunction relaxedHeaders(headers, fieldNames, skipFields) {\n    let includedFields = new Set();\n    let skip = new Set();\n    let headerFields = new Map();\n\n    (skipFields || '')\n        .toLowerCase()\n        .split(':')\n        .forEach(field => {\n            skip.add(field.trim());\n        });\n\n    (fieldNames || '')\n        .toLowerCase()\n        .split(':')\n        .filter(field => !skip.has(field.trim()))\n        .forEach(field => {\n            includedFields.add(field.trim());\n        });\n\n    for (let i = headers.length - 1; i >= 0; i--) {\n        let line = headers[i];\n        // only include the first value from bottom to top\n        if (includedFields.has(line.key) && !headerFields.has(line.key)) {\n            headerFields.set(line.key, relaxedHeaderLine(line.line));\n        }\n    }\n\n    let headersList = [];\n    let fields = [];\n    includedFields.forEach(field => {\n        if (headerFields.has(field)) {\n            fields.push(field);\n            headersList.push(field + ':' + headerFields.get(field));\n        }\n    });\n\n    return {\n        headers: headersList.join('\\r\\n') + '\\r\\n',\n        fieldNames: fields.join(':')\n    };\n}\n\nfunction relaxedHeaderLine(line) {\n    return line\n        .substr(line.indexOf(':') + 1)\n        .replace(/\\r?\\n/g, '')\n        .replace(/\\s+/g, ' ')\n        .trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvZGtpbS9zaWduLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFhO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFlO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsK0NBQStDLEdBQUcsR0FBRyxHQUFHO0FBQ3hEOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtFQUFrRTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlbWFya2V0Ly4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL2RraW0vc2lnbi5qcz81NTE1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcHVueWNvZGUgPSByZXF1aXJlKCcuLi9wdW55Y29kZScpO1xuY29uc3QgbWltZUZ1bmNzID0gcmVxdWlyZSgnLi4vbWltZS1mdW5jcycpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbi8qKlxuICogUmV0dXJucyBES0lNIHNpZ25hdHVyZSBoZWFkZXIgbGluZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIFBhcnNlZCBoZWFkZXJzIG9iamVjdCBmcm9tIE1lc3NhZ2VQYXJzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBib2R5SGFzaCBCYXNlNjQgZW5jb2RlZCBoYXNoIG9mIHRoZSBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBES0lNIG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmRvbWFpbk5hbWUgRG9tYWluIG5hbWUgdG8gYmUgc2lnbmVkIGZvclxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMua2V5U2VsZWN0b3IgREtJTSBrZXkgc2VsZWN0b3IgdG8gdXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5wcml2YXRlS2V5IERLSU0gcHJpdmF0ZSBrZXkgdG8gdXNlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IENvbXBsZXRlIGhlYWRlciBsaW5lXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSAoaGVhZGVycywgaGFzaEFsZ28sIGJvZHlIYXNoLCBvcHRpb25zKSA9PiB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBhbGwgbGlzdGVkIGZpZWxkcyBmcm9tIFJGQzQ4NzEgIzUuNVxuICAgIGxldCBkZWZhdWx0RmllbGROYW1lcyA9XG4gICAgICAgICdGcm9tOlNlbmRlcjpSZXBseS1UbzpTdWJqZWN0OkRhdGU6TWVzc2FnZS1JRDpUbzonICtcbiAgICAgICAgJ0NjOk1JTUUtVmVyc2lvbjpDb250ZW50LVR5cGU6Q29udGVudC1UcmFuc2Zlci1FbmNvZGluZzpDb250ZW50LUlEOicgK1xuICAgICAgICAnQ29udGVudC1EZXNjcmlwdGlvbjpSZXNlbnQtRGF0ZTpSZXNlbnQtRnJvbTpSZXNlbnQtU2VuZGVyOicgK1xuICAgICAgICAnUmVzZW50LVRvOlJlc2VudC1DYzpSZXNlbnQtTWVzc2FnZS1JRDpJbi1SZXBseS1UbzpSZWZlcmVuY2VzOicgK1xuICAgICAgICAnTGlzdC1JZDpMaXN0LUhlbHA6TGlzdC1VbnN1YnNjcmliZTpMaXN0LVN1YnNjcmliZTpMaXN0LVBvc3Q6JyArXG4gICAgICAgICdMaXN0LU93bmVyOkxpc3QtQXJjaGl2ZSc7XG5cbiAgICBsZXQgZmllbGROYW1lcyA9IG9wdGlvbnMuaGVhZGVyRmllbGROYW1lcyB8fCBkZWZhdWx0RmllbGROYW1lcztcblxuICAgIGxldCBjYW5vbmljYWxpemVkSGVhZGVyRGF0YSA9IHJlbGF4ZWRIZWFkZXJzKGhlYWRlcnMsIGZpZWxkTmFtZXMsIG9wdGlvbnMuc2tpcEZpZWxkcyk7XG4gICAgbGV0IGRraW1IZWFkZXIgPSBnZW5lcmF0ZURLSU1IZWFkZXIob3B0aW9ucy5kb21haW5OYW1lLCBvcHRpb25zLmtleVNlbGVjdG9yLCBjYW5vbmljYWxpemVkSGVhZGVyRGF0YS5maWVsZE5hbWVzLCBoYXNoQWxnbywgYm9keUhhc2gpO1xuXG4gICAgbGV0IHNpZ25lciwgc2lnbmF0dXJlO1xuXG4gICAgY2Fub25pY2FsaXplZEhlYWRlckRhdGEuaGVhZGVycyArPSAnZGtpbS1zaWduYXR1cmU6JyArIHJlbGF4ZWRIZWFkZXJMaW5lKGRraW1IZWFkZXIpO1xuXG4gICAgc2lnbmVyID0gY3J5cHRvLmNyZWF0ZVNpZ24oKCdyc2EtJyArIGhhc2hBbGdvKS50b1VwcGVyQ2FzZSgpKTtcbiAgICBzaWduZXIudXBkYXRlKGNhbm9uaWNhbGl6ZWRIZWFkZXJEYXRhLmhlYWRlcnMpO1xuICAgIHRyeSB7XG4gICAgICAgIHNpZ25hdHVyZSA9IHNpZ25lci5zaWduKG9wdGlvbnMucHJpdmF0ZUtleSwgJ2Jhc2U2NCcpO1xuICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBka2ltSGVhZGVyICsgc2lnbmF0dXJlLnJlcGxhY2UoLyheLns3M318Lns3NX0oPyFcXHI/XFxufFxccikpL2csICckJlxcclxcbiAnKS50cmltKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5yZWxheGVkSGVhZGVycyA9IHJlbGF4ZWRIZWFkZXJzO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZURLSU1IZWFkZXIoZG9tYWluTmFtZSwga2V5U2VsZWN0b3IsIGZpZWxkTmFtZXMsIGhhc2hBbGdvLCBib2R5SGFzaCkge1xuICAgIGxldCBka2ltID0gW1xuICAgICAgICAndj0xJyxcbiAgICAgICAgJ2E9cnNhLScgKyBoYXNoQWxnbyxcbiAgICAgICAgJ2M9cmVsYXhlZC9yZWxheGVkJyxcbiAgICAgICAgJ2Q9JyArIHB1bnljb2RlLnRvQVNDSUkoZG9tYWluTmFtZSksXG4gICAgICAgICdxPWRucy90eHQnLFxuICAgICAgICAncz0nICsga2V5U2VsZWN0b3IsXG4gICAgICAgICdiaD0nICsgYm9keUhhc2gsXG4gICAgICAgICdoPScgKyBmaWVsZE5hbWVzXG4gICAgXS5qb2luKCc7ICcpO1xuXG4gICAgcmV0dXJuIG1pbWVGdW5jcy5mb2xkTGluZXMoJ0RLSU0tU2lnbmF0dXJlOiAnICsgZGtpbSwgNzYpICsgJztcXHJcXG4gYj0nO1xufVxuXG5mdW5jdGlvbiByZWxheGVkSGVhZGVycyhoZWFkZXJzLCBmaWVsZE5hbWVzLCBza2lwRmllbGRzKSB7XG4gICAgbGV0IGluY2x1ZGVkRmllbGRzID0gbmV3IFNldCgpO1xuICAgIGxldCBza2lwID0gbmV3IFNldCgpO1xuICAgIGxldCBoZWFkZXJGaWVsZHMgPSBuZXcgTWFwKCk7XG5cbiAgICAoc2tpcEZpZWxkcyB8fCAnJylcbiAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgLnNwbGl0KCc6JylcbiAgICAgICAgLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgc2tpcC5hZGQoZmllbGQudHJpbSgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAoZmllbGROYW1lcyB8fCAnJylcbiAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgLnNwbGl0KCc6JylcbiAgICAgICAgLmZpbHRlcihmaWVsZCA9PiAhc2tpcC5oYXMoZmllbGQudHJpbSgpKSlcbiAgICAgICAgLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaW5jbHVkZWRGaWVsZHMuYWRkKGZpZWxkLnRyaW0oKSk7XG4gICAgICAgIH0pO1xuXG4gICAgZm9yIChsZXQgaSA9IGhlYWRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGxpbmUgPSBoZWFkZXJzW2ldO1xuICAgICAgICAvLyBvbmx5IGluY2x1ZGUgdGhlIGZpcnN0IHZhbHVlIGZyb20gYm90dG9tIHRvIHRvcFxuICAgICAgICBpZiAoaW5jbHVkZWRGaWVsZHMuaGFzKGxpbmUua2V5KSAmJiAhaGVhZGVyRmllbGRzLmhhcyhsaW5lLmtleSkpIHtcbiAgICAgICAgICAgIGhlYWRlckZpZWxkcy5zZXQobGluZS5rZXksIHJlbGF4ZWRIZWFkZXJMaW5lKGxpbmUubGluZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGhlYWRlcnNMaXN0ID0gW107XG4gICAgbGV0IGZpZWxkcyA9IFtdO1xuICAgIGluY2x1ZGVkRmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICBpZiAoaGVhZGVyRmllbGRzLmhhcyhmaWVsZCkpIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIGhlYWRlcnNMaXN0LnB1c2goZmllbGQgKyAnOicgKyBoZWFkZXJGaWVsZHMuZ2V0KGZpZWxkKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnNMaXN0LmpvaW4oJ1xcclxcbicpICsgJ1xcclxcbicsXG4gICAgICAgIGZpZWxkTmFtZXM6IGZpZWxkcy5qb2luKCc6JylcbiAgICB9O1xufVxuXG5mdW5jdGlvbiByZWxheGVkSGVhZGVyTGluZShsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmVcbiAgICAgICAgLnN1YnN0cihsaW5lLmluZGV4T2YoJzonKSArIDEpXG4gICAgICAgIC5yZXBsYWNlKC9cXHI/XFxuL2csICcnKVxuICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgICAgIC50cmltKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/dkim/sign.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/fetch/cookies.js":
/*!******************************************************!*\
  !*** ./node_modules/nodemailer/lib/fetch/cookies.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// module to handle cookies\n\nconst urllib = __webpack_require__(/*! url */ \"url\");\n\nconst SESSION_TIMEOUT = 1800; // 30 min\n\n/**\n * Creates a biskviit cookie jar for managing cookie values in memory\n *\n * @constructor\n * @param {Object} [options] Optional options object\n */\nclass Cookies {\n    constructor(options) {\n        this.options = options || {};\n        this.cookies = [];\n    }\n\n    /**\n     * Stores a cookie string to the cookie storage\n     *\n     * @param {String} cookieStr Value from the 'Set-Cookie:' header\n     * @param {String} url Current URL\n     */\n    set(cookieStr, url) {\n        let urlparts = urllib.parse(url || '');\n        let cookie = this.parse(cookieStr);\n        let domain;\n\n        if (cookie.domain) {\n            domain = cookie.domain.replace(/^\\./, '');\n\n            // do not allow cross origin cookies\n            if (\n                // can't be valid if the requested domain is shorter than current hostname\n                urlparts.hostname.length < domain.length ||\n                // prefix domains with dot to be sure that partial matches are not used\n                ('.' + urlparts.hostname).substr(-domain.length + 1) !== '.' + domain\n            ) {\n                cookie.domain = urlparts.hostname;\n            }\n        } else {\n            cookie.domain = urlparts.hostname;\n        }\n\n        if (!cookie.path) {\n            cookie.path = this.getPath(urlparts.pathname);\n        }\n\n        // if no expire date, then use sessionTimeout value\n        if (!cookie.expires) {\n            cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);\n        }\n\n        return this.add(cookie);\n    }\n\n    /**\n     * Returns cookie string for the 'Cookie:' header.\n     *\n     * @param {String} url URL to check for\n     * @returns {String} Cookie header or empty string if no matches were found\n     */\n    get(url) {\n        return this.list(url)\n            .map(cookie => cookie.name + '=' + cookie.value)\n            .join('; ');\n    }\n\n    /**\n     * Lists all valied cookie objects for the specified URL\n     *\n     * @param {String} url URL to check for\n     * @returns {Array} An array of cookie objects\n     */\n    list(url) {\n        let result = [];\n        let i;\n        let cookie;\n\n        for (i = this.cookies.length - 1; i >= 0; i--) {\n            cookie = this.cookies[i];\n\n            if (this.isExpired(cookie)) {\n                this.cookies.splice(i, i);\n                continue;\n            }\n\n            if (this.match(cookie, url)) {\n                result.unshift(cookie);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Parses cookie string from the 'Set-Cookie:' header\n     *\n     * @param {String} cookieStr String from the 'Set-Cookie:' header\n     * @returns {Object} Cookie object\n     */\n    parse(cookieStr) {\n        let cookie = {};\n\n        (cookieStr || '')\n            .toString()\n            .split(';')\n            .forEach(cookiePart => {\n                let valueParts = cookiePart.split('=');\n                let key = valueParts.shift().trim().toLowerCase();\n                let value = valueParts.join('=').trim();\n                let domain;\n\n                if (!key) {\n                    // skip empty parts\n                    return;\n                }\n\n                switch (key) {\n                    case 'expires':\n                        value = new Date(value);\n                        // ignore date if can not parse it\n                        if (value.toString() !== 'Invalid Date') {\n                            cookie.expires = value;\n                        }\n                        break;\n\n                    case 'path':\n                        cookie.path = value;\n                        break;\n\n                    case 'domain':\n                        domain = value.toLowerCase();\n                        if (domain.length && domain.charAt(0) !== '.') {\n                            domain = '.' + domain; // ensure preceeding dot for user set domains\n                        }\n                        cookie.domain = domain;\n                        break;\n\n                    case 'max-age':\n                        cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);\n                        break;\n\n                    case 'secure':\n                        cookie.secure = true;\n                        break;\n\n                    case 'httponly':\n                        cookie.httponly = true;\n                        break;\n\n                    default:\n                        if (!cookie.name) {\n                            cookie.name = key;\n                            cookie.value = value;\n                        }\n                }\n            });\n\n        return cookie;\n    }\n\n    /**\n     * Checks if a cookie object is valid for a specified URL\n     *\n     * @param {Object} cookie Cookie object\n     * @param {String} url URL to check for\n     * @returns {Boolean} true if cookie is valid for specifiec URL\n     */\n    match(cookie, url) {\n        let urlparts = urllib.parse(url || '');\n\n        // check if hostname matches\n        // .foo.com also matches subdomains, foo.com does not\n        if (\n            urlparts.hostname !== cookie.domain &&\n            (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)\n        ) {\n            return false;\n        }\n\n        // check if path matches\n        let path = this.getPath(urlparts.pathname);\n        if (path.substr(0, cookie.path.length) !== cookie.path) {\n            return false;\n        }\n\n        // check secure argument\n        if (cookie.secure && urlparts.protocol !== 'https:') {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Adds (or updates/removes if needed) a cookie object to the cookie storage\n     *\n     * @param {Object} cookie Cookie value to be stored\n     */\n    add(cookie) {\n        let i;\n        let len;\n\n        // nothing to do here\n        if (!cookie || !cookie.name) {\n            return false;\n        }\n\n        // overwrite if has same params\n        for (i = 0, len = this.cookies.length; i < len; i++) {\n            if (this.compare(this.cookies[i], cookie)) {\n                // check if the cookie needs to be removed instead\n                if (this.isExpired(cookie)) {\n                    this.cookies.splice(i, 1); // remove expired/unset cookie\n                    return false;\n                }\n\n                this.cookies[i] = cookie;\n                return true;\n            }\n        }\n\n        // add as new if not already expired\n        if (!this.isExpired(cookie)) {\n            this.cookies.push(cookie);\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if two cookie objects are the same\n     *\n     * @param {Object} a Cookie to check against\n     * @param {Object} b Cookie to check against\n     * @returns {Boolean} True, if the cookies are the same\n     */\n    compare(a, b) {\n        return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;\n    }\n\n    /**\n     * Checks if a cookie is expired\n     *\n     * @param {Object} cookie Cookie object to check against\n     * @returns {Boolean} True, if the cookie is expired\n     */\n    isExpired(cookie) {\n        return (cookie.expires && cookie.expires < new Date()) || !cookie.value;\n    }\n\n    /**\n     * Returns normalized cookie path for an URL path argument\n     *\n     * @param {String} pathname\n     * @returns {String} Normalized path\n     */\n    getPath(pathname) {\n        let path = (pathname || '/').split('/');\n        path.pop(); // remove filename part\n        path = path.join('/').trim();\n\n        // ensure path prefix /\n        if (path.charAt(0) !== '/') {\n            path = '/' + path;\n        }\n\n        // ensure path suffix /\n        if (path.substr(-1) !== '/') {\n            path += '/';\n        }\n\n        return path;\n    }\n}\n\nmodule.exports = Cookies;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvZmV0Y2gvY29va2llcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQSxlQUFlLG1CQUFPLENBQUMsZ0JBQUs7O0FBRTVCLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsUUFBUTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9mZXRjaC9jb29raWVzLmpzPzhjN2UiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBtb2R1bGUgdG8gaGFuZGxlIGNvb2tpZXNcblxuY29uc3QgdXJsbGliID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFNFU1NJT05fVElNRU9VVCA9IDE4MDA7IC8vIDMwIG1pblxuXG4vKipcbiAqIENyZWF0ZXMgYSBiaXNrdmlpdCBjb29raWUgamFyIGZvciBtYW5hZ2luZyBjb29raWUgdmFsdWVzIGluIG1lbW9yeVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zIG9iamVjdFxuICovXG5jbGFzcyBDb29raWVzIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuY29va2llcyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyBhIGNvb2tpZSBzdHJpbmcgdG8gdGhlIGNvb2tpZSBzdG9yYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29va2llU3RyIFZhbHVlIGZyb20gdGhlICdTZXQtQ29va2llOicgaGVhZGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBDdXJyZW50IFVSTFxuICAgICAqL1xuICAgIHNldChjb29raWVTdHIsIHVybCkge1xuICAgICAgICBsZXQgdXJscGFydHMgPSB1cmxsaWIucGFyc2UodXJsIHx8ICcnKTtcbiAgICAgICAgbGV0IGNvb2tpZSA9IHRoaXMucGFyc2UoY29va2llU3RyKTtcbiAgICAgICAgbGV0IGRvbWFpbjtcblxuICAgICAgICBpZiAoY29va2llLmRvbWFpbikge1xuICAgICAgICAgICAgZG9tYWluID0gY29va2llLmRvbWFpbi5yZXBsYWNlKC9eXFwuLywgJycpO1xuXG4gICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgY3Jvc3Mgb3JpZ2luIGNvb2tpZXNcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBjYW4ndCBiZSB2YWxpZCBpZiB0aGUgcmVxdWVzdGVkIGRvbWFpbiBpcyBzaG9ydGVyIHRoYW4gY3VycmVudCBob3N0bmFtZVxuICAgICAgICAgICAgICAgIHVybHBhcnRzLmhvc3RuYW1lLmxlbmd0aCA8IGRvbWFpbi5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAvLyBwcmVmaXggZG9tYWlucyB3aXRoIGRvdCB0byBiZSBzdXJlIHRoYXQgcGFydGlhbCBtYXRjaGVzIGFyZSBub3QgdXNlZFxuICAgICAgICAgICAgICAgICgnLicgKyB1cmxwYXJ0cy5ob3N0bmFtZSkuc3Vic3RyKC1kb21haW4ubGVuZ3RoICsgMSkgIT09ICcuJyArIGRvbWFpblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29va2llLmRvbWFpbiA9IHVybHBhcnRzLmhvc3RuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29va2llLmRvbWFpbiA9IHVybHBhcnRzLmhvc3RuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb29raWUucGF0aCkge1xuICAgICAgICAgICAgY29va2llLnBhdGggPSB0aGlzLmdldFBhdGgodXJscGFydHMucGF0aG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm8gZXhwaXJlIGRhdGUsIHRoZW4gdXNlIHNlc3Npb25UaW1lb3V0IHZhbHVlXG4gICAgICAgIGlmICghY29va2llLmV4cGlyZXMpIHtcbiAgICAgICAgICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIChOdW1iZXIodGhpcy5vcHRpb25zLnNlc3Npb25UaW1lb3V0IHx8IFNFU1NJT05fVElNRU9VVCkgfHwgU0VTU0lPTl9USU1FT1VUKSAqIDEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGNvb2tpZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29raWUgc3RyaW5nIGZvciB0aGUgJ0Nvb2tpZTonIGhlYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIGNoZWNrIGZvclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IENvb2tpZSBoZWFkZXIgb3IgZW1wdHkgc3RyaW5nIGlmIG5vIG1hdGNoZXMgd2VyZSBmb3VuZFxuICAgICAqL1xuICAgIGdldCh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdCh1cmwpXG4gICAgICAgICAgICAubWFwKGNvb2tpZSA9PiBjb29raWUubmFtZSArICc9JyArIGNvb2tpZS52YWx1ZSlcbiAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCB2YWxpZWQgY29va2llIG9iamVjdHMgZm9yIHRoZSBzcGVjaWZpZWQgVVJMXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byBjaGVjayBmb3JcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGNvb2tpZSBvYmplY3RzXG4gICAgICovXG4gICAgbGlzdCh1cmwpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGNvb2tpZTtcblxuICAgICAgICBmb3IgKGkgPSB0aGlzLmNvb2tpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvb2tpZSA9IHRoaXMuY29va2llc1tpXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNFeHBpcmVkKGNvb2tpZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvb2tpZXMuc3BsaWNlKGksIGkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5tYXRjaChjb29raWUsIHVybCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudW5zaGlmdChjb29raWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgY29va2llIHN0cmluZyBmcm9tIHRoZSAnU2V0LUNvb2tpZTonIGhlYWRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvb2tpZVN0ciBTdHJpbmcgZnJvbSB0aGUgJ1NldC1Db29raWU6JyBoZWFkZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBDb29raWUgb2JqZWN0XG4gICAgICovXG4gICAgcGFyc2UoY29va2llU3RyKSB7XG4gICAgICAgIGxldCBjb29raWUgPSB7fTtcblxuICAgICAgICAoY29va2llU3RyIHx8ICcnKVxuICAgICAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgICAgIC5zcGxpdCgnOycpXG4gICAgICAgICAgICAuZm9yRWFjaChjb29raWVQYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVQYXJ0cyA9IGNvb2tpZVBhcnQuc3BsaXQoJz0nKTtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gdmFsdWVQYXJ0cy5zaGlmdCgpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlUGFydHMuam9pbignPScpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9tYWluO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBlbXB0eSBwYXJ0c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXhwaXJlcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBkYXRlIGlmIGNhbiBub3QgcGFyc2UgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50b1N0cmluZygpICE9PSAnSW52YWxpZCBEYXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZS5leHBpcmVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdwYXRoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZS5wYXRoID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkb21haW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4ubGVuZ3RoICYmIGRvbWFpbi5jaGFyQXQoMCkgIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9ICcuJyArIGRvbWFpbjsgLy8gZW5zdXJlIHByZWNlZWRpbmcgZG90IGZvciB1c2VyIHNldCBkb21haW5zXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29raWUuZG9tYWluID0gZG9tYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWF4LWFnZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29raWUuZXhwaXJlcyA9IG5ldyBEYXRlKERhdGUubm93KCkgKyAoTnVtYmVyKHZhbHVlKSB8fCAwKSAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VjdXJlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaHR0cG9ubHknOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2llLmh0dHBvbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvb2tpZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2llLm5hbWUgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2llLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBjb29raWUgb2JqZWN0IGlzIHZhbGlkIGZvciBhIHNwZWNpZmllZCBVUkxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb29raWUgQ29va2llIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIGNoZWNrIGZvclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGNvb2tpZSBpcyB2YWxpZCBmb3Igc3BlY2lmaWVjIFVSTFxuICAgICAqL1xuICAgIG1hdGNoKGNvb2tpZSwgdXJsKSB7XG4gICAgICAgIGxldCB1cmxwYXJ0cyA9IHVybGxpYi5wYXJzZSh1cmwgfHwgJycpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGhvc3RuYW1lIG1hdGNoZXNcbiAgICAgICAgLy8gLmZvby5jb20gYWxzbyBtYXRjaGVzIHN1YmRvbWFpbnMsIGZvby5jb20gZG9lcyBub3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdXJscGFydHMuaG9zdG5hbWUgIT09IGNvb2tpZS5kb21haW4gJiZcbiAgICAgICAgICAgIChjb29raWUuZG9tYWluLmNoYXJBdCgwKSAhPT0gJy4nIHx8ICgnLicgKyB1cmxwYXJ0cy5ob3N0bmFtZSkuc3Vic3RyKC1jb29raWUuZG9tYWluLmxlbmd0aCkgIT09IGNvb2tpZS5kb21haW4pXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgcGF0aCBtYXRjaGVzXG4gICAgICAgIGxldCBwYXRoID0gdGhpcy5nZXRQYXRoKHVybHBhcnRzLnBhdGhuYW1lKTtcbiAgICAgICAgaWYgKHBhdGguc3Vic3RyKDAsIGNvb2tpZS5wYXRoLmxlbmd0aCkgIT09IGNvb2tpZS5wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBzZWN1cmUgYXJndW1lbnRcbiAgICAgICAgaWYgKGNvb2tpZS5zZWN1cmUgJiYgdXJscGFydHMucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIChvciB1cGRhdGVzL3JlbW92ZXMgaWYgbmVlZGVkKSBhIGNvb2tpZSBvYmplY3QgdG8gdGhlIGNvb2tpZSBzdG9yYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29va2llIENvb2tpZSB2YWx1ZSB0byBiZSBzdG9yZWRcbiAgICAgKi9cbiAgICBhZGQoY29va2llKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuO1xuXG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG8gaGVyZVxuICAgICAgICBpZiAoIWNvb2tpZSB8fCAhY29va2llLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG92ZXJ3cml0ZSBpZiBoYXMgc2FtZSBwYXJhbXNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5jb29raWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlKHRoaXMuY29va2llc1tpXSwgY29va2llKSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjb29raWUgbmVlZHMgdG8gYmUgcmVtb3ZlZCBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFeHBpcmVkKGNvb2tpZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29raWVzLnNwbGljZShpLCAxKTsgLy8gcmVtb3ZlIGV4cGlyZWQvdW5zZXQgY29va2llXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvb2tpZXNbaV0gPSBjb29raWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgYXMgbmV3IGlmIG5vdCBhbHJlYWR5IGV4cGlyZWRcbiAgICAgICAgaWYgKCF0aGlzLmlzRXhwaXJlZChjb29raWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvb2tpZXMucHVzaChjb29raWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHR3byBjb29raWUgb2JqZWN0cyBhcmUgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhIENvb2tpZSB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGIgQ29va2llIHRvIGNoZWNrIGFnYWluc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSwgaWYgdGhlIGNvb2tpZXMgYXJlIHRoZSBzYW1lXG4gICAgICovXG4gICAgY29tcGFyZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm5hbWUgPT09IGIubmFtZSAmJiBhLnBhdGggPT09IGIucGF0aCAmJiBhLmRvbWFpbiA9PT0gYi5kb21haW4gJiYgYS5zZWN1cmUgPT09IGIuc2VjdXJlICYmIGEuaHR0cG9ubHkgPT09IGEuaHR0cG9ubHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgY29va2llIGlzIGV4cGlyZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb29raWUgQ29va2llIG9iamVjdCB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUsIGlmIHRoZSBjb29raWUgaXMgZXhwaXJlZFxuICAgICAqL1xuICAgIGlzRXhwaXJlZChjb29raWUpIHtcbiAgICAgICAgcmV0dXJuIChjb29raWUuZXhwaXJlcyAmJiBjb29raWUuZXhwaXJlcyA8IG5ldyBEYXRlKCkpIHx8ICFjb29raWUudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBub3JtYWxpemVkIGNvb2tpZSBwYXRoIGZvciBhbiBVUkwgcGF0aCBhcmd1bWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhuYW1lXG4gICAgICogQHJldHVybnMge1N0cmluZ30gTm9ybWFsaXplZCBwYXRoXG4gICAgICovXG4gICAgZ2V0UGF0aChwYXRobmFtZSkge1xuICAgICAgICBsZXQgcGF0aCA9IChwYXRobmFtZSB8fCAnLycpLnNwbGl0KCcvJyk7XG4gICAgICAgIHBhdGgucG9wKCk7IC8vIHJlbW92ZSBmaWxlbmFtZSBwYXJ0XG4gICAgICAgIHBhdGggPSBwYXRoLmpvaW4oJy8nKS50cmltKCk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHBhdGggcHJlZml4IC9cbiAgICAgICAgaWYgKHBhdGguY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgICAgICAgIHBhdGggPSAnLycgKyBwYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHBhdGggc3VmZml4IC9cbiAgICAgICAgaWYgKHBhdGguc3Vic3RyKC0xKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICBwYXRoICs9ICcvJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb29raWVzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/fetch/cookies.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/fetch/index.js":
/*!****************************************************!*\
  !*** ./node_modules/nodemailer/lib/fetch/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst urllib = __webpack_require__(/*! url */ \"url\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nconst Cookies = __webpack_require__(/*! ./cookies */ \"(rsc)/./node_modules/nodemailer/lib/fetch/cookies.js\");\nconst packageData = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/nodemailer/package.json\");\nconst net = __webpack_require__(/*! net */ \"net\");\n\nconst MAX_REDIRECTS = 5;\n\nmodule.exports = function (url, options) {\n    return nmfetch(url, options);\n};\n\nmodule.exports.Cookies = Cookies;\n\nfunction nmfetch(url, options) {\n    options = options || {};\n\n    options.fetchRes = options.fetchRes || new PassThrough();\n    options.cookies = options.cookies || new Cookies();\n    options.redirects = options.redirects || 0;\n    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;\n\n    if (options.cookie) {\n        [].concat(options.cookie || []).forEach(cookie => {\n            options.cookies.set(cookie, url);\n        });\n        options.cookie = false;\n    }\n\n    let fetchRes = options.fetchRes;\n    let parsed = urllib.parse(url);\n    let method = (options.method || '').toString().trim().toUpperCase() || 'GET';\n    let finished = false;\n    let cookies;\n    let body;\n\n    let handler = parsed.protocol === 'https:' ? https : http;\n\n    let headers = {\n        'accept-encoding': 'gzip,deflate',\n        'user-agent': 'nodemailer/' + packageData.version\n    };\n\n    Object.keys(options.headers || {}).forEach(key => {\n        headers[key.toLowerCase().trim()] = options.headers[key];\n    });\n\n    if (options.userAgent) {\n        headers['user-agent'] = options.userAgent;\n    }\n\n    if (parsed.auth) {\n        headers.Authorization = 'Basic ' + Buffer.from(parsed.auth).toString('base64');\n    }\n\n    if ((cookies = options.cookies.get(url))) {\n        headers.cookie = cookies;\n    }\n\n    if (options.body) {\n        if (options.contentType !== false) {\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n        }\n\n        if (typeof options.body.pipe === 'function') {\n            // it's a stream\n            headers['Transfer-Encoding'] = 'chunked';\n            body = options.body;\n            body.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n            });\n        } else {\n            if (options.body instanceof Buffer) {\n                body = options.body;\n            } else if (typeof options.body === 'object') {\n                try {\n                    // encodeURIComponent can fail on invalid input (partial emoji etc.)\n                    body = Buffer.from(\n                        Object.keys(options.body)\n                            .map(key => {\n                                let value = options.body[key].toString().trim();\n                                return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n                            })\n                            .join('&')\n                    );\n                } catch (E) {\n                    if (finished) {\n                        return;\n                    }\n                    finished = true;\n                    E.type = 'FETCH';\n                    E.sourceUrl = url;\n                    fetchRes.emit('error', E);\n                    return;\n                }\n            } else {\n                body = Buffer.from(options.body.toString().trim());\n            }\n\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n            headers['Content-Length'] = body.length;\n        }\n        // if method is not provided, use POST instead of GET\n        method = (options.method || '').toString().trim().toUpperCase() || 'POST';\n    }\n\n    let req;\n    let reqOptions = {\n        method,\n        host: parsed.hostname,\n        path: parsed.path,\n        port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,\n        headers,\n        rejectUnauthorized: false,\n        agent: false\n    };\n\n    if (options.tls) {\n        Object.keys(options.tls).forEach(key => {\n            reqOptions[key] = options.tls[key];\n        });\n    }\n\n    if (parsed.protocol === 'https:' && parsed.hostname && parsed.hostname !== reqOptions.host && !net.isIP(parsed.hostname) && !reqOptions.servername) {\n        reqOptions.servername = parsed.hostname;\n    }\n\n    try {\n        req = handler.request(reqOptions);\n    } catch (E) {\n        finished = true;\n        setImmediate(() => {\n            E.type = 'FETCH';\n            E.sourceUrl = url;\n            fetchRes.emit('error', E);\n        });\n        return fetchRes;\n    }\n\n    if (options.timeout) {\n        req.setTimeout(options.timeout, () => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            req.abort();\n            let err = new Error('Request Timeout');\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n        });\n    }\n\n    req.on('error', err => {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n    });\n\n    req.on('response', res => {\n        let inflate;\n\n        if (finished) {\n            return;\n        }\n\n        switch (res.headers['content-encoding']) {\n            case 'gzip':\n            case 'deflate':\n                inflate = zlib.createUnzip();\n                break;\n        }\n\n        if (res.headers['set-cookie']) {\n            [].concat(res.headers['set-cookie'] || []).forEach(cookie => {\n                options.cookies.set(cookie, url);\n            });\n        }\n\n        if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {\n            // redirect\n            options.redirects++;\n            if (options.redirects > options.maxRedirects) {\n                finished = true;\n                let err = new Error('Maximum redirect count exceeded');\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n                return;\n            }\n            // redirect does not include POST body\n            options.method = 'GET';\n            options.body = false;\n            return nmfetch(urllib.resolve(url, res.headers.location), options);\n        }\n\n        fetchRes.statusCode = res.statusCode;\n        fetchRes.headers = res.headers;\n\n        if (res.statusCode >= 300 && !options.allowErrorResponse) {\n            finished = true;\n            let err = new Error('Invalid status code ' + res.statusCode);\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n            return;\n        }\n\n        res.on('error', err => {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            err.type = 'FETCH';\n            err.sourceUrl = url;\n            fetchRes.emit('error', err);\n            req.abort();\n        });\n\n        if (inflate) {\n            res.pipe(inflate).pipe(fetchRes);\n            inflate.on('error', err => {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                req.abort();\n            });\n        } else {\n            res.pipe(fetchRes);\n        }\n    });\n\n    setImmediate(() => {\n        if (body) {\n            try {\n                if (typeof body.pipe === 'function') {\n                    return body.pipe(req);\n                } else {\n                    req.write(body);\n                }\n            } catch (err) {\n                finished = true;\n                err.type = 'FETCH';\n                err.sourceUrl = url;\n                fetchRes.emit('error', err);\n                return;\n            }\n        }\n        req.end();\n    });\n\n    return fetchRes;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvZmV0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixlQUFlLG1CQUFPLENBQUMsZ0JBQUs7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLG9CQUFvQix5REFBNkI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsdUVBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsd0VBQW9CO0FBQ2hELFlBQVksbUJBQU8sQ0FBQyxnQkFBSzs7QUFFekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VtYXJrZXQvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvZmV0Y2gvaW5kZXguanM/NjdhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCB1cmxsaWIgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5jb25zdCBQYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3N0cmVhbScpLlBhc3NUaHJvdWdoO1xuY29uc3QgQ29va2llcyA9IHJlcXVpcmUoJy4vY29va2llcycpO1xuY29uc3QgcGFja2FnZURhdGEgPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuXG5jb25zdCBNQVhfUkVESVJFQ1RTID0gNTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5tZmV0Y2godXJsLCBvcHRpb25zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvb2tpZXMgPSBDb29raWVzO1xuXG5mdW5jdGlvbiBubWZldGNoKHVybCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgb3B0aW9ucy5mZXRjaFJlcyA9IG9wdGlvbnMuZmV0Y2hSZXMgfHwgbmV3IFBhc3NUaHJvdWdoKCk7XG4gICAgb3B0aW9ucy5jb29raWVzID0gb3B0aW9ucy5jb29raWVzIHx8IG5ldyBDb29raWVzKCk7XG4gICAgb3B0aW9ucy5yZWRpcmVjdHMgPSBvcHRpb25zLnJlZGlyZWN0cyB8fCAwO1xuICAgIG9wdGlvbnMubWF4UmVkaXJlY3RzID0gaXNOYU4ob3B0aW9ucy5tYXhSZWRpcmVjdHMpID8gTUFYX1JFRElSRUNUUyA6IG9wdGlvbnMubWF4UmVkaXJlY3RzO1xuXG4gICAgaWYgKG9wdGlvbnMuY29va2llKSB7XG4gICAgICAgIFtdLmNvbmNhdChvcHRpb25zLmNvb2tpZSB8fCBbXSkuZm9yRWFjaChjb29raWUgPT4ge1xuICAgICAgICAgICAgb3B0aW9ucy5jb29raWVzLnNldChjb29raWUsIHVybCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zLmNvb2tpZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBmZXRjaFJlcyA9IG9wdGlvbnMuZmV0Y2hSZXM7XG4gICAgbGV0IHBhcnNlZCA9IHVybGxpYi5wYXJzZSh1cmwpO1xuICAgIGxldCBtZXRob2QgPSAob3B0aW9ucy5tZXRob2QgfHwgJycpLnRvU3RyaW5nKCkudHJpbSgpLnRvVXBwZXJDYXNlKCkgfHwgJ0dFVCc7XG4gICAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG4gICAgbGV0IGNvb2tpZXM7XG4gICAgbGV0IGJvZHk7XG5cbiAgICBsZXQgaGFuZGxlciA9IHBhcnNlZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBodHRwcyA6IGh0dHA7XG5cbiAgICBsZXQgaGVhZGVycyA9IHtcbiAgICAgICAgJ2FjY2VwdC1lbmNvZGluZyc6ICdnemlwLGRlZmxhdGUnLFxuICAgICAgICAndXNlci1hZ2VudCc6ICdub2RlbWFpbGVyLycgKyBwYWNrYWdlRGF0YS52ZXJzaW9uXG4gICAgfTtcblxuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMuaGVhZGVycyB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpLnRyaW0oKV0gPSBvcHRpb25zLmhlYWRlcnNba2V5XTtcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLnVzZXJBZ2VudCkge1xuICAgICAgICBoZWFkZXJzWyd1c2VyLWFnZW50J10gPSBvcHRpb25zLnVzZXJBZ2VudDtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VkLmF1dGgpIHtcbiAgICAgICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShwYXJzZWQuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cblxuICAgIGlmICgoY29va2llcyA9IG9wdGlvbnMuY29va2llcy5nZXQodXJsKSkpIHtcbiAgICAgICAgaGVhZGVycy5jb29raWUgPSBjb29raWVzO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudFR5cGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IG9wdGlvbnMuY29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYm9keS5waXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBpdCdzIGEgc3RyZWFtXG4gICAgICAgICAgICBoZWFkZXJzWydUcmFuc2Zlci1FbmNvZGluZyddID0gJ2NodW5rZWQnO1xuICAgICAgICAgICAgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgICAgICAgIGJvZHkub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyLnR5cGUgPSAnRkVUQ0gnO1xuICAgICAgICAgICAgICAgIGVyci5zb3VyY2VVcmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgZmV0Y2hSZXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ib2R5IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuYm9keSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQgY2FuIGZhaWwgb24gaW52YWxpZCBpbnB1dCAocGFydGlhbCBlbW9qaSBldGMuKVxuICAgICAgICAgICAgICAgICAgICBib2R5ID0gQnVmZmVyLmZyb20oXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLmJvZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBvcHRpb25zLmJvZHlba2V5XS50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcmJylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgRS50eXBlID0gJ0ZFVENIJztcbiAgICAgICAgICAgICAgICAgICAgRS5zb3VyY2VVcmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoUmVzLmVtaXQoJ2Vycm9yJywgRSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBCdWZmZXIuZnJvbShvcHRpb25zLmJvZHkudG9TdHJpbmcoKS50cmltKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IG9wdGlvbnMuY29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gYm9keS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbWV0aG9kIGlzIG5vdCBwcm92aWRlZCwgdXNlIFBPU1QgaW5zdGVhZCBvZiBHRVRcbiAgICAgICAgbWV0aG9kID0gKG9wdGlvbnMubWV0aG9kIHx8ICcnKS50b1N0cmluZygpLnRyaW0oKS50b1VwcGVyQ2FzZSgpIHx8ICdQT1NUJztcbiAgICB9XG5cbiAgICBsZXQgcmVxO1xuICAgIGxldCByZXFPcHRpb25zID0ge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhvc3Q6IHBhcnNlZC5ob3N0bmFtZSxcbiAgICAgICAgcGF0aDogcGFyc2VkLnBhdGgsXG4gICAgICAgIHBvcnQ6IHBhcnNlZC5wb3J0ID8gcGFyc2VkLnBvcnQgOiBwYXJzZWQucHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODAsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2UsXG4gICAgICAgIGFnZW50OiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy50bHMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy50bHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHJlcU9wdGlvbnNba2V5XSA9IG9wdGlvbnMudGxzW2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwYXJzZWQucHJvdG9jb2wgPT09ICdodHRwczonICYmIHBhcnNlZC5ob3N0bmFtZSAmJiBwYXJzZWQuaG9zdG5hbWUgIT09IHJlcU9wdGlvbnMuaG9zdCAmJiAhbmV0LmlzSVAocGFyc2VkLmhvc3RuYW1lKSAmJiAhcmVxT3B0aW9ucy5zZXJ2ZXJuYW1lKSB7XG4gICAgICAgIHJlcU9wdGlvbnMuc2VydmVybmFtZSA9IHBhcnNlZC5ob3N0bmFtZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXEgPSBoYW5kbGVyLnJlcXVlc3QocmVxT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoRSkge1xuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICBFLnR5cGUgPSAnRkVUQ0gnO1xuICAgICAgICAgICAgRS5zb3VyY2VVcmwgPSB1cmw7XG4gICAgICAgICAgICBmZXRjaFJlcy5lbWl0KCdlcnJvcicsIEUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZldGNoUmVzO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgICAgcmVxLnNldFRpbWVvdXQob3B0aW9ucy50aW1lb3V0LCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICByZXEuYWJvcnQoKTtcbiAgICAgICAgICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgVGltZW91dCcpO1xuICAgICAgICAgICAgZXJyLnR5cGUgPSAnRkVUQ0gnO1xuICAgICAgICAgICAgZXJyLnNvdXJjZVVybCA9IHVybDtcbiAgICAgICAgICAgIGZldGNoUmVzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVxLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgZXJyLnR5cGUgPSAnRkVUQ0gnO1xuICAgICAgICBlcnIuc291cmNlVXJsID0gdXJsO1xuICAgICAgICBmZXRjaFJlcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG5cbiAgICByZXEub24oJ3Jlc3BvbnNlJywgcmVzID0+IHtcbiAgICAgICAgbGV0IGluZmxhdGU7XG5cbiAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10pIHtcbiAgICAgICAgICAgIGNhc2UgJ2d6aXAnOlxuICAgICAgICAgICAgY2FzZSAnZGVmbGF0ZSc6XG4gICAgICAgICAgICAgICAgaW5mbGF0ZSA9IHpsaWIuY3JlYXRlVW56aXAoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXMuaGVhZGVyc1snc2V0LWNvb2tpZSddKSB7XG4gICAgICAgICAgICBbXS5jb25jYXQocmVzLmhlYWRlcnNbJ3NldC1jb29raWUnXSB8fCBbXSkuZm9yRWFjaChjb29raWUgPT4ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29va2llcy5zZXQoY29va2llLCB1cmwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XS5pbmNsdWRlcyhyZXMuc3RhdHVzQ29kZSkgJiYgcmVzLmhlYWRlcnMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIC8vIHJlZGlyZWN0XG4gICAgICAgICAgICBvcHRpb25zLnJlZGlyZWN0cysrO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVkaXJlY3RzID4gb3B0aW9ucy5tYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IGVyciA9IG5ldyBFcnJvcignTWF4aW11bSByZWRpcmVjdCBjb3VudCBleGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgIGVyci50eXBlID0gJ0ZFVENIJztcbiAgICAgICAgICAgICAgICBlcnIuc291cmNlVXJsID0gdXJsO1xuICAgICAgICAgICAgICAgIGZldGNoUmVzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXEuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWRpcmVjdCBkb2VzIG5vdCBpbmNsdWRlIFBPU1QgYm9keVxuICAgICAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIG5tZmV0Y2godXJsbGliLnJlc29sdmUodXJsLCByZXMuaGVhZGVycy5sb2NhdGlvbiksIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmV0Y2hSZXMuc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuICAgICAgICBmZXRjaFJlcy5oZWFkZXJzID0gcmVzLmhlYWRlcnM7XG5cbiAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID49IDMwMCAmJiAhb3B0aW9ucy5hbGxvd0Vycm9yUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUgJyArIHJlcy5zdGF0dXNDb2RlKTtcbiAgICAgICAgICAgIGVyci50eXBlID0gJ0ZFVENIJztcbiAgICAgICAgICAgIGVyci5zb3VyY2VVcmwgPSB1cmw7XG4gICAgICAgICAgICBmZXRjaFJlcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICByZXEuYWJvcnQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcy5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgZXJyLnR5cGUgPSAnRkVUQ0gnO1xuICAgICAgICAgICAgZXJyLnNvdXJjZVVybCA9IHVybDtcbiAgICAgICAgICAgIGZldGNoUmVzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaW5mbGF0ZSkge1xuICAgICAgICAgICAgcmVzLnBpcGUoaW5mbGF0ZSkucGlwZShmZXRjaFJlcyk7XG4gICAgICAgICAgICBpbmZsYXRlLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVyci50eXBlID0gJ0ZFVENIJztcbiAgICAgICAgICAgICAgICBlcnIuc291cmNlVXJsID0gdXJsO1xuICAgICAgICAgICAgICAgIGZldGNoUmVzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXEuYWJvcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLnBpcGUoZmV0Y2hSZXMpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJvZHkucGlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9keS5waXBlKHJlcSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLndyaXRlKGJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlcnIudHlwZSA9ICdGRVRDSCc7XG4gICAgICAgICAgICAgICAgZXJyLnNvdXJjZVVybCA9IHVybDtcbiAgICAgICAgICAgICAgICBmZXRjaFJlcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcS5lbmQoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmZXRjaFJlcztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/fetch/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/json-transport/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/nodemailer/lib/json-transport/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst packageData = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/nodemailer/package.json\");\nconst shared = __webpack_require__(/*! ../shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\");\n\n/**\n * Generates a Transport object to generate JSON output\n *\n * @constructor\n * @param {Object} optional config parameter\n */\nclass JSONTransport {\n    constructor(options) {\n        options = options || {};\n\n        this.options = options || {};\n\n        this.name = 'JSONTransport';\n        this.version = packageData.version;\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'json-transport'\n        });\n    }\n\n    /**\n     * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>\n     *\n     * @param {Object} emailMessage MailComposer object\n     * @param {Function} callback Callback function to run when the sending is completed\n     */\n    send(mail, done) {\n        // Sendmail strips this header line by itself\n        mail.message.keepBcc = true;\n\n        let envelope = mail.data.envelope || mail.message.getEnvelope();\n        let messageId = mail.message.messageId();\n\n        let recipients = [].concat(envelope.to || []);\n        if (recipients.length > 3) {\n            recipients.push('...and ' + recipients.splice(2).length + ' more');\n        }\n        this.logger.info(\n            {\n                tnx: 'send',\n                messageId\n            },\n            'Composing JSON structure of %s to <%s>',\n            messageId,\n            recipients.join(', ')\n        );\n\n        setImmediate(() => {\n            mail.normalize((err, data) => {\n                if (err) {\n                    this.logger.error(\n                        {\n                            err,\n                            tnx: 'send',\n                            messageId\n                        },\n                        'Failed building JSON structure for %s. %s',\n                        messageId,\n                        err.message\n                    );\n                    return done(err);\n                }\n\n                delete data.envelope;\n                delete data.normalizedHeaders;\n\n                return done(null, {\n                    envelope,\n                    messageId,\n                    message: this.options.skipEncoding ? data : JSON.stringify(data)\n                });\n            });\n        });\n    }\n}\n\nmodule.exports = JSONTransport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvanNvbi10cmFuc3BvcnQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsd0VBQW9CO0FBQ2hELGVBQWUsbUJBQU8sQ0FBQyxzRUFBVzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VtYXJrZXQvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvanNvbi10cmFuc3BvcnQvaW5kZXguanM/ZGM5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhY2thZ2VEYXRhID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJyk7XG5jb25zdCBzaGFyZWQgPSByZXF1aXJlKCcuLi9zaGFyZWQnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBUcmFuc3BvcnQgb2JqZWN0IHRvIGdlbmVyYXRlIEpTT04gb3V0cHV0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uYWwgY29uZmlnIHBhcmFtZXRlclxuICovXG5jbGFzcyBKU09OVHJhbnNwb3J0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ0pTT05UcmFuc3BvcnQnO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBwYWNrYWdlRGF0YS52ZXJzaW9uO1xuXG4gICAgICAgIHRoaXMubG9nZ2VyID0gc2hhcmVkLmdldExvZ2dlcih0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcy5vcHRpb25zLmNvbXBvbmVudCB8fCAnanNvbi10cmFuc3BvcnQnXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxwPkNvbXBpbGVzIGEgbWFpbGNvbXBvc2VyIG1lc3NhZ2UgYW5kIGZvcndhcmRzIGl0IHRvIGhhbmRsZXIgdGhhdCBzZW5kcyBpdC48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW1haWxNZXNzYWdlIE1haWxDb21wb3NlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgc2VuZGluZyBpcyBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBzZW5kKG1haWwsIGRvbmUpIHtcbiAgICAgICAgLy8gU2VuZG1haWwgc3RyaXBzIHRoaXMgaGVhZGVyIGxpbmUgYnkgaXRzZWxmXG4gICAgICAgIG1haWwubWVzc2FnZS5rZWVwQmNjID0gdHJ1ZTtcblxuICAgICAgICBsZXQgZW52ZWxvcGUgPSBtYWlsLmRhdGEuZW52ZWxvcGUgfHwgbWFpbC5tZXNzYWdlLmdldEVudmVsb3BlKCk7XG4gICAgICAgIGxldCBtZXNzYWdlSWQgPSBtYWlsLm1lc3NhZ2UubWVzc2FnZUlkKCk7XG5cbiAgICAgICAgbGV0IHJlY2lwaWVudHMgPSBbXS5jb25jYXQoZW52ZWxvcGUudG8gfHwgW10pO1xuICAgICAgICBpZiAocmVjaXBpZW50cy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICByZWNpcGllbnRzLnB1c2goJy4uLmFuZCAnICsgcmVjaXBpZW50cy5zcGxpY2UoMikubGVuZ3RoICsgJyBtb3JlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0bng6ICdzZW5kJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnQ29tcG9zaW5nIEpTT04gc3RydWN0dXJlIG9mICVzIHRvIDwlcz4nLFxuICAgICAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAgICAgcmVjaXBpZW50cy5qb2luKCcsICcpXG4gICAgICAgICk7XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgIG1haWwubm9ybWFsaXplKChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bng6ICdzZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIGJ1aWxkaW5nIEpTT04gc3RydWN0dXJlIGZvciAlcy4gJXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5lbnZlbG9wZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5ub3JtYWxpemVkSGVhZGVycztcblxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgZW52ZWxvcGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5vcHRpb25zLnNraXBFbmNvZGluZyA/IGRhdGEgOiBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OVHJhbnNwb3J0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/json-transport/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/mail-composer/index.js":
/*!************************************************************!*\
  !*** ./node_modules/nodemailer/lib/mail-composer/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-undefined: 0 */\n\n\n\nconst MimeNode = __webpack_require__(/*! ../mime-node */ \"(rsc)/./node_modules/nodemailer/lib/mime-node/index.js\");\nconst mimeFuncs = __webpack_require__(/*! ../mime-funcs */ \"(rsc)/./node_modules/nodemailer/lib/mime-funcs/index.js\");\nconst parseDataURI = (__webpack_require__(/*! ../shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\").parseDataURI);\n\n/**\n * Creates the object for composing a MimeNode instance out from the mail options\n *\n * @constructor\n * @param {Object} mail Mail options\n */\nclass MailComposer {\n    constructor(mail) {\n        this.mail = mail || {};\n        this.message = false;\n    }\n\n    /**\n     * Builds MimeNode instance\n     */\n    compile() {\n        this._alternatives = this.getAlternatives();\n        this._htmlNode = this._alternatives.filter(alternative => /^text\\/html\\b/i.test(alternative.contentType)).pop();\n        this._attachments = this.getAttachments(!!this._htmlNode);\n\n        this._useRelated = !!(this._htmlNode && this._attachments.related.length);\n        this._useAlternative = this._alternatives.length > 1;\n        this._useMixed = this._attachments.attached.length > 1 || (this._alternatives.length && this._attachments.attached.length === 1);\n\n        // Compose MIME tree\n        if (this.mail.raw) {\n            this.message = new MimeNode('message/rfc822', { newline: this.mail.newline }).setRaw(this.mail.raw);\n        } else if (this._useMixed) {\n            this.message = this._createMixed();\n        } else if (this._useAlternative) {\n            this.message = this._createAlternative();\n        } else if (this._useRelated) {\n            this.message = this._createRelated();\n        } else {\n            this.message = this._createContentNode(\n                false,\n                []\n                    .concat(this._alternatives || [])\n                    .concat(this._attachments.attached || [])\n                    .shift() || {\n                    contentType: 'text/plain',\n                    content: ''\n                }\n            );\n        }\n\n        // Add custom headers\n        if (this.mail.headers) {\n            this.message.addHeader(this.mail.headers);\n        }\n\n        // Add headers to the root node, always overrides custom headers\n        ['from', 'sender', 'to', 'cc', 'bcc', 'reply-to', 'in-reply-to', 'references', 'subject', 'message-id', 'date'].forEach(header => {\n            let key = header.replace(/-(\\w)/g, (o, c) => c.toUpperCase());\n            if (this.mail[key]) {\n                this.message.setHeader(header, this.mail[key]);\n            }\n        });\n\n        // Sets custom envelope\n        if (this.mail.envelope) {\n            this.message.setEnvelope(this.mail.envelope);\n        }\n\n        // ensure Message-Id value\n        this.message.messageId();\n\n        return this.message;\n    }\n\n    /**\n     * List all attachments. Resulting attachment objects can be used as input for MimeNode nodes\n     *\n     * @param {Boolean} findRelated If true separate related attachments from attached ones\n     * @returns {Object} An object of arrays (`related` and `attached`)\n     */\n    getAttachments(findRelated) {\n        let icalEvent, eventObject;\n        let attachments = [].concat(this.mail.attachments || []).map((attachment, i) => {\n            let data;\n            let isMessageNode = /^message\\//i.test(attachment.contentType);\n\n            if (/^data:/i.test(attachment.path || attachment.href)) {\n                attachment = this._processDataUrl(attachment);\n            }\n\n            let contentType = attachment.contentType || mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin');\n            let isImage = /^image\\//i.test(contentType);\n            let contentDisposition = attachment.contentDisposition || (isMessageNode || (isImage && attachment.cid) ? 'inline' : 'attachment');\n\n            data = {\n                contentType,\n                contentDisposition,\n                contentTransferEncoding: 'contentTransferEncoding' in attachment ? attachment.contentTransferEncoding : 'base64'\n            };\n\n            if (attachment.filename) {\n                data.filename = attachment.filename;\n            } else if (!isMessageNode && attachment.filename !== false) {\n                data.filename = (attachment.path || attachment.href || '').split('/').pop().split('?').shift() || 'attachment-' + (i + 1);\n                if (data.filename.indexOf('.') < 0) {\n                    data.filename += '.' + mimeFuncs.detectExtension(data.contentType);\n                }\n            }\n\n            if (/^https?:\\/\\//i.test(attachment.path)) {\n                attachment.href = attachment.path;\n                attachment.path = undefined;\n            }\n\n            if (attachment.cid) {\n                data.cid = attachment.cid;\n            }\n\n            if (attachment.raw) {\n                data.raw = attachment.raw;\n            } else if (attachment.path) {\n                data.content = {\n                    path: attachment.path\n                };\n            } else if (attachment.href) {\n                data.content = {\n                    href: attachment.href,\n                    httpHeaders: attachment.httpHeaders\n                };\n            } else {\n                data.content = attachment.content || '';\n            }\n\n            if (attachment.encoding) {\n                data.encoding = attachment.encoding;\n            }\n\n            if (attachment.headers) {\n                data.headers = attachment.headers;\n            }\n\n            return data;\n        });\n\n        if (this.mail.icalEvent) {\n            if (\n                typeof this.mail.icalEvent === 'object' &&\n                (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)\n            ) {\n                icalEvent = this.mail.icalEvent;\n            } else {\n                icalEvent = {\n                    content: this.mail.icalEvent\n                };\n            }\n\n            eventObject = {};\n            Object.keys(icalEvent).forEach(key => {\n                eventObject[key] = icalEvent[key];\n            });\n\n            eventObject.contentType = 'application/ics';\n            if (!eventObject.headers) {\n                eventObject.headers = {};\n            }\n            eventObject.filename = eventObject.filename || 'invite.ics';\n            eventObject.headers['Content-Disposition'] = 'attachment';\n            eventObject.headers['Content-Transfer-Encoding'] = 'base64';\n        }\n\n        if (!findRelated) {\n            return {\n                attached: attachments.concat(eventObject || []),\n                related: []\n            };\n        } else {\n            return {\n                attached: attachments.filter(attachment => !attachment.cid).concat(eventObject || []),\n                related: attachments.filter(attachment => !!attachment.cid)\n            };\n        }\n    }\n\n    /**\n     * List alternatives. Resulting objects can be used as input for MimeNode nodes\n     *\n     * @returns {Array} An array of alternative elements. Includes the `text` and `html` values as well\n     */\n    getAlternatives() {\n        let alternatives = [],\n            text,\n            html,\n            watchHtml,\n            amp,\n            icalEvent,\n            eventObject;\n\n        if (this.mail.text) {\n            if (typeof this.mail.text === 'object' && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {\n                text = this.mail.text;\n            } else {\n                text = {\n                    content: this.mail.text\n                };\n            }\n            text.contentType = 'text/plain; charset=utf-8';\n        }\n\n        if (this.mail.watchHtml) {\n            if (\n                typeof this.mail.watchHtml === 'object' &&\n                (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)\n            ) {\n                watchHtml = this.mail.watchHtml;\n            } else {\n                watchHtml = {\n                    content: this.mail.watchHtml\n                };\n            }\n            watchHtml.contentType = 'text/watch-html; charset=utf-8';\n        }\n\n        if (this.mail.amp) {\n            if (typeof this.mail.amp === 'object' && (this.mail.amp.content || this.mail.amp.path || this.mail.amp.href || this.mail.amp.raw)) {\n                amp = this.mail.amp;\n            } else {\n                amp = {\n                    content: this.mail.amp\n                };\n            }\n            amp.contentType = 'text/x-amp-html; charset=utf-8';\n        }\n\n        // NB! when including attachments with a calendar alternative you might end up in a blank screen on some clients\n        if (this.mail.icalEvent) {\n            if (\n                typeof this.mail.icalEvent === 'object' &&\n                (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)\n            ) {\n                icalEvent = this.mail.icalEvent;\n            } else {\n                icalEvent = {\n                    content: this.mail.icalEvent\n                };\n            }\n\n            eventObject = {};\n            Object.keys(icalEvent).forEach(key => {\n                eventObject[key] = icalEvent[key];\n            });\n\n            if (eventObject.content && typeof eventObject.content === 'object') {\n                // we are going to have the same attachment twice, so mark this to be\n                // resolved just once\n                eventObject.content._resolve = true;\n            }\n\n            eventObject.filename = false;\n            eventObject.contentType = 'text/calendar; charset=utf-8; method=' + (eventObject.method || 'PUBLISH').toString().trim().toUpperCase();\n            if (!eventObject.headers) {\n                eventObject.headers = {};\n            }\n        }\n\n        if (this.mail.html) {\n            if (typeof this.mail.html === 'object' && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {\n                html = this.mail.html;\n            } else {\n                html = {\n                    content: this.mail.html\n                };\n            }\n            html.contentType = 'text/html; charset=utf-8';\n        }\n\n        []\n            .concat(text || [])\n            .concat(watchHtml || [])\n            .concat(amp || [])\n            .concat(html || [])\n            .concat(eventObject || [])\n            .concat(this.mail.alternatives || [])\n            .forEach(alternative => {\n                let data;\n\n                if (/^data:/i.test(alternative.path || alternative.href)) {\n                    alternative = this._processDataUrl(alternative);\n                }\n\n                data = {\n                    contentType: alternative.contentType || mimeFuncs.detectMimeType(alternative.filename || alternative.path || alternative.href || 'txt'),\n                    contentTransferEncoding: alternative.contentTransferEncoding\n                };\n\n                if (alternative.filename) {\n                    data.filename = alternative.filename;\n                }\n\n                if (/^https?:\\/\\//i.test(alternative.path)) {\n                    alternative.href = alternative.path;\n                    alternative.path = undefined;\n                }\n\n                if (alternative.raw) {\n                    data.raw = alternative.raw;\n                } else if (alternative.path) {\n                    data.content = {\n                        path: alternative.path\n                    };\n                } else if (alternative.href) {\n                    data.content = {\n                        href: alternative.href\n                    };\n                } else {\n                    data.content = alternative.content || '';\n                }\n\n                if (alternative.encoding) {\n                    data.encoding = alternative.encoding;\n                }\n\n                if (alternative.headers) {\n                    data.headers = alternative.headers;\n                }\n\n                alternatives.push(data);\n            });\n\n        return alternatives;\n    }\n\n    /**\n     * Builds multipart/mixed node. It should always contain different type of elements on the same level\n     * eg. text + attachments\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @returns {Object} MimeNode node element\n     */\n    _createMixed(parentNode) {\n        let node;\n\n        if (!parentNode) {\n            node = new MimeNode('multipart/mixed', {\n                baseBoundary: this.mail.baseBoundary,\n                textEncoding: this.mail.textEncoding,\n                boundaryPrefix: this.mail.boundaryPrefix,\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey,\n                newline: this.mail.newline\n            });\n        } else {\n            node = parentNode.createChild('multipart/mixed', {\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey,\n                newline: this.mail.newline\n            });\n        }\n\n        if (this._useAlternative) {\n            this._createAlternative(node);\n        } else if (this._useRelated) {\n            this._createRelated(node);\n        }\n\n        []\n            .concat((!this._useAlternative && this._alternatives) || [])\n            .concat(this._attachments.attached || [])\n            .forEach(element => {\n                // if the element is a html node from related subpart then ignore it\n                if (!this._useRelated || element !== this._htmlNode) {\n                    this._createContentNode(node, element);\n                }\n            });\n\n        return node;\n    }\n\n    /**\n     * Builds multipart/alternative node. It should always contain same type of elements on the same level\n     * eg. text + html view of the same data\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @returns {Object} MimeNode node element\n     */\n    _createAlternative(parentNode) {\n        let node;\n\n        if (!parentNode) {\n            node = new MimeNode('multipart/alternative', {\n                baseBoundary: this.mail.baseBoundary,\n                textEncoding: this.mail.textEncoding,\n                boundaryPrefix: this.mail.boundaryPrefix,\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey,\n                newline: this.mail.newline\n            });\n        } else {\n            node = parentNode.createChild('multipart/alternative', {\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey,\n                newline: this.mail.newline\n            });\n        }\n\n        this._alternatives.forEach(alternative => {\n            if (this._useRelated && this._htmlNode === alternative) {\n                this._createRelated(node);\n            } else {\n                this._createContentNode(node, alternative);\n            }\n        });\n\n        return node;\n    }\n\n    /**\n     * Builds multipart/related node. It should always contain html node with related attachments\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @returns {Object} MimeNode node element\n     */\n    _createRelated(parentNode) {\n        let node;\n\n        if (!parentNode) {\n            node = new MimeNode('multipart/related; type=\"text/html\"', {\n                baseBoundary: this.mail.baseBoundary,\n                textEncoding: this.mail.textEncoding,\n                boundaryPrefix: this.mail.boundaryPrefix,\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey,\n                newline: this.mail.newline\n            });\n        } else {\n            node = parentNode.createChild('multipart/related; type=\"text/html\"', {\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey,\n                newline: this.mail.newline\n            });\n        }\n\n        this._createContentNode(node, this._htmlNode);\n\n        this._attachments.related.forEach(alternative => this._createContentNode(node, alternative));\n\n        return node;\n    }\n\n    /**\n     * Creates a regular node with contents\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @param {Object} element Node data\n     * @returns {Object} MimeNode node element\n     */\n    _createContentNode(parentNode, element) {\n        element = element || {};\n        element.content = element.content || '';\n\n        let node;\n        let encoding = (element.encoding || 'utf8')\n            .toString()\n            .toLowerCase()\n            .replace(/[-_\\s]/g, '');\n\n        if (!parentNode) {\n            node = new MimeNode(element.contentType, {\n                filename: element.filename,\n                baseBoundary: this.mail.baseBoundary,\n                textEncoding: this.mail.textEncoding,\n                boundaryPrefix: this.mail.boundaryPrefix,\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey,\n                newline: this.mail.newline\n            });\n        } else {\n            node = parentNode.createChild(element.contentType, {\n                filename: element.filename,\n                textEncoding: this.mail.textEncoding,\n                disableUrlAccess: this.mail.disableUrlAccess,\n                disableFileAccess: this.mail.disableFileAccess,\n                normalizeHeaderKey: this.mail.normalizeHeaderKey,\n                newline: this.mail.newline\n            });\n        }\n\n        // add custom headers\n        if (element.headers) {\n            node.addHeader(element.headers);\n        }\n\n        if (element.cid) {\n            node.setHeader('Content-Id', '<' + element.cid.replace(/[<>]/g, '') + '>');\n        }\n\n        if (element.contentTransferEncoding) {\n            node.setHeader('Content-Transfer-Encoding', element.contentTransferEncoding);\n        } else if (this.mail.encoding && /^text\\//i.test(element.contentType)) {\n            node.setHeader('Content-Transfer-Encoding', this.mail.encoding);\n        }\n\n        if (!/^text\\//i.test(element.contentType) || element.contentDisposition) {\n            node.setHeader(\n                'Content-Disposition',\n                element.contentDisposition || (element.cid && /^image\\//i.test(element.contentType) ? 'inline' : 'attachment')\n            );\n        }\n\n        if (typeof element.content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n            element.content = Buffer.from(element.content, encoding);\n        }\n\n        // prefer pregenerated raw content\n        if (element.raw) {\n            node.setRaw(element.raw);\n        } else {\n            node.setContent(element.content);\n        }\n\n        return node;\n    }\n\n    /**\n     * Parses data uri and converts it to a Buffer\n     *\n     * @param {Object} element Content element\n     * @return {Object} Parsed element\n     */\n    _processDataUrl(element) {\n        let parsedDataUri;\n        if ((element.path || element.href).match(/^data:/)) {\n            parsedDataUri = parseDataURI(element.path || element.href);\n        }\n\n        if (!parsedDataUri) {\n            return element;\n        }\n\n        element.content = parsedDataUri.data;\n        element.contentType = element.contentType || parsedDataUri.contentType;\n\n        if ('path' in element) {\n            element.path = false;\n        }\n\n        if ('href' in element) {\n            element.href = false;\n        }\n\n        return element;\n    }\n}\n\nmodule.exports = MailComposer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvbWFpbC1jb21wb3Nlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBYztBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBZTtBQUN6QyxxQkFBcUIsMEdBQWlDOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQsNEJBQTRCO0FBQ3hGLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsZUFBZTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1YsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VtYXJrZXQvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvbWFpbC1jb21wb3Nlci9pbmRleC5qcz84ZmY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bmRlZmluZWQ6IDAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNaW1lTm9kZSA9IHJlcXVpcmUoJy4uL21pbWUtbm9kZScpO1xuY29uc3QgbWltZUZ1bmNzID0gcmVxdWlyZSgnLi4vbWltZS1mdW5jcycpO1xuY29uc3QgcGFyc2VEYXRhVVJJID0gcmVxdWlyZSgnLi4vc2hhcmVkJykucGFyc2VEYXRhVVJJO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIG9iamVjdCBmb3IgY29tcG9zaW5nIGEgTWltZU5vZGUgaW5zdGFuY2Ugb3V0IGZyb20gdGhlIG1haWwgb3B0aW9uc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG1haWwgTWFpbCBvcHRpb25zXG4gKi9cbmNsYXNzIE1haWxDb21wb3NlciB7XG4gICAgY29uc3RydWN0b3IobWFpbCkge1xuICAgICAgICB0aGlzLm1haWwgPSBtYWlsIHx8IHt9O1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgTWltZU5vZGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21waWxlKCkge1xuICAgICAgICB0aGlzLl9hbHRlcm5hdGl2ZXMgPSB0aGlzLmdldEFsdGVybmF0aXZlcygpO1xuICAgICAgICB0aGlzLl9odG1sTm9kZSA9IHRoaXMuX2FsdGVybmF0aXZlcy5maWx0ZXIoYWx0ZXJuYXRpdmUgPT4gL150ZXh0XFwvaHRtbFxcYi9pLnRlc3QoYWx0ZXJuYXRpdmUuY29udGVudFR5cGUpKS5wb3AoKTtcbiAgICAgICAgdGhpcy5fYXR0YWNobWVudHMgPSB0aGlzLmdldEF0dGFjaG1lbnRzKCEhdGhpcy5faHRtbE5vZGUpO1xuXG4gICAgICAgIHRoaXMuX3VzZVJlbGF0ZWQgPSAhISh0aGlzLl9odG1sTm9kZSAmJiB0aGlzLl9hdHRhY2htZW50cy5yZWxhdGVkLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuX3VzZUFsdGVybmF0aXZlID0gdGhpcy5fYWx0ZXJuYXRpdmVzLmxlbmd0aCA+IDE7XG4gICAgICAgIHRoaXMuX3VzZU1peGVkID0gdGhpcy5fYXR0YWNobWVudHMuYXR0YWNoZWQubGVuZ3RoID4gMSB8fCAodGhpcy5fYWx0ZXJuYXRpdmVzLmxlbmd0aCAmJiB0aGlzLl9hdHRhY2htZW50cy5hdHRhY2hlZC5sZW5ndGggPT09IDEpO1xuXG4gICAgICAgIC8vIENvbXBvc2UgTUlNRSB0cmVlXG4gICAgICAgIGlmICh0aGlzLm1haWwucmF3KSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBuZXcgTWltZU5vZGUoJ21lc3NhZ2UvcmZjODIyJywgeyBuZXdsaW5lOiB0aGlzLm1haWwubmV3bGluZSB9KS5zZXRSYXcodGhpcy5tYWlsLnJhdyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdXNlTWl4ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuX2NyZWF0ZU1peGVkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdXNlQWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuX2NyZWF0ZUFsdGVybmF0aXZlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdXNlUmVsYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5fY3JlYXRlUmVsYXRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5fY3JlYXRlQ29udGVudE5vZGUoXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgW11cbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLl9hbHRlcm5hdGl2ZXMgfHwgW10pXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQodGhpcy5fYXR0YWNobWVudHMuYXR0YWNoZWQgfHwgW10pXG4gICAgICAgICAgICAgICAgICAgIC5zaGlmdCgpIHx8IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogJydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGN1c3RvbSBoZWFkZXJzXG4gICAgICAgIGlmICh0aGlzLm1haWwuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlLmFkZEhlYWRlcih0aGlzLm1haWwuaGVhZGVycyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcm9vdCBub2RlLCBhbHdheXMgb3ZlcnJpZGVzIGN1c3RvbSBoZWFkZXJzXG4gICAgICAgIFsnZnJvbScsICdzZW5kZXInLCAndG8nLCAnY2MnLCAnYmNjJywgJ3JlcGx5LXRvJywgJ2luLXJlcGx5LXRvJywgJ3JlZmVyZW5jZXMnLCAnc3ViamVjdCcsICdtZXNzYWdlLWlkJywgJ2RhdGUnXS5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICBsZXQga2V5ID0gaGVhZGVyLnJlcGxhY2UoLy0oXFx3KS9nLCAobywgYykgPT4gYy50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1haWxba2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZS5zZXRIZWFkZXIoaGVhZGVyLCB0aGlzLm1haWxba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldHMgY3VzdG9tIGVudmVsb3BlXG4gICAgICAgIGlmICh0aGlzLm1haWwuZW52ZWxvcGUpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZS5zZXRFbnZlbG9wZSh0aGlzLm1haWwuZW52ZWxvcGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIE1lc3NhZ2UtSWQgdmFsdWVcbiAgICAgICAgdGhpcy5tZXNzYWdlLm1lc3NhZ2VJZCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgYXR0YWNobWVudHMuIFJlc3VsdGluZyBhdHRhY2htZW50IG9iamVjdHMgY2FuIGJlIHVzZWQgYXMgaW5wdXQgZm9yIE1pbWVOb2RlIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbmRSZWxhdGVkIElmIHRydWUgc2VwYXJhdGUgcmVsYXRlZCBhdHRhY2htZW50cyBmcm9tIGF0dGFjaGVkIG9uZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgb2YgYXJyYXlzIChgcmVsYXRlZGAgYW5kIGBhdHRhY2hlZGApXG4gICAgICovXG4gICAgZ2V0QXR0YWNobWVudHMoZmluZFJlbGF0ZWQpIHtcbiAgICAgICAgbGV0IGljYWxFdmVudCwgZXZlbnRPYmplY3Q7XG4gICAgICAgIGxldCBhdHRhY2htZW50cyA9IFtdLmNvbmNhdCh0aGlzLm1haWwuYXR0YWNobWVudHMgfHwgW10pLm1hcCgoYXR0YWNobWVudCwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICBsZXQgaXNNZXNzYWdlTm9kZSA9IC9ebWVzc2FnZVxcLy9pLnRlc3QoYXR0YWNobWVudC5jb250ZW50VHlwZSk7XG5cbiAgICAgICAgICAgIGlmICgvXmRhdGE6L2kudGVzdChhdHRhY2htZW50LnBhdGggfHwgYXR0YWNobWVudC5ocmVmKSkge1xuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQgPSB0aGlzLl9wcm9jZXNzRGF0YVVybChhdHRhY2htZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gYXR0YWNobWVudC5jb250ZW50VHlwZSB8fCBtaW1lRnVuY3MuZGV0ZWN0TWltZVR5cGUoYXR0YWNobWVudC5maWxlbmFtZSB8fCBhdHRhY2htZW50LnBhdGggfHwgYXR0YWNobWVudC5ocmVmIHx8ICdiaW4nKTtcbiAgICAgICAgICAgIGxldCBpc0ltYWdlID0gL15pbWFnZVxcLy9pLnRlc3QoY29udGVudFR5cGUpO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnREaXNwb3NpdGlvbiA9IGF0dGFjaG1lbnQuY29udGVudERpc3Bvc2l0aW9uIHx8IChpc01lc3NhZ2VOb2RlIHx8IChpc0ltYWdlICYmIGF0dGFjaG1lbnQuY2lkKSA/ICdpbmxpbmUnIDogJ2F0dGFjaG1lbnQnKTtcblxuICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgY29udGVudFRyYW5zZmVyRW5jb2Rpbmc6ICdjb250ZW50VHJhbnNmZXJFbmNvZGluZycgaW4gYXR0YWNobWVudCA/IGF0dGFjaG1lbnQuY29udGVudFRyYW5zZmVyRW5jb2RpbmcgOiAnYmFzZTY0J1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmZpbGVuYW1lID0gYXR0YWNobWVudC5maWxlbmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTWVzc2FnZU5vZGUgJiYgYXR0YWNobWVudC5maWxlbmFtZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmZpbGVuYW1lID0gKGF0dGFjaG1lbnQucGF0aCB8fCBhdHRhY2htZW50LmhyZWYgfHwgJycpLnNwbGl0KCcvJykucG9wKCkuc3BsaXQoJz8nKS5zaGlmdCgpIHx8ICdhdHRhY2htZW50LScgKyAoaSArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmZpbGVuYW1lLmluZGV4T2YoJy4nKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5maWxlbmFtZSArPSAnLicgKyBtaW1lRnVuY3MuZGV0ZWN0RXh0ZW5zaW9uKGRhdGEuY29udGVudFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKC9eaHR0cHM/OlxcL1xcLy9pLnRlc3QoYXR0YWNobWVudC5wYXRoKSkge1xuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuaHJlZiA9IGF0dGFjaG1lbnQucGF0aDtcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdHRhY2htZW50LmNpZCkge1xuICAgICAgICAgICAgICAgIGRhdGEuY2lkID0gYXR0YWNobWVudC5jaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdHRhY2htZW50LnJhdykge1xuICAgICAgICAgICAgICAgIGRhdGEucmF3ID0gYXR0YWNobWVudC5yYXc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dGFjaG1lbnQucGF0aCkge1xuICAgICAgICAgICAgICAgIGRhdGEuY29udGVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYXR0YWNobWVudC5wYXRoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0YWNobWVudC5ocmVmKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jb250ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBocmVmOiBhdHRhY2htZW50LmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIGh0dHBIZWFkZXJzOiBhdHRhY2htZW50Lmh0dHBIZWFkZXJzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jb250ZW50ID0gYXR0YWNobWVudC5jb250ZW50IHx8ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXR0YWNobWVudC5lbmNvZGluZykge1xuICAgICAgICAgICAgICAgIGRhdGEuZW5jb2RpbmcgPSBhdHRhY2htZW50LmVuY29kaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXR0YWNobWVudC5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5oZWFkZXJzID0gYXR0YWNobWVudC5oZWFkZXJzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMubWFpbC5pY2FsRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGhpcy5tYWlsLmljYWxFdmVudCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5tYWlsLmljYWxFdmVudC5jb250ZW50IHx8IHRoaXMubWFpbC5pY2FsRXZlbnQucGF0aCB8fCB0aGlzLm1haWwuaWNhbEV2ZW50LmhyZWYgfHwgdGhpcy5tYWlsLmljYWxFdmVudC5yYXcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpY2FsRXZlbnQgPSB0aGlzLm1haWwuaWNhbEV2ZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpY2FsRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMubWFpbC5pY2FsRXZlbnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudE9iamVjdCA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaWNhbEV2ZW50KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnRPYmplY3Rba2V5XSA9IGljYWxFdmVudFtrZXldO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGV2ZW50T2JqZWN0LmNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL2ljcyc7XG4gICAgICAgICAgICBpZiAoIWV2ZW50T2JqZWN0LmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBldmVudE9iamVjdC5oZWFkZXJzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudE9iamVjdC5maWxlbmFtZSA9IGV2ZW50T2JqZWN0LmZpbGVuYW1lIHx8ICdpbnZpdGUuaWNzJztcbiAgICAgICAgICAgIGV2ZW50T2JqZWN0LmhlYWRlcnNbJ0NvbnRlbnQtRGlzcG9zaXRpb24nXSA9ICdhdHRhY2htZW50JztcbiAgICAgICAgICAgIGV2ZW50T2JqZWN0LmhlYWRlcnNbJ0NvbnRlbnQtVHJhbnNmZXItRW5jb2RpbmcnXSA9ICdiYXNlNjQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmaW5kUmVsYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRhY2hlZDogYXR0YWNobWVudHMuY29uY2F0KGV2ZW50T2JqZWN0IHx8IFtdKSxcbiAgICAgICAgICAgICAgICByZWxhdGVkOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0YWNoZWQ6IGF0dGFjaG1lbnRzLmZpbHRlcihhdHRhY2htZW50ID0+ICFhdHRhY2htZW50LmNpZCkuY29uY2F0KGV2ZW50T2JqZWN0IHx8IFtdKSxcbiAgICAgICAgICAgICAgICByZWxhdGVkOiBhdHRhY2htZW50cy5maWx0ZXIoYXR0YWNobWVudCA9PiAhIWF0dGFjaG1lbnQuY2lkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3QgYWx0ZXJuYXRpdmVzLiBSZXN1bHRpbmcgb2JqZWN0cyBjYW4gYmUgdXNlZCBhcyBpbnB1dCBmb3IgTWltZU5vZGUgbm9kZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2YgYWx0ZXJuYXRpdmUgZWxlbWVudHMuIEluY2x1ZGVzIHRoZSBgdGV4dGAgYW5kIGBodG1sYCB2YWx1ZXMgYXMgd2VsbFxuICAgICAqL1xuICAgIGdldEFsdGVybmF0aXZlcygpIHtcbiAgICAgICAgbGV0IGFsdGVybmF0aXZlcyA9IFtdLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIGh0bWwsXG4gICAgICAgICAgICB3YXRjaEh0bWwsXG4gICAgICAgICAgICBhbXAsXG4gICAgICAgICAgICBpY2FsRXZlbnQsXG4gICAgICAgICAgICBldmVudE9iamVjdDtcblxuICAgICAgICBpZiAodGhpcy5tYWlsLnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5tYWlsLnRleHQgPT09ICdvYmplY3QnICYmICh0aGlzLm1haWwudGV4dC5jb250ZW50IHx8IHRoaXMubWFpbC50ZXh0LnBhdGggfHwgdGhpcy5tYWlsLnRleHQuaHJlZiB8fCB0aGlzLm1haWwudGV4dC5yYXcpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMubWFpbC50ZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLm1haWwudGV4dFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0LmNvbnRlbnRUeXBlID0gJ3RleHQvcGxhaW47IGNoYXJzZXQ9dXRmLTgnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFpbC53YXRjaEh0bWwpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGhpcy5tYWlsLndhdGNoSHRtbCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5tYWlsLndhdGNoSHRtbC5jb250ZW50IHx8IHRoaXMubWFpbC53YXRjaEh0bWwucGF0aCB8fCB0aGlzLm1haWwud2F0Y2hIdG1sLmhyZWYgfHwgdGhpcy5tYWlsLndhdGNoSHRtbC5yYXcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB3YXRjaEh0bWwgPSB0aGlzLm1haWwud2F0Y2hIdG1sO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YXRjaEh0bWwgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMubWFpbC53YXRjaEh0bWxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2F0Y2hIdG1sLmNvbnRlbnRUeXBlID0gJ3RleHQvd2F0Y2gtaHRtbDsgY2hhcnNldD11dGYtOCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYWlsLmFtcCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1haWwuYW1wID09PSAnb2JqZWN0JyAmJiAodGhpcy5tYWlsLmFtcC5jb250ZW50IHx8IHRoaXMubWFpbC5hbXAucGF0aCB8fCB0aGlzLm1haWwuYW1wLmhyZWYgfHwgdGhpcy5tYWlsLmFtcC5yYXcpKSB7XG4gICAgICAgICAgICAgICAgYW1wID0gdGhpcy5tYWlsLmFtcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW1wID0ge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLm1haWwuYW1wXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFtcC5jb250ZW50VHlwZSA9ICd0ZXh0L3gtYW1wLWh0bWw7IGNoYXJzZXQ9dXRmLTgnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTkIhIHdoZW4gaW5jbHVkaW5nIGF0dGFjaG1lbnRzIHdpdGggYSBjYWxlbmRhciBhbHRlcm5hdGl2ZSB5b3UgbWlnaHQgZW5kIHVwIGluIGEgYmxhbmsgc2NyZWVuIG9uIHNvbWUgY2xpZW50c1xuICAgICAgICBpZiAodGhpcy5tYWlsLmljYWxFdmVudCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzLm1haWwuaWNhbEV2ZW50ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICh0aGlzLm1haWwuaWNhbEV2ZW50LmNvbnRlbnQgfHwgdGhpcy5tYWlsLmljYWxFdmVudC5wYXRoIHx8IHRoaXMubWFpbC5pY2FsRXZlbnQuaHJlZiB8fCB0aGlzLm1haWwuaWNhbEV2ZW50LnJhdylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGljYWxFdmVudCA9IHRoaXMubWFpbC5pY2FsRXZlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGljYWxFdmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5tYWlsLmljYWxFdmVudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50T2JqZWN0ID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhpY2FsRXZlbnQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBldmVudE9iamVjdFtrZXldID0gaWNhbEV2ZW50W2tleV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGV2ZW50T2JqZWN0LmNvbnRlbnQgJiYgdHlwZW9mIGV2ZW50T2JqZWN0LmNvbnRlbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIGdvaW5nIHRvIGhhdmUgdGhlIHNhbWUgYXR0YWNobWVudCB0d2ljZSwgc28gbWFyayB0aGlzIHRvIGJlXG4gICAgICAgICAgICAgICAgLy8gcmVzb2x2ZWQganVzdCBvbmNlXG4gICAgICAgICAgICAgICAgZXZlbnRPYmplY3QuY29udGVudC5fcmVzb2x2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50T2JqZWN0LmZpbGVuYW1lID0gZmFsc2U7XG4gICAgICAgICAgICBldmVudE9iamVjdC5jb250ZW50VHlwZSA9ICd0ZXh0L2NhbGVuZGFyOyBjaGFyc2V0PXV0Zi04OyBtZXRob2Q9JyArIChldmVudE9iamVjdC5tZXRob2QgfHwgJ1BVQkxJU0gnKS50b1N0cmluZygpLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKCFldmVudE9iamVjdC5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRPYmplY3QuaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFpbC5odG1sKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFpbC5odG1sID09PSAnb2JqZWN0JyAmJiAodGhpcy5tYWlsLmh0bWwuY29udGVudCB8fCB0aGlzLm1haWwuaHRtbC5wYXRoIHx8IHRoaXMubWFpbC5odG1sLmhyZWYgfHwgdGhpcy5tYWlsLmh0bWwucmF3KSkge1xuICAgICAgICAgICAgICAgIGh0bWwgPSB0aGlzLm1haWwuaHRtbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaHRtbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5tYWlsLmh0bWxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHRtbC5jb250ZW50VHlwZSA9ICd0ZXh0L2h0bWw7IGNoYXJzZXQ9dXRmLTgnO1xuICAgICAgICB9XG5cbiAgICAgICAgW11cbiAgICAgICAgICAgIC5jb25jYXQodGV4dCB8fCBbXSlcbiAgICAgICAgICAgIC5jb25jYXQod2F0Y2hIdG1sIHx8IFtdKVxuICAgICAgICAgICAgLmNvbmNhdChhbXAgfHwgW10pXG4gICAgICAgICAgICAuY29uY2F0KGh0bWwgfHwgW10pXG4gICAgICAgICAgICAuY29uY2F0KGV2ZW50T2JqZWN0IHx8IFtdKVxuICAgICAgICAgICAgLmNvbmNhdCh0aGlzLm1haWwuYWx0ZXJuYXRpdmVzIHx8IFtdKVxuICAgICAgICAgICAgLmZvckVhY2goYWx0ZXJuYXRpdmUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKC9eZGF0YTovaS50ZXN0KGFsdGVybmF0aXZlLnBhdGggfHwgYWx0ZXJuYXRpdmUuaHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmUgPSB0aGlzLl9wcm9jZXNzRGF0YVVybChhbHRlcm5hdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGFsdGVybmF0aXZlLmNvbnRlbnRUeXBlIHx8IG1pbWVGdW5jcy5kZXRlY3RNaW1lVHlwZShhbHRlcm5hdGl2ZS5maWxlbmFtZSB8fCBhbHRlcm5hdGl2ZS5wYXRoIHx8IGFsdGVybmF0aXZlLmhyZWYgfHwgJ3R4dCcpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50VHJhbnNmZXJFbmNvZGluZzogYWx0ZXJuYXRpdmUuY29udGVudFRyYW5zZmVyRW5jb2RpbmdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGFsdGVybmF0aXZlLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZmlsZW5hbWUgPSBhbHRlcm5hdGl2ZS5maWxlbmFtZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoL15odHRwcz86XFwvXFwvL2kudGVzdChhbHRlcm5hdGl2ZS5wYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZS5ocmVmID0gYWx0ZXJuYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmUucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWx0ZXJuYXRpdmUucmF3KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucmF3ID0gYWx0ZXJuYXRpdmUucmF3O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRpdmUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmNvbnRlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBhbHRlcm5hdGl2ZS5wYXRoXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbHRlcm5hdGl2ZS5ocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuY29udGVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGFsdGVybmF0aXZlLmhyZWZcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmNvbnRlbnQgPSBhbHRlcm5hdGl2ZS5jb250ZW50IHx8ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZS5lbmNvZGluZykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmVuY29kaW5nID0gYWx0ZXJuYXRpdmUuZW5jb2Rpbmc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFsdGVybmF0aXZlLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5oZWFkZXJzID0gYWx0ZXJuYXRpdmUuaGVhZGVycztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhbHRlcm5hdGl2ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIG11bHRpcGFydC9taXhlZCBub2RlLiBJdCBzaG91bGQgYWx3YXlzIGNvbnRhaW4gZGlmZmVyZW50IHR5cGUgb2YgZWxlbWVudHMgb24gdGhlIHNhbWUgbGV2ZWxcbiAgICAgKiBlZy4gdGV4dCArIGF0dGFjaG1lbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50Tm9kZSBQYXJlbnQgZm9yIHRoaXMgbm90ZS4gSWYgaXQgZG9lcyBub3QgZXhpc3QsIGEgcm9vdCBub2RlIGlzIGNyZWF0ZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBNaW1lTm9kZSBub2RlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfY3JlYXRlTWl4ZWQocGFyZW50Tm9kZSkge1xuICAgICAgICBsZXQgbm9kZTtcblxuICAgICAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgTWltZU5vZGUoJ211bHRpcGFydC9taXhlZCcsIHtcbiAgICAgICAgICAgICAgICBiYXNlQm91bmRhcnk6IHRoaXMubWFpbC5iYXNlQm91bmRhcnksXG4gICAgICAgICAgICAgICAgdGV4dEVuY29kaW5nOiB0aGlzLm1haWwudGV4dEVuY29kaW5nLFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5UHJlZml4OiB0aGlzLm1haWwuYm91bmRhcnlQcmVmaXgsXG4gICAgICAgICAgICAgICAgZGlzYWJsZVVybEFjY2VzczogdGhpcy5tYWlsLmRpc2FibGVVcmxBY2Nlc3MsXG4gICAgICAgICAgICAgICAgZGlzYWJsZUZpbGVBY2Nlc3M6IHRoaXMubWFpbC5kaXNhYmxlRmlsZUFjY2VzcyxcbiAgICAgICAgICAgICAgICBub3JtYWxpemVIZWFkZXJLZXk6IHRoaXMubWFpbC5ub3JtYWxpemVIZWFkZXJLZXksXG4gICAgICAgICAgICAgICAgbmV3bGluZTogdGhpcy5tYWlsLm5ld2xpbmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudE5vZGUuY3JlYXRlQ2hpbGQoJ211bHRpcGFydC9taXhlZCcsIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlVXJsQWNjZXNzOiB0aGlzLm1haWwuZGlzYWJsZVVybEFjY2VzcyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlRmlsZUFjY2VzczogdGhpcy5tYWlsLmRpc2FibGVGaWxlQWNjZXNzLFxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZUhlYWRlcktleTogdGhpcy5tYWlsLm5vcm1hbGl6ZUhlYWRlcktleSxcbiAgICAgICAgICAgICAgICBuZXdsaW5lOiB0aGlzLm1haWwubmV3bGluZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdXNlQWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUFsdGVybmF0aXZlKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3VzZVJlbGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlbGF0ZWQobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBbXVxuICAgICAgICAgICAgLmNvbmNhdCgoIXRoaXMuX3VzZUFsdGVybmF0aXZlICYmIHRoaXMuX2FsdGVybmF0aXZlcykgfHwgW10pXG4gICAgICAgICAgICAuY29uY2F0KHRoaXMuX2F0dGFjaG1lbnRzLmF0dGFjaGVkIHx8IFtdKVxuICAgICAgICAgICAgLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaXMgYSBodG1sIG5vZGUgZnJvbSByZWxhdGVkIHN1YnBhcnQgdGhlbiBpZ25vcmUgaXRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3VzZVJlbGF0ZWQgfHwgZWxlbWVudCAhPT0gdGhpcy5faHRtbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ29udGVudE5vZGUobm9kZSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIG11bHRpcGFydC9hbHRlcm5hdGl2ZSBub2RlLiBJdCBzaG91bGQgYWx3YXlzIGNvbnRhaW4gc2FtZSB0eXBlIG9mIGVsZW1lbnRzIG9uIHRoZSBzYW1lIGxldmVsXG4gICAgICogZWcuIHRleHQgKyBodG1sIHZpZXcgb2YgdGhlIHNhbWUgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudE5vZGUgUGFyZW50IGZvciB0aGlzIG5vdGUuIElmIGl0IGRvZXMgbm90IGV4aXN0LCBhIHJvb3Qgbm9kZSBpcyBjcmVhdGVkXG4gICAgICogQHJldHVybnMge09iamVjdH0gTWltZU5vZGUgbm9kZSBlbGVtZW50XG4gICAgICovXG4gICAgX2NyZWF0ZUFsdGVybmF0aXZlKHBhcmVudE5vZGUpIHtcbiAgICAgICAgbGV0IG5vZGU7XG5cbiAgICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBub2RlID0gbmV3IE1pbWVOb2RlKCdtdWx0aXBhcnQvYWx0ZXJuYXRpdmUnLCB7XG4gICAgICAgICAgICAgICAgYmFzZUJvdW5kYXJ5OiB0aGlzLm1haWwuYmFzZUJvdW5kYXJ5LFxuICAgICAgICAgICAgICAgIHRleHRFbmNvZGluZzogdGhpcy5tYWlsLnRleHRFbmNvZGluZyxcbiAgICAgICAgICAgICAgICBib3VuZGFyeVByZWZpeDogdGhpcy5tYWlsLmJvdW5kYXJ5UHJlZml4LFxuICAgICAgICAgICAgICAgIGRpc2FibGVVcmxBY2Nlc3M6IHRoaXMubWFpbC5kaXNhYmxlVXJsQWNjZXNzLFxuICAgICAgICAgICAgICAgIGRpc2FibGVGaWxlQWNjZXNzOiB0aGlzLm1haWwuZGlzYWJsZUZpbGVBY2Nlc3MsXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplSGVhZGVyS2V5OiB0aGlzLm1haWwubm9ybWFsaXplSGVhZGVyS2V5LFxuICAgICAgICAgICAgICAgIG5ld2xpbmU6IHRoaXMubWFpbC5uZXdsaW5lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnROb2RlLmNyZWF0ZUNoaWxkKCdtdWx0aXBhcnQvYWx0ZXJuYXRpdmUnLCB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZVVybEFjY2VzczogdGhpcy5tYWlsLmRpc2FibGVVcmxBY2Nlc3MsXG4gICAgICAgICAgICAgICAgZGlzYWJsZUZpbGVBY2Nlc3M6IHRoaXMubWFpbC5kaXNhYmxlRmlsZUFjY2VzcyxcbiAgICAgICAgICAgICAgICBub3JtYWxpemVIZWFkZXJLZXk6IHRoaXMubWFpbC5ub3JtYWxpemVIZWFkZXJLZXksXG4gICAgICAgICAgICAgICAgbmV3bGluZTogdGhpcy5tYWlsLm5ld2xpbmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYWx0ZXJuYXRpdmVzLmZvckVhY2goYWx0ZXJuYXRpdmUgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VzZVJlbGF0ZWQgJiYgdGhpcy5faHRtbE5vZGUgPT09IGFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlUmVsYXRlZChub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ29udGVudE5vZGUobm9kZSwgYWx0ZXJuYXRpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgbXVsdGlwYXJ0L3JlbGF0ZWQgbm9kZS4gSXQgc2hvdWxkIGFsd2F5cyBjb250YWluIGh0bWwgbm9kZSB3aXRoIHJlbGF0ZWQgYXR0YWNobWVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnROb2RlIFBhcmVudCBmb3IgdGhpcyBub3RlLiBJZiBpdCBkb2VzIG5vdCBleGlzdCwgYSByb290IG5vZGUgaXMgY3JlYXRlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE1pbWVOb2RlIG5vZGUgZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVSZWxhdGVkKHBhcmVudE5vZGUpIHtcbiAgICAgICAgbGV0IG5vZGU7XG5cbiAgICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBub2RlID0gbmV3IE1pbWVOb2RlKCdtdWx0aXBhcnQvcmVsYXRlZDsgdHlwZT1cInRleHQvaHRtbFwiJywge1xuICAgICAgICAgICAgICAgIGJhc2VCb3VuZGFyeTogdGhpcy5tYWlsLmJhc2VCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rpbmc6IHRoaXMubWFpbC50ZXh0RW5jb2RpbmcsXG4gICAgICAgICAgICAgICAgYm91bmRhcnlQcmVmaXg6IHRoaXMubWFpbC5ib3VuZGFyeVByZWZpeCxcbiAgICAgICAgICAgICAgICBkaXNhYmxlVXJsQWNjZXNzOiB0aGlzLm1haWwuZGlzYWJsZVVybEFjY2VzcyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlRmlsZUFjY2VzczogdGhpcy5tYWlsLmRpc2FibGVGaWxlQWNjZXNzLFxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZUhlYWRlcktleTogdGhpcy5tYWlsLm5vcm1hbGl6ZUhlYWRlcktleSxcbiAgICAgICAgICAgICAgICBuZXdsaW5lOiB0aGlzLm1haWwubmV3bGluZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50Tm9kZS5jcmVhdGVDaGlsZCgnbXVsdGlwYXJ0L3JlbGF0ZWQ7IHR5cGU9XCJ0ZXh0L2h0bWxcIicsIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlVXJsQWNjZXNzOiB0aGlzLm1haWwuZGlzYWJsZVVybEFjY2VzcyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlRmlsZUFjY2VzczogdGhpcy5tYWlsLmRpc2FibGVGaWxlQWNjZXNzLFxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZUhlYWRlcktleTogdGhpcy5tYWlsLm5vcm1hbGl6ZUhlYWRlcktleSxcbiAgICAgICAgICAgICAgICBuZXdsaW5lOiB0aGlzLm1haWwubmV3bGluZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jcmVhdGVDb250ZW50Tm9kZShub2RlLCB0aGlzLl9odG1sTm9kZSk7XG5cbiAgICAgICAgdGhpcy5fYXR0YWNobWVudHMucmVsYXRlZC5mb3JFYWNoKGFsdGVybmF0aXZlID0+IHRoaXMuX2NyZWF0ZUNvbnRlbnROb2RlKG5vZGUsIGFsdGVybmF0aXZlKSk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlZ3VsYXIgbm9kZSB3aXRoIGNvbnRlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50Tm9kZSBQYXJlbnQgZm9yIHRoaXMgbm90ZS4gSWYgaXQgZG9lcyBub3QgZXhpc3QsIGEgcm9vdCBub2RlIGlzIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCBOb2RlIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBNaW1lTm9kZSBub2RlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfY3JlYXRlQ29udGVudE5vZGUocGFyZW50Tm9kZSwgZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudCB8fCB7fTtcbiAgICAgICAgZWxlbWVudC5jb250ZW50ID0gZWxlbWVudC5jb250ZW50IHx8ICcnO1xuXG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICBsZXQgZW5jb2RpbmcgPSAoZWxlbWVudC5lbmNvZGluZyB8fCAndXRmOCcpXG4gICAgICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bLV9cXHNdL2csICcnKTtcblxuICAgICAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgTWltZU5vZGUoZWxlbWVudC5jb250ZW50VHlwZSwge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBlbGVtZW50LmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGJhc2VCb3VuZGFyeTogdGhpcy5tYWlsLmJhc2VCb3VuZGFyeSxcbiAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rpbmc6IHRoaXMubWFpbC50ZXh0RW5jb2RpbmcsXG4gICAgICAgICAgICAgICAgYm91bmRhcnlQcmVmaXg6IHRoaXMubWFpbC5ib3VuZGFyeVByZWZpeCxcbiAgICAgICAgICAgICAgICBkaXNhYmxlVXJsQWNjZXNzOiB0aGlzLm1haWwuZGlzYWJsZVVybEFjY2VzcyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlRmlsZUFjY2VzczogdGhpcy5tYWlsLmRpc2FibGVGaWxlQWNjZXNzLFxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZUhlYWRlcktleTogdGhpcy5tYWlsLm5vcm1hbGl6ZUhlYWRlcktleSxcbiAgICAgICAgICAgICAgICBuZXdsaW5lOiB0aGlzLm1haWwubmV3bGluZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50Tm9kZS5jcmVhdGVDaGlsZChlbGVtZW50LmNvbnRlbnRUeXBlLCB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGVsZW1lbnQuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgdGV4dEVuY29kaW5nOiB0aGlzLm1haWwudGV4dEVuY29kaW5nLFxuICAgICAgICAgICAgICAgIGRpc2FibGVVcmxBY2Nlc3M6IHRoaXMubWFpbC5kaXNhYmxlVXJsQWNjZXNzLFxuICAgICAgICAgICAgICAgIGRpc2FibGVGaWxlQWNjZXNzOiB0aGlzLm1haWwuZGlzYWJsZUZpbGVBY2Nlc3MsXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplSGVhZGVyS2V5OiB0aGlzLm1haWwubm9ybWFsaXplSGVhZGVyS2V5LFxuICAgICAgICAgICAgICAgIG5ld2xpbmU6IHRoaXMubWFpbC5uZXdsaW5lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBjdXN0b20gaGVhZGVyc1xuICAgICAgICBpZiAoZWxlbWVudC5oZWFkZXJzKSB7XG4gICAgICAgICAgICBub2RlLmFkZEhlYWRlcihlbGVtZW50LmhlYWRlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnQuY2lkKSB7XG4gICAgICAgICAgICBub2RlLnNldEhlYWRlcignQ29udGVudC1JZCcsICc8JyArIGVsZW1lbnQuY2lkLnJlcGxhY2UoL1s8Pl0vZywgJycpICsgJz4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtZW50LmNvbnRlbnRUcmFuc2ZlckVuY29kaW5nKSB7XG4gICAgICAgICAgICBub2RlLnNldEhlYWRlcignQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZycsIGVsZW1lbnQuY29udGVudFRyYW5zZmVyRW5jb2RpbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWFpbC5lbmNvZGluZyAmJiAvXnRleHRcXC8vaS50ZXN0KGVsZW1lbnQuY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICBub2RlLnNldEhlYWRlcignQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZycsIHRoaXMubWFpbC5lbmNvZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIS9edGV4dFxcLy9pLnRlc3QoZWxlbWVudC5jb250ZW50VHlwZSkgfHwgZWxlbWVudC5jb250ZW50RGlzcG9zaXRpb24pIHtcbiAgICAgICAgICAgIG5vZGUuc2V0SGVhZGVyKFxuICAgICAgICAgICAgICAgICdDb250ZW50LURpc3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNvbnRlbnREaXNwb3NpdGlvbiB8fCAoZWxlbWVudC5jaWQgJiYgL15pbWFnZVxcLy9pLnRlc3QoZWxlbWVudC5jb250ZW50VHlwZSkgPyAnaW5saW5lJyA6ICdhdHRhY2htZW50JylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQuY29udGVudCA9PT0gJ3N0cmluZycgJiYgIVsndXRmOCcsICd1c2FzY2lpJywgJ2FzY2lpJ10uaW5jbHVkZXMoZW5jb2RpbmcpKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNvbnRlbnQgPSBCdWZmZXIuZnJvbShlbGVtZW50LmNvbnRlbnQsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZWZlciBwcmVnZW5lcmF0ZWQgcmF3IGNvbnRlbnRcbiAgICAgICAgaWYgKGVsZW1lbnQucmF3KSB7XG4gICAgICAgICAgICBub2RlLnNldFJhdyhlbGVtZW50LnJhdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLnNldENvbnRlbnQoZWxlbWVudC5jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBkYXRhIHVyaSBhbmQgY29udmVydHMgaXQgdG8gYSBCdWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IENvbnRlbnQgZWxlbWVudFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUGFyc2VkIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfcHJvY2Vzc0RhdGFVcmwoZWxlbWVudCkge1xuICAgICAgICBsZXQgcGFyc2VkRGF0YVVyaTtcbiAgICAgICAgaWYgKChlbGVtZW50LnBhdGggfHwgZWxlbWVudC5ocmVmKS5tYXRjaCgvXmRhdGE6LykpIHtcbiAgICAgICAgICAgIHBhcnNlZERhdGFVcmkgPSBwYXJzZURhdGFVUkkoZWxlbWVudC5wYXRoIHx8IGVsZW1lbnQuaHJlZik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcnNlZERhdGFVcmkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5jb250ZW50ID0gcGFyc2VkRGF0YVVyaS5kYXRhO1xuICAgICAgICBlbGVtZW50LmNvbnRlbnRUeXBlID0gZWxlbWVudC5jb250ZW50VHlwZSB8fCBwYXJzZWREYXRhVXJpLmNvbnRlbnRUeXBlO1xuXG4gICAgICAgIGlmICgncGF0aCcgaW4gZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5wYXRoID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2hyZWYnIGluIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuaHJlZiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1haWxDb21wb3NlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/mail-composer/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/mailer/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/nodemailer/lib/mailer/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst shared = __webpack_require__(/*! ../shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\");\nconst mimeTypes = __webpack_require__(/*! ../mime-funcs/mime-types */ \"(rsc)/./node_modules/nodemailer/lib/mime-funcs/mime-types.js\");\nconst MailComposer = __webpack_require__(/*! ../mail-composer */ \"(rsc)/./node_modules/nodemailer/lib/mail-composer/index.js\");\nconst DKIM = __webpack_require__(/*! ../dkim */ \"(rsc)/./node_modules/nodemailer/lib/dkim/index.js\");\nconst httpProxyClient = __webpack_require__(/*! ../smtp-connection/http-proxy-client */ \"(rsc)/./node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst urllib = __webpack_require__(/*! url */ \"url\");\nconst packageData = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/nodemailer/package.json\");\nconst MailMessage = __webpack_require__(/*! ./mail-message */ \"(rsc)/./node_modules/nodemailer/lib/mailer/mail-message.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst dns = __webpack_require__(/*! dns */ \"dns\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\n/**\n * Creates an object for exposing the Mail API\n *\n * @constructor\n * @param {Object} transporter Transport object instance to pass the mails to\n */\nclass Mail extends EventEmitter {\n    constructor(transporter, options, defaults) {\n        super();\n\n        this.options = options || {};\n        this._defaults = defaults || {};\n\n        this._defaultPlugins = {\n            compile: [(...args) => this._convertDataImages(...args)],\n            stream: []\n        };\n\n        this._userPlugins = {\n            compile: [],\n            stream: []\n        };\n\n        this.meta = new Map();\n\n        this.dkim = this.options.dkim ? new DKIM(this.options.dkim) : false;\n\n        this.transporter = transporter;\n        this.transporter.mailer = this;\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'mail'\n        });\n\n        this.logger.debug(\n            {\n                tnx: 'create'\n            },\n            'Creating transport: %s',\n            this.getVersionString()\n        );\n\n        // setup emit handlers for the transporter\n        if (typeof this.transporter.on === 'function') {\n            // deprecated log interface\n            this.transporter.on('log', log => {\n                this.logger.debug(\n                    {\n                        tnx: 'transport'\n                    },\n                    '%s: %s',\n                    log.type,\n                    log.message\n                );\n            });\n\n            // transporter errors\n            this.transporter.on('error', err => {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'transport'\n                    },\n                    'Transport Error: %s',\n                    err.message\n                );\n                this.emit('error', err);\n            });\n\n            // indicates if the sender has became idle\n            this.transporter.on('idle', (...args) => {\n                this.emit('idle', ...args);\n            });\n        }\n\n        /**\n         * Optional methods passed to the underlying transport object\n         */\n        ['close', 'isIdle', 'verify'].forEach(method => {\n            this[method] = (...args) => {\n                if (typeof this.transporter[method] === 'function') {\n                    if (method === 'verify' && typeof this.getSocket === 'function') {\n                        this.transporter.getSocket = this.getSocket;\n                        this.getSocket = false;\n                    }\n                    return this.transporter[method](...args);\n                } else {\n                    this.logger.warn(\n                        {\n                            tnx: 'transport',\n                            methodName: method\n                        },\n                        'Non existing method %s called for transport',\n                        method\n                    );\n                    return false;\n                }\n            };\n        });\n\n        // setup proxy handling\n        if (this.options.proxy && typeof this.options.proxy === 'string') {\n            this.setupProxy(this.options.proxy);\n        }\n    }\n\n    use(step, plugin) {\n        step = (step || '').toString();\n        if (!this._userPlugins.hasOwnProperty(step)) {\n            this._userPlugins[step] = [plugin];\n        } else {\n            this._userPlugins[step].push(plugin);\n        }\n\n        return this;\n    }\n\n    /**\n     * Sends an email using the preselected transport object\n     *\n     * @param {Object} data E-data description\n     * @param {Function?} callback Callback to run once the sending succeeded or failed\n     */\n    sendMail(data, callback = null) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        if (typeof this.getSocket === 'function') {\n            this.transporter.getSocket = this.getSocket;\n            this.getSocket = false;\n        }\n\n        let mail = new MailMessage(this, data);\n\n        this.logger.debug(\n            {\n                tnx: 'transport',\n                name: this.transporter.name,\n                version: this.transporter.version,\n                action: 'send'\n            },\n            'Sending mail using %s/%s',\n            this.transporter.name,\n            this.transporter.version\n        );\n\n        this._processPlugins('compile', mail, err => {\n            if (err) {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'plugin',\n                        action: 'compile'\n                    },\n                    'PluginCompile Error: %s',\n                    err.message\n                );\n                return callback(err);\n            }\n\n            mail.message = new MailComposer(mail.data).compile();\n\n            mail.setMailerHeader();\n            mail.setPriorityHeaders();\n            mail.setListHeaders();\n\n            this._processPlugins('stream', mail, err => {\n                if (err) {\n                    this.logger.error(\n                        {\n                            err,\n                            tnx: 'plugin',\n                            action: 'stream'\n                        },\n                        'PluginStream Error: %s',\n                        err.message\n                    );\n                    return callback(err);\n                }\n\n                if (mail.data.dkim || this.dkim) {\n                    mail.message.processFunc(input => {\n                        let dkim = mail.data.dkim ? new DKIM(mail.data.dkim) : this.dkim;\n                        this.logger.debug(\n                            {\n                                tnx: 'DKIM',\n                                messageId: mail.message.messageId(),\n                                dkimDomains: dkim.keys.map(key => key.keySelector + '.' + key.domainName).join(', ')\n                            },\n                            'Signing outgoing message with %s keys',\n                            dkim.keys.length\n                        );\n                        return dkim.sign(input, mail.data._dkim);\n                    });\n                }\n\n                this.transporter.send(mail, (...args) => {\n                    if (args[0]) {\n                        this.logger.error(\n                            {\n                                err: args[0],\n                                tnx: 'transport',\n                                action: 'send'\n                            },\n                            'Send Error: %s',\n                            args[0].message\n                        );\n                    }\n                    callback(...args);\n                });\n            });\n        });\n\n        return promise;\n    }\n\n    getVersionString() {\n        return util.format('%s (%s; +%s; %s/%s)', packageData.name, packageData.version, packageData.homepage, this.transporter.name, this.transporter.version);\n    }\n\n    _processPlugins(step, mail, callback) {\n        step = (step || '').toString();\n\n        if (!this._userPlugins.hasOwnProperty(step)) {\n            return callback();\n        }\n\n        let userPlugins = this._userPlugins[step] || [];\n        let defaultPlugins = this._defaultPlugins[step] || [];\n\n        if (userPlugins.length) {\n            this.logger.debug(\n                {\n                    tnx: 'transaction',\n                    pluginCount: userPlugins.length,\n                    step\n                },\n                'Using %s plugins for %s',\n                userPlugins.length,\n                step\n            );\n        }\n\n        if (userPlugins.length + defaultPlugins.length === 0) {\n            return callback();\n        }\n\n        let pos = 0;\n        let block = 'default';\n        let processPlugins = () => {\n            let curplugins = block === 'default' ? defaultPlugins : userPlugins;\n            if (pos >= curplugins.length) {\n                if (block === 'default' && userPlugins.length) {\n                    block = 'user';\n                    pos = 0;\n                    curplugins = userPlugins;\n                } else {\n                    return callback();\n                }\n            }\n            let plugin = curplugins[pos++];\n            plugin(mail, err => {\n                if (err) {\n                    return callback(err);\n                }\n                processPlugins();\n            });\n        };\n\n        processPlugins();\n    }\n\n    /**\n     * Sets up proxy handler for a Nodemailer object\n     *\n     * @param {String} proxyUrl Proxy configuration url\n     */\n    setupProxy(proxyUrl) {\n        let proxy = urllib.parse(proxyUrl);\n\n        // setup socket handler for the mailer object\n        this.getSocket = (options, callback) => {\n            let protocol = proxy.protocol.replace(/:$/, '').toLowerCase();\n\n            if (this.meta.has('proxy_handler_' + protocol)) {\n                return this.meta.get('proxy_handler_' + protocol)(proxy, options, callback);\n            }\n\n            switch (protocol) {\n                // Connect using a HTTP CONNECT method\n                case 'http':\n                case 'https':\n                    httpProxyClient(proxy.href, options.port, options.host, (err, socket) => {\n                        if (err) {\n                            return callback(err);\n                        }\n                        return callback(null, {\n                            connection: socket\n                        });\n                    });\n                    return;\n                case 'socks':\n                case 'socks5':\n                case 'socks4':\n                case 'socks4a': {\n                    if (!this.meta.has('proxy_socks_module')) {\n                        return callback(new Error('Socks module not loaded'));\n                    }\n                    let connect = ipaddress => {\n                        let proxyV2 = !!this.meta.get('proxy_socks_module').SocksClient;\n                        let socksClient = proxyV2 ? this.meta.get('proxy_socks_module').SocksClient : this.meta.get('proxy_socks_module');\n                        let proxyType = Number(proxy.protocol.replace(/\\D/g, '')) || 5;\n                        let connectionOpts = {\n                            proxy: {\n                                ipaddress,\n                                port: Number(proxy.port),\n                                type: proxyType\n                            },\n                            [proxyV2 ? 'destination' : 'target']: {\n                                host: options.host,\n                                port: options.port\n                            },\n                            command: 'connect'\n                        };\n\n                        if (proxy.auth) {\n                            let username = decodeURIComponent(proxy.auth.split(':').shift());\n                            let password = decodeURIComponent(proxy.auth.split(':').pop());\n                            if (proxyV2) {\n                                connectionOpts.proxy.userId = username;\n                                connectionOpts.proxy.password = password;\n                            } else if (proxyType === 4) {\n                                connectionOpts.userid = username;\n                            } else {\n                                connectionOpts.authentication = {\n                                    username,\n                                    password\n                                };\n                            }\n                        }\n\n                        socksClient.createConnection(connectionOpts, (err, info) => {\n                            if (err) {\n                                return callback(err);\n                            }\n                            return callback(null, {\n                                connection: info.socket || info\n                            });\n                        });\n                    };\n\n                    if (net.isIP(proxy.hostname)) {\n                        return connect(proxy.hostname);\n                    }\n\n                    return dns.resolve(proxy.hostname, (err, address) => {\n                        if (err) {\n                            return callback(err);\n                        }\n                        connect(Array.isArray(address) ? address[0] : address);\n                    });\n                }\n            }\n            callback(new Error('Unknown proxy configuration'));\n        };\n    }\n\n    _convertDataImages(mail, callback) {\n        if ((!this.options.attachDataUrls && !mail.data.attachDataUrls) || !mail.data.html) {\n            return callback();\n        }\n        mail.resolveContent(mail.data, 'html', (err, html) => {\n            if (err) {\n                return callback(err);\n            }\n            let cidCounter = 0;\n            html = (html || '')\n                .toString()\n                .replace(/(<img\\b[^<>]{0,1024} src\\s{0,20}=[\\s\"']{0,20})(data:([^;]+);[^\"'>\\s]+)/gi, (match, prefix, dataUri, mimeType) => {\n                    let cid = crypto.randomBytes(10).toString('hex') + '@localhost';\n                    if (!mail.data.attachments) {\n                        mail.data.attachments = [];\n                    }\n                    if (!Array.isArray(mail.data.attachments)) {\n                        mail.data.attachments = [].concat(mail.data.attachments || []);\n                    }\n                    mail.data.attachments.push({\n                        path: dataUri,\n                        cid,\n                        filename: 'image-' + ++cidCounter + '.' + mimeTypes.detectExtension(mimeType)\n                    });\n                    return prefix + 'cid:' + cid;\n                });\n            mail.data.html = html;\n            callback();\n        });\n    }\n\n    set(key, value) {\n        return this.meta.set(key, value);\n    }\n\n    get(key) {\n        return this.meta.get(key);\n    }\n}\n\nmodule.exports = Mail;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvbWFpbGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLHNCQUFRO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVztBQUNsQyxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBMEI7QUFDcEQscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWtCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyxrRUFBUztBQUM5Qix3QkFBd0IsbUJBQU8sQ0FBQyxzSEFBc0M7QUFDdEUsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxnQkFBSztBQUM1QixvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBb0I7QUFDaEQsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzVDLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsZUFBZSxtQkFBTyxDQUFDLHNCQUFROztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxLQUFLO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRLE1BQU0sS0FBSyxRQUFRLEtBQUssV0FBVyxJQUFJO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9tYWlsZXIvaW5kZXguanM/ZDQxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3Qgc2hhcmVkID0gcmVxdWlyZSgnLi4vc2hhcmVkJyk7XG5jb25zdCBtaW1lVHlwZXMgPSByZXF1aXJlKCcuLi9taW1lLWZ1bmNzL21pbWUtdHlwZXMnKTtcbmNvbnN0IE1haWxDb21wb3NlciA9IHJlcXVpcmUoJy4uL21haWwtY29tcG9zZXInKTtcbmNvbnN0IERLSU0gPSByZXF1aXJlKCcuLi9ka2ltJyk7XG5jb25zdCBodHRwUHJveHlDbGllbnQgPSByZXF1aXJlKCcuLi9zbXRwLWNvbm5lY3Rpb24vaHR0cC1wcm94eS1jbGllbnQnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB1cmxsaWIgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IHBhY2thZ2VEYXRhID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJyk7XG5jb25zdCBNYWlsTWVzc2FnZSA9IHJlcXVpcmUoJy4vbWFpbC1tZXNzYWdlJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IGRucyA9IHJlcXVpcmUoJ2RucycpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgZm9yIGV4cG9zaW5nIHRoZSBNYWlsIEFQSVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zcG9ydGVyIFRyYW5zcG9ydCBvYmplY3QgaW5zdGFuY2UgdG8gcGFzcyB0aGUgbWFpbHMgdG9cbiAqL1xuY2xhc3MgTWFpbCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0ZXIsIG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdHMgPSBkZWZhdWx0cyB8fCB7fTtcblxuICAgICAgICB0aGlzLl9kZWZhdWx0UGx1Z2lucyA9IHtcbiAgICAgICAgICAgIGNvbXBpbGU6IFsoLi4uYXJncykgPT4gdGhpcy5fY29udmVydERhdGFJbWFnZXMoLi4uYXJncyldLFxuICAgICAgICAgICAgc3RyZWFtOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3VzZXJQbHVnaW5zID0ge1xuICAgICAgICAgICAgY29tcGlsZTogW10sXG4gICAgICAgICAgICBzdHJlYW06IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5tZXRhID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMuZGtpbSA9IHRoaXMub3B0aW9ucy5ka2ltID8gbmV3IERLSU0odGhpcy5vcHRpb25zLmRraW0pIDogZmFsc2U7XG5cbiAgICAgICAgdGhpcy50cmFuc3BvcnRlciA9IHRyYW5zcG9ydGVyO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydGVyLm1haWxlciA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5sb2dnZXIgPSBzaGFyZWQuZ2V0TG9nZ2VyKHRoaXMub3B0aW9ucywge1xuICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLm9wdGlvbnMuY29tcG9uZW50IHx8ICdtYWlsJ1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0bng6ICdjcmVhdGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ0NyZWF0aW5nIHRyYW5zcG9ydDogJXMnLFxuICAgICAgICAgICAgdGhpcy5nZXRWZXJzaW9uU3RyaW5nKClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBzZXR1cCBlbWl0IGhhbmRsZXJzIGZvciB0aGUgdHJhbnNwb3J0ZXJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRyYW5zcG9ydGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkIGxvZyBpbnRlcmZhY2VcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ZXIub24oJ2xvZycsIGxvZyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3RyYW5zcG9ydCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJyVzOiAlcycsXG4gICAgICAgICAgICAgICAgICAgIGxvZy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBsb2cubWVzc2FnZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gdHJhbnNwb3J0ZXIgZXJyb3JzXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydGVyLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3RyYW5zcG9ydCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ1RyYW5zcG9ydCBFcnJvcjogJXMnLFxuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gaW5kaWNhdGVzIGlmIHRoZSBzZW5kZXIgaGFzIGJlY2FtZSBpZGxlXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydGVyLm9uKCdpZGxlJywgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2lkbGUnLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIG1ldGhvZHMgcGFzc2VkIHRvIHRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydCBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFsnY2xvc2UnLCAnaXNJZGxlJywgJ3ZlcmlmeSddLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRyYW5zcG9ydGVyW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ3ZlcmlmeScgJiYgdHlwZW9mIHRoaXMuZ2V0U29ja2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydGVyLmdldFNvY2tldCA9IHRoaXMuZ2V0U29ja2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRTb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRlclttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG54OiAndHJhbnNwb3J0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2ROYW1lOiBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnTm9uIGV4aXN0aW5nIG1ldGhvZCAlcyBjYWxsZWQgZm9yIHRyYW5zcG9ydCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNldHVwIHByb3h5IGhhbmRsaW5nXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJveHkgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5wcm94eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBQcm94eSh0aGlzLm9wdGlvbnMucHJveHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXNlKHN0ZXAsIHBsdWdpbikge1xuICAgICAgICBzdGVwID0gKHN0ZXAgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghdGhpcy5fdXNlclBsdWdpbnMuaGFzT3duUHJvcGVydHkoc3RlcCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VzZXJQbHVnaW5zW3N0ZXBdID0gW3BsdWdpbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl91c2VyUGx1Z2luc1tzdGVwXS5wdXNoKHBsdWdpbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhbiBlbWFpbCB1c2luZyB0aGUgcHJlc2VsZWN0ZWQgdHJhbnNwb3J0IG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRS1kYXRhIGRlc2NyaXB0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbj99IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1biBvbmNlIHRoZSBzZW5kaW5nIHN1Y2NlZWRlZCBvciBmYWlsZWRcbiAgICAgKi9cbiAgICBzZW5kTWFpbChkYXRhLCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICAgICAgbGV0IHByb21pc2U7XG5cbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHNoYXJlZC5jYWxsYmFja1Byb21pc2UocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdldFNvY2tldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRlci5nZXRTb2NrZXQgPSB0aGlzLmdldFNvY2tldDtcbiAgICAgICAgICAgIHRoaXMuZ2V0U29ja2V0ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWFpbCA9IG5ldyBNYWlsTWVzc2FnZSh0aGlzLCBkYXRhKTtcblxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0bng6ICd0cmFuc3BvcnQnLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMudHJhbnNwb3J0ZXIubmFtZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnRyYW5zcG9ydGVyLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnc2VuZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnU2VuZGluZyBtYWlsIHVzaW5nICVzLyVzJyxcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ZXIubmFtZSxcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ZXIudmVyc2lvblxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NQbHVnaW5zKCdjb21waWxlJywgbWFpbCwgZXJyID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG54OiAncGx1Z2luJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2NvbXBpbGUnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdQbHVnaW5Db21waWxlIEVycm9yOiAlcycsXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWFpbC5tZXNzYWdlID0gbmV3IE1haWxDb21wb3NlcihtYWlsLmRhdGEpLmNvbXBpbGUoKTtcblxuICAgICAgICAgICAgbWFpbC5zZXRNYWlsZXJIZWFkZXIoKTtcbiAgICAgICAgICAgIG1haWwuc2V0UHJpb3JpdHlIZWFkZXJzKCk7XG4gICAgICAgICAgICBtYWlsLnNldExpc3RIZWFkZXJzKCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NQbHVnaW5zKCdzdHJlYW0nLCBtYWlsLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3BsdWdpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnc3RyZWFtJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQbHVnaW5TdHJlYW0gRXJyb3I6ICVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtYWlsLmRhdGEuZGtpbSB8fCB0aGlzLmRraW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbC5tZXNzYWdlLnByb2Nlc3NGdW5jKGlucHV0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBka2ltID0gbWFpbC5kYXRhLmRraW0gPyBuZXcgREtJTShtYWlsLmRhdGEuZGtpbSkgOiB0aGlzLmRraW07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ0RLSU0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IG1haWwubWVzc2FnZS5tZXNzYWdlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGtpbURvbWFpbnM6IGRraW0ua2V5cy5tYXAoa2V5ID0+IGtleS5rZXlTZWxlY3RvciArICcuJyArIGtleS5kb21haW5OYW1lKS5qb2luKCcsICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnU2lnbmluZyBvdXRnb2luZyBtZXNzYWdlIHdpdGggJXMga2V5cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGtpbS5rZXlzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBka2ltLnNpZ24oaW5wdXQsIG1haWwuZGF0YS5fZGtpbSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ZXIuc2VuZChtYWlsLCAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnc1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnI6IGFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3RyYW5zcG9ydCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ3NlbmQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnU2VuZCBFcnJvcjogJXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0ubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICBnZXRWZXJzaW9uU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdXRpbC5mb3JtYXQoJyVzICglczsgKyVzOyAlcy8lcyknLCBwYWNrYWdlRGF0YS5uYW1lLCBwYWNrYWdlRGF0YS52ZXJzaW9uLCBwYWNrYWdlRGF0YS5ob21lcGFnZSwgdGhpcy50cmFuc3BvcnRlci5uYW1lLCB0aGlzLnRyYW5zcG9ydGVyLnZlcnNpb24pO1xuICAgIH1cblxuICAgIF9wcm9jZXNzUGx1Z2lucyhzdGVwLCBtYWlsLCBjYWxsYmFjaykge1xuICAgICAgICBzdGVwID0gKHN0ZXAgfHwgJycpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl91c2VyUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShzdGVwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdXNlclBsdWdpbnMgPSB0aGlzLl91c2VyUGx1Z2luc1tzdGVwXSB8fCBbXTtcbiAgICAgICAgbGV0IGRlZmF1bHRQbHVnaW5zID0gdGhpcy5fZGVmYXVsdFBsdWdpbnNbc3RlcF0gfHwgW107XG5cbiAgICAgICAgaWYgKHVzZXJQbHVnaW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0bng6ICd0cmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbkNvdW50OiB1c2VyUGx1Z2lucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdVc2luZyAlcyBwbHVnaW5zIGZvciAlcycsXG4gICAgICAgICAgICAgICAgdXNlclBsdWdpbnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHN0ZXBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXNlclBsdWdpbnMubGVuZ3RoICsgZGVmYXVsdFBsdWdpbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBsZXQgYmxvY2sgPSAnZGVmYXVsdCc7XG4gICAgICAgIGxldCBwcm9jZXNzUGx1Z2lucyA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBjdXJwbHVnaW5zID0gYmxvY2sgPT09ICdkZWZhdWx0JyA/IGRlZmF1bHRQbHVnaW5zIDogdXNlclBsdWdpbnM7XG4gICAgICAgICAgICBpZiAocG9zID49IGN1cnBsdWdpbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrID09PSAnZGVmYXVsdCcgJiYgdXNlclBsdWdpbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrID0gJ3VzZXInO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjdXJwbHVnaW5zID0gdXNlclBsdWdpbnM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBsdWdpbiA9IGN1cnBsdWdpbnNbcG9zKytdO1xuICAgICAgICAgICAgcGx1Z2luKG1haWwsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2Vzc1BsdWdpbnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHByb2Nlc3NQbHVnaW5zKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBwcm94eSBoYW5kbGVyIGZvciBhIE5vZGVtYWlsZXIgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJveHlVcmwgUHJveHkgY29uZmlndXJhdGlvbiB1cmxcbiAgICAgKi9cbiAgICBzZXR1cFByb3h5KHByb3h5VXJsKSB7XG4gICAgICAgIGxldCBwcm94eSA9IHVybGxpYi5wYXJzZShwcm94eVVybCk7XG5cbiAgICAgICAgLy8gc2V0dXAgc29ja2V0IGhhbmRsZXIgZm9yIHRoZSBtYWlsZXIgb2JqZWN0XG4gICAgICAgIHRoaXMuZ2V0U29ja2V0ID0gKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBsZXQgcHJvdG9jb2wgPSBwcm94eS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tZXRhLmhhcygncHJveHlfaGFuZGxlcl8nICsgcHJvdG9jb2wpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWV0YS5nZXQoJ3Byb3h5X2hhbmRsZXJfJyArIHByb3RvY29sKShwcm94eSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29ubmVjdCB1c2luZyBhIEhUVFAgQ09OTkVDVCBtZXRob2RcbiAgICAgICAgICAgICAgICBjYXNlICdodHRwJzpcbiAgICAgICAgICAgICAgICBjYXNlICdodHRwcyc6XG4gICAgICAgICAgICAgICAgICAgIGh0dHBQcm94eUNsaWVudChwcm94eS5ocmVmLCBvcHRpb25zLnBvcnQsIG9wdGlvbnMuaG9zdCwgKGVyciwgc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IHNvY2tldFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnc29ja3MnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NvY2tzNSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc29ja3M0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdzb2NrczRhJzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWV0YS5oYXMoJ3Byb3h5X3NvY2tzX21vZHVsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdTb2NrcyBtb2R1bGUgbm90IGxvYWRlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29ubmVjdCA9IGlwYWRkcmVzcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJveHlWMiA9ICEhdGhpcy5tZXRhLmdldCgncHJveHlfc29ja3NfbW9kdWxlJykuU29ja3NDbGllbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc29ja3NDbGllbnQgPSBwcm94eVYyID8gdGhpcy5tZXRhLmdldCgncHJveHlfc29ja3NfbW9kdWxlJykuU29ja3NDbGllbnQgOiB0aGlzLm1ldGEuZ2V0KCdwcm94eV9zb2Nrc19tb2R1bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcm94eVR5cGUgPSBOdW1iZXIocHJveHkucHJvdG9jb2wucmVwbGFjZSgvXFxEL2csICcnKSkgfHwgNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb25uZWN0aW9uT3B0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IE51bWJlcihwcm94eS5wb3J0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcHJveHlUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcHJveHlWMiA/ICdkZXN0aW5hdGlvbicgOiAndGFyZ2V0J106IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogb3B0aW9ucy5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBvcHRpb25zLnBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjb25uZWN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3h5LmF1dGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXNlcm5hbWUgPSBkZWNvZGVVUklDb21wb25lbnQocHJveHkuYXV0aC5zcGxpdCgnOicpLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXNzd29yZCA9IGRlY29kZVVSSUNvbXBvbmVudChwcm94eS5hdXRoLnNwbGl0KCc6JykucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm94eVYyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRzLnByb3h5LnVzZXJJZCA9IHVzZXJuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0cy5wcm94eS5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJveHlUeXBlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRzLnVzZXJpZCA9IHVzZXJuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRzLmF1dGhlbnRpY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc29ja3NDbGllbnQuY3JlYXRlQ29ubmVjdGlvbihjb25uZWN0aW9uT3B0cywgKGVyciwgaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IGluZm8uc29ja2V0IHx8IGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXQuaXNJUChwcm94eS5ob3N0bmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0KHByb3h5Lmhvc3RuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkbnMucmVzb2x2ZShwcm94eS5ob3N0bmFtZSwgKGVyciwgYWRkcmVzcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdChBcnJheS5pc0FycmF5KGFkZHJlc3MpID8gYWRkcmVzc1swXSA6IGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ1Vua25vd24gcHJveHkgY29uZmlndXJhdGlvbicpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfY29udmVydERhdGFJbWFnZXMobWFpbCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCghdGhpcy5vcHRpb25zLmF0dGFjaERhdGFVcmxzICYmICFtYWlsLmRhdGEuYXR0YWNoRGF0YVVybHMpIHx8ICFtYWlsLmRhdGEuaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgbWFpbC5yZXNvbHZlQ29udGVudChtYWlsLmRhdGEsICdodG1sJywgKGVyciwgaHRtbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNpZENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgaHRtbCA9IChodG1sIHx8ICcnKVxuICAgICAgICAgICAgICAgIC50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyg8aW1nXFxiW148Pl17MCwxMDI0fSBzcmNcXHN7MCwyMH09W1xcc1wiJ117MCwyMH0pKGRhdGE6KFteO10rKTtbXlwiJz5cXHNdKykvZ2ksIChtYXRjaCwgcHJlZml4LCBkYXRhVXJpLCBtaW1lVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2lkID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDEwKS50b1N0cmluZygnaGV4JykgKyAnQGxvY2FsaG9zdCc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFpbC5kYXRhLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWlsLmRhdGEuYXR0YWNobWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWFpbC5kYXRhLmF0dGFjaG1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbC5kYXRhLmF0dGFjaG1lbnRzID0gW10uY29uY2F0KG1haWwuZGF0YS5hdHRhY2htZW50cyB8fCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFpbC5kYXRhLmF0dGFjaG1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZGF0YVVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiAnaW1hZ2UtJyArICsrY2lkQ291bnRlciArICcuJyArIG1pbWVUeXBlcy5kZXRlY3RFeHRlbnNpb24obWltZVR5cGUpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgJ2NpZDonICsgY2lkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWFpbC5kYXRhLmh0bWwgPSBodG1sO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhLmdldChrZXkpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNYWlsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/mailer/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/mailer/mail-message.js":
/*!************************************************************!*\
  !*** ./node_modules/nodemailer/lib/mailer/mail-message.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst shared = __webpack_require__(/*! ../shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\");\nconst MimeNode = __webpack_require__(/*! ../mime-node */ \"(rsc)/./node_modules/nodemailer/lib/mime-node/index.js\");\nconst mimeFuncs = __webpack_require__(/*! ../mime-funcs */ \"(rsc)/./node_modules/nodemailer/lib/mime-funcs/index.js\");\n\nclass MailMessage {\n    constructor(mailer, data) {\n        this.mailer = mailer;\n        this.data = {};\n        this.message = null;\n\n        data = data || {};\n        let options = mailer.options || {};\n        let defaults = mailer._defaults || {};\n\n        Object.keys(data).forEach(key => {\n            this.data[key] = data[key];\n        });\n\n        this.data.headers = this.data.headers || {};\n\n        // apply defaults\n        Object.keys(defaults).forEach(key => {\n            if (!(key in this.data)) {\n                this.data[key] = defaults[key];\n            } else if (key === 'headers') {\n                // headers is a special case. Allow setting individual default headers\n                Object.keys(defaults.headers).forEach(key => {\n                    if (!(key in this.data.headers)) {\n                        this.data.headers[key] = defaults.headers[key];\n                    }\n                });\n            }\n        });\n\n        // force specific keys from transporter options\n        ['disableFileAccess', 'disableUrlAccess', 'normalizeHeaderKey'].forEach(key => {\n            if (key in options) {\n                this.data[key] = options[key];\n            }\n        });\n    }\n\n    resolveContent(...args) {\n        return shared.resolveContent(...args);\n    }\n\n    resolveAll(callback) {\n        let keys = [\n            [this.data, 'html'],\n            [this.data, 'text'],\n            [this.data, 'watchHtml'],\n            [this.data, 'amp'],\n            [this.data, 'icalEvent']\n        ];\n\n        if (this.data.alternatives && this.data.alternatives.length) {\n            this.data.alternatives.forEach((alternative, i) => {\n                keys.push([this.data.alternatives, i]);\n            });\n        }\n\n        if (this.data.attachments && this.data.attachments.length) {\n            this.data.attachments.forEach((attachment, i) => {\n                if (!attachment.filename) {\n                    attachment.filename = (attachment.path || attachment.href || '').split('/').pop().split('?').shift() || 'attachment-' + (i + 1);\n                    if (attachment.filename.indexOf('.') < 0) {\n                        attachment.filename += '.' + mimeFuncs.detectExtension(attachment.contentType);\n                    }\n                }\n\n                if (!attachment.contentType) {\n                    attachment.contentType = mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin');\n                }\n\n                keys.push([this.data.attachments, i]);\n            });\n        }\n\n        let mimeNode = new MimeNode();\n\n        let addressKeys = ['from', 'to', 'cc', 'bcc', 'sender', 'replyTo'];\n\n        addressKeys.forEach(address => {\n            let value;\n            if (this.message) {\n                value = [].concat(mimeNode._parseAddresses(this.message.getHeader(address === 'replyTo' ? 'reply-to' : address)) || []);\n            } else if (this.data[address]) {\n                value = [].concat(mimeNode._parseAddresses(this.data[address]) || []);\n            }\n            if (value && value.length) {\n                this.data[address] = value;\n            } else if (address in this.data) {\n                this.data[address] = null;\n            }\n        });\n\n        let singleKeys = ['from', 'sender'];\n        singleKeys.forEach(address => {\n            if (this.data[address]) {\n                this.data[address] = this.data[address].shift();\n            }\n        });\n\n        let pos = 0;\n        let resolveNext = () => {\n            if (pos >= keys.length) {\n                return callback(null, this.data);\n            }\n            let args = keys[pos++];\n            if (!args[0] || !args[0][args[1]]) {\n                return resolveNext();\n            }\n            shared.resolveContent(...args, (err, value) => {\n                if (err) {\n                    return callback(err);\n                }\n\n                let node = {\n                    content: value\n                };\n                if (args[0][args[1]] && typeof args[0][args[1]] === 'object' && !Buffer.isBuffer(args[0][args[1]])) {\n                    Object.keys(args[0][args[1]]).forEach(key => {\n                        if (!(key in node) && !['content', 'path', 'href', 'raw'].includes(key)) {\n                            node[key] = args[0][args[1]][key];\n                        }\n                    });\n                }\n\n                args[0][args[1]] = node;\n                resolveNext();\n            });\n        };\n\n        setImmediate(() => resolveNext());\n    }\n\n    normalize(callback) {\n        let envelope = this.data.envelope || this.message.getEnvelope();\n        let messageId = this.message.messageId();\n\n        this.resolveAll((err, data) => {\n            if (err) {\n                return callback(err);\n            }\n\n            data.envelope = envelope;\n            data.messageId = messageId;\n\n            ['html', 'text', 'watchHtml', 'amp'].forEach(key => {\n                if (data[key] && data[key].content) {\n                    if (typeof data[key].content === 'string') {\n                        data[key] = data[key].content;\n                    } else if (Buffer.isBuffer(data[key].content)) {\n                        data[key] = data[key].content.toString();\n                    }\n                }\n            });\n\n            if (data.icalEvent && Buffer.isBuffer(data.icalEvent.content)) {\n                data.icalEvent.content = data.icalEvent.content.toString('base64');\n                data.icalEvent.encoding = 'base64';\n            }\n\n            if (data.alternatives && data.alternatives.length) {\n                data.alternatives.forEach(alternative => {\n                    if (alternative && alternative.content && Buffer.isBuffer(alternative.content)) {\n                        alternative.content = alternative.content.toString('base64');\n                        alternative.encoding = 'base64';\n                    }\n                });\n            }\n\n            if (data.attachments && data.attachments.length) {\n                data.attachments.forEach(attachment => {\n                    if (attachment && attachment.content && Buffer.isBuffer(attachment.content)) {\n                        attachment.content = attachment.content.toString('base64');\n                        attachment.encoding = 'base64';\n                    }\n                });\n            }\n\n            data.normalizedHeaders = {};\n            Object.keys(data.headers || {}).forEach(key => {\n                let value = [].concat(data.headers[key] || []).shift();\n                value = (value && value.value) || value;\n                if (value) {\n                    if (['references', 'in-reply-to', 'message-id', 'content-id'].includes(key)) {\n                        value = this.message._encodeHeaderValue(key, value);\n                    }\n                    data.normalizedHeaders[key] = value;\n                }\n            });\n\n            if (data.list && typeof data.list === 'object') {\n                let listHeaders = this._getListHeaders(data.list);\n                listHeaders.forEach(entry => {\n                    data.normalizedHeaders[entry.key] = entry.value.map(val => (val && val.value) || val).join(', ');\n                });\n            }\n\n            if (data.references) {\n                data.normalizedHeaders.references = this.message._encodeHeaderValue('references', data.references);\n            }\n\n            if (data.inReplyTo) {\n                data.normalizedHeaders['in-reply-to'] = this.message._encodeHeaderValue('in-reply-to', data.inReplyTo);\n            }\n\n            return callback(null, data);\n        });\n    }\n\n    setMailerHeader() {\n        if (!this.message || !this.data.xMailer) {\n            return;\n        }\n        this.message.setHeader('X-Mailer', this.data.xMailer);\n    }\n\n    setPriorityHeaders() {\n        if (!this.message || !this.data.priority) {\n            return;\n        }\n        switch ((this.data.priority || '').toString().toLowerCase()) {\n            case 'high':\n                this.message.setHeader('X-Priority', '1 (Highest)');\n                this.message.setHeader('X-MSMail-Priority', 'High');\n                this.message.setHeader('Importance', 'High');\n                break;\n            case 'low':\n                this.message.setHeader('X-Priority', '5 (Lowest)');\n                this.message.setHeader('X-MSMail-Priority', 'Low');\n                this.message.setHeader('Importance', 'Low');\n                break;\n            default:\n            // do not add anything, since all messages are 'Normal' by default\n        }\n    }\n\n    setListHeaders() {\n        if (!this.message || !this.data.list || typeof this.data.list !== 'object') {\n            return;\n        }\n        // add optional List-* headers\n        if (this.data.list && typeof this.data.list === 'object') {\n            this._getListHeaders(this.data.list).forEach(listHeader => {\n                listHeader.value.forEach(value => {\n                    this.message.addHeader(listHeader.key, value);\n                });\n            });\n        }\n    }\n\n    _getListHeaders(listData) {\n        // make sure an url looks like <protocol:url>\n        return Object.keys(listData).map(key => ({\n            key: 'list-' + key.toLowerCase().trim(),\n            value: [].concat(listData[key] || []).map(value => ({\n                prepared: true,\n                foldLines: true,\n                value: []\n                    .concat(value || [])\n                    .map(value => {\n                        if (typeof value === 'string') {\n                            value = {\n                                url: value\n                            };\n                        }\n\n                        if (value && value.url) {\n                            if (key.toLowerCase().trim() === 'id') {\n                                // List-ID: \"comment\" <domain>\n                                let comment = value.comment || '';\n                                if (mimeFuncs.isPlainText(comment)) {\n                                    comment = '\"' + comment + '\"';\n                                } else {\n                                    comment = mimeFuncs.encodeWord(comment);\n                                }\n\n                                return (value.comment ? comment + ' ' : '') + this._formatListUrl(value.url).replace(/^<[^:]+\\/{,2}/, '');\n                            }\n\n                            // List-*: <http://domain> (comment)\n                            let comment = value.comment || '';\n                            if (!mimeFuncs.isPlainText(comment)) {\n                                comment = mimeFuncs.encodeWord(comment);\n                            }\n\n                            return this._formatListUrl(value.url) + (value.comment ? ' (' + comment + ')' : '');\n                        }\n\n                        return '';\n                    })\n                    .filter(value => value)\n                    .join(', ')\n            }))\n        }));\n    }\n\n    _formatListUrl(url) {\n        url = url.replace(/[\\s<]+|[\\s>]+/g, '');\n        if (/^(https?|mailto|ftp):/.test(url)) {\n            return '<' + url + '>';\n        }\n        if (/^[^@]+@[^@]+$/.test(url)) {\n            return '<mailto:' + url + '>';\n        }\n\n        return '<http://' + url + '>';\n    }\n}\n\nmodule.exports = MailMessage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvbWFpbGVyL21haWwtbWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsc0VBQVc7QUFDbEMsaUJBQWlCLG1CQUFPLENBQUMsNEVBQWM7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMsOEVBQWU7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBLGdJQUFnSSxHQUFHO0FBQ25JOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlbWFya2V0Ly4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL21haWxlci9tYWlsLW1lc3NhZ2UuanM/MDdmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNoYXJlZCA9IHJlcXVpcmUoJy4uL3NoYXJlZCcpO1xuY29uc3QgTWltZU5vZGUgPSByZXF1aXJlKCcuLi9taW1lLW5vZGUnKTtcbmNvbnN0IG1pbWVGdW5jcyA9IHJlcXVpcmUoJy4uL21pbWUtZnVuY3MnKTtcblxuY2xhc3MgTWFpbE1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKG1haWxlciwgZGF0YSkge1xuICAgICAgICB0aGlzLm1haWxlciA9IG1haWxlcjtcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG51bGw7XG5cbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICAgIGxldCBvcHRpb25zID0gbWFpbGVyLm9wdGlvbnMgfHwge307XG4gICAgICAgIGxldCBkZWZhdWx0cyA9IG1haWxlci5fZGVmYXVsdHMgfHwge307XG5cbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZGF0YS5oZWFkZXJzID0gdGhpcy5kYXRhLmhlYWRlcnMgfHwge307XG5cbiAgICAgICAgLy8gYXBwbHkgZGVmYXVsdHNcbiAgICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiB0aGlzLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdoZWFkZXJzJykge1xuICAgICAgICAgICAgICAgIC8vIGhlYWRlcnMgaXMgYSBzcGVjaWFsIGNhc2UuIEFsbG93IHNldHRpbmcgaW5kaXZpZHVhbCBkZWZhdWx0IGhlYWRlcnNcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkZWZhdWx0cy5oZWFkZXJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiB0aGlzLmRhdGEuaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5oZWFkZXJzW2tleV0gPSBkZWZhdWx0cy5oZWFkZXJzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZm9yY2Ugc3BlY2lmaWMga2V5cyBmcm9tIHRyYW5zcG9ydGVyIG9wdGlvbnNcbiAgICAgICAgWydkaXNhYmxlRmlsZUFjY2VzcycsICdkaXNhYmxlVXJsQWNjZXNzJywgJ25vcm1hbGl6ZUhlYWRlcktleSddLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtrZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXNvbHZlQ29udGVudCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzaGFyZWQucmVzb2x2ZUNvbnRlbnQoLi4uYXJncyk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZUFsbChjYWxsYmFjaykge1xuICAgICAgICBsZXQga2V5cyA9IFtcbiAgICAgICAgICAgIFt0aGlzLmRhdGEsICdodG1sJ10sXG4gICAgICAgICAgICBbdGhpcy5kYXRhLCAndGV4dCddLFxuICAgICAgICAgICAgW3RoaXMuZGF0YSwgJ3dhdGNoSHRtbCddLFxuICAgICAgICAgICAgW3RoaXMuZGF0YSwgJ2FtcCddLFxuICAgICAgICAgICAgW3RoaXMuZGF0YSwgJ2ljYWxFdmVudCddXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5hbHRlcm5hdGl2ZXMgJiYgdGhpcy5kYXRhLmFsdGVybmF0aXZlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5hbHRlcm5hdGl2ZXMuZm9yRWFjaCgoYWx0ZXJuYXRpdmUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goW3RoaXMuZGF0YS5hbHRlcm5hdGl2ZXMsIGldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5hdHRhY2htZW50cyAmJiB0aGlzLmRhdGEuYXR0YWNobWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuYXR0YWNobWVudHMuZm9yRWFjaCgoYXR0YWNobWVudCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghYXR0YWNobWVudC5maWxlbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LmZpbGVuYW1lID0gKGF0dGFjaG1lbnQucGF0aCB8fCBhdHRhY2htZW50LmhyZWYgfHwgJycpLnNwbGl0KCcvJykucG9wKCkuc3BsaXQoJz8nKS5zaGlmdCgpIHx8ICdhdHRhY2htZW50LScgKyAoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudC5maWxlbmFtZS5pbmRleE9mKCcuJykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LmZpbGVuYW1lICs9ICcuJyArIG1pbWVGdW5jcy5kZXRlY3RFeHRlbnNpb24oYXR0YWNobWVudC5jb250ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWF0dGFjaG1lbnQuY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5jb250ZW50VHlwZSA9IG1pbWVGdW5jcy5kZXRlY3RNaW1lVHlwZShhdHRhY2htZW50LmZpbGVuYW1lIHx8IGF0dGFjaG1lbnQucGF0aCB8fCBhdHRhY2htZW50LmhyZWYgfHwgJ2JpbicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGtleXMucHVzaChbdGhpcy5kYXRhLmF0dGFjaG1lbnRzLCBpXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtaW1lTm9kZSA9IG5ldyBNaW1lTm9kZSgpO1xuXG4gICAgICAgIGxldCBhZGRyZXNzS2V5cyA9IFsnZnJvbScsICd0bycsICdjYycsICdiY2MnLCAnc2VuZGVyJywgJ3JlcGx5VG8nXTtcblxuICAgICAgICBhZGRyZXNzS2V5cy5mb3JFYWNoKGFkZHJlc3MgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gW10uY29uY2F0KG1pbWVOb2RlLl9wYXJzZUFkZHJlc3Nlcyh0aGlzLm1lc3NhZ2UuZ2V0SGVhZGVyKGFkZHJlc3MgPT09ICdyZXBseVRvJyA/ICdyZXBseS10bycgOiBhZGRyZXNzKSkgfHwgW10pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFbYWRkcmVzc10pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdLmNvbmNhdChtaW1lTm9kZS5fcGFyc2VBZGRyZXNzZXModGhpcy5kYXRhW2FkZHJlc3NdKSB8fCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2FkZHJlc3NdID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFkZHJlc3MgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2FkZHJlc3NdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHNpbmdsZUtleXMgPSBbJ2Zyb20nLCAnc2VuZGVyJ107XG4gICAgICAgIHNpbmdsZUtleXMuZm9yRWFjaChhZGRyZXNzID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbYWRkcmVzc10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbYWRkcmVzc10gPSB0aGlzLmRhdGFbYWRkcmVzc10uc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGxldCByZXNvbHZlTmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwb3MgPj0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdGhpcy5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhcmdzID0ga2V5c1twb3MrK107XG4gICAgICAgICAgICBpZiAoIWFyZ3NbMF0gfHwgIWFyZ3NbMF1bYXJnc1sxXV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZU5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoYXJlZC5yZXNvbHZlQ29udGVudCguLi5hcmdzLCAoZXJyLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnc1swXVthcmdzWzFdXSAmJiB0eXBlb2YgYXJnc1swXVthcmdzWzFdXSA9PT0gJ29iamVjdCcgJiYgIUJ1ZmZlci5pc0J1ZmZlcihhcmdzWzBdW2FyZ3NbMV1dKSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhcmdzWzBdW2FyZ3NbMV1dKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbm9kZSkgJiYgIVsnY29udGVudCcsICdwYXRoJywgJ2hyZWYnLCAncmF3J10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVba2V5XSA9IGFyZ3NbMF1bYXJnc1sxXV1ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJnc1swXVthcmdzWzFdXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZU5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiByZXNvbHZlTmV4dCgpKTtcbiAgICB9XG5cbiAgICBub3JtYWxpemUoY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGVudmVsb3BlID0gdGhpcy5kYXRhLmVudmVsb3BlIHx8IHRoaXMubWVzc2FnZS5nZXRFbnZlbG9wZSgpO1xuICAgICAgICBsZXQgbWVzc2FnZUlkID0gdGhpcy5tZXNzYWdlLm1lc3NhZ2VJZCgpO1xuXG4gICAgICAgIHRoaXMucmVzb2x2ZUFsbCgoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEuZW52ZWxvcGUgPSBlbnZlbG9wZTtcbiAgICAgICAgICAgIGRhdGEubWVzc2FnZUlkID0gbWVzc2FnZUlkO1xuXG4gICAgICAgICAgICBbJ2h0bWwnLCAndGV4dCcsICd3YXRjaEh0bWwnLCAnYW1wJ10uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2tleV0gJiYgZGF0YVtrZXldLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2tleV0uY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IGRhdGFba2V5XS5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhW2tleV0uY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IGRhdGFba2V5XS5jb250ZW50LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuaWNhbEV2ZW50ICYmIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLmljYWxFdmVudC5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgIGRhdGEuaWNhbEV2ZW50LmNvbnRlbnQgPSBkYXRhLmljYWxFdmVudC5jb250ZW50LnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgICAgICAgICBkYXRhLmljYWxFdmVudC5lbmNvZGluZyA9ICdiYXNlNjQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YS5hbHRlcm5hdGl2ZXMgJiYgZGF0YS5hbHRlcm5hdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5hbHRlcm5hdGl2ZXMuZm9yRWFjaChhbHRlcm5hdGl2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZSAmJiBhbHRlcm5hdGl2ZS5jb250ZW50ICYmIEJ1ZmZlci5pc0J1ZmZlcihhbHRlcm5hdGl2ZS5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmUuY29udGVudCA9IGFsdGVybmF0aXZlLmNvbnRlbnQudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmUuZW5jb2RpbmcgPSAnYmFzZTY0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YS5hdHRhY2htZW50cyAmJiBkYXRhLmF0dGFjaG1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRhdGEuYXR0YWNobWVudHMuZm9yRWFjaChhdHRhY2htZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQgJiYgYXR0YWNobWVudC5jb250ZW50ICYmIEJ1ZmZlci5pc0J1ZmZlcihhdHRhY2htZW50LmNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LmNvbnRlbnQgPSBhdHRhY2htZW50LmNvbnRlbnQudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5lbmNvZGluZyA9ICdiYXNlNjQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEubm9ybWFsaXplZEhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEuaGVhZGVycyB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IFtdLmNvbmNhdChkYXRhLmhlYWRlcnNba2V5XSB8fCBbXSkuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAmJiB2YWx1ZS52YWx1ZSkgfHwgdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChbJ3JlZmVyZW5jZXMnLCAnaW4tcmVwbHktdG8nLCAnbWVzc2FnZS1pZCcsICdjb250ZW50LWlkJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1lc3NhZ2UuX2VuY29kZUhlYWRlclZhbHVlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEubm9ybWFsaXplZEhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5saXN0ICYmIHR5cGVvZiBkYXRhLmxpc3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpc3RIZWFkZXJzID0gdGhpcy5fZ2V0TGlzdEhlYWRlcnMoZGF0YS5saXN0KTtcbiAgICAgICAgICAgICAgICBsaXN0SGVhZGVycy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5ub3JtYWxpemVkSGVhZGVyc1tlbnRyeS5rZXldID0gZW50cnkudmFsdWUubWFwKHZhbCA9PiAodmFsICYmIHZhbC52YWx1ZSkgfHwgdmFsKS5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YS5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5ub3JtYWxpemVkSGVhZGVycy5yZWZlcmVuY2VzID0gdGhpcy5tZXNzYWdlLl9lbmNvZGVIZWFkZXJWYWx1ZSgncmVmZXJlbmNlcycsIGRhdGEucmVmZXJlbmNlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmluUmVwbHlUbykge1xuICAgICAgICAgICAgICAgIGRhdGEubm9ybWFsaXplZEhlYWRlcnNbJ2luLXJlcGx5LXRvJ10gPSB0aGlzLm1lc3NhZ2UuX2VuY29kZUhlYWRlclZhbHVlKCdpbi1yZXBseS10bycsIGRhdGEuaW5SZXBseVRvKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXRNYWlsZXJIZWFkZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5tZXNzYWdlIHx8ICF0aGlzLmRhdGEueE1haWxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZS5zZXRIZWFkZXIoJ1gtTWFpbGVyJywgdGhpcy5kYXRhLnhNYWlsZXIpO1xuICAgIH1cblxuICAgIHNldFByaW9yaXR5SGVhZGVycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lc3NhZ2UgfHwgIXRoaXMuZGF0YS5wcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoKHRoaXMuZGF0YS5wcmlvcml0eSB8fCAnJykudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdoaWdoJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2Uuc2V0SGVhZGVyKCdYLVByaW9yaXR5JywgJzEgKEhpZ2hlc3QpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlLnNldEhlYWRlcignWC1NU01haWwtUHJpb3JpdHknLCAnSGlnaCcpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZS5zZXRIZWFkZXIoJ0ltcG9ydGFuY2UnLCAnSGlnaCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbG93JzpcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2Uuc2V0SGVhZGVyKCdYLVByaW9yaXR5JywgJzUgKExvd2VzdCknKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2Uuc2V0SGVhZGVyKCdYLU1TTWFpbC1Qcmlvcml0eScsICdMb3cnKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2Uuc2V0SGVhZGVyKCdJbXBvcnRhbmNlJywgJ0xvdycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGRvIG5vdCBhZGQgYW55dGhpbmcsIHNpbmNlIGFsbCBtZXNzYWdlcyBhcmUgJ05vcm1hbCcgYnkgZGVmYXVsdFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0TGlzdEhlYWRlcnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5tZXNzYWdlIHx8ICF0aGlzLmRhdGEubGlzdCB8fCB0eXBlb2YgdGhpcy5kYXRhLmxpc3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIG9wdGlvbmFsIExpc3QtKiBoZWFkZXJzXG4gICAgICAgIGlmICh0aGlzLmRhdGEubGlzdCAmJiB0eXBlb2YgdGhpcy5kYXRhLmxpc3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRMaXN0SGVhZGVycyh0aGlzLmRhdGEubGlzdCkuZm9yRWFjaChsaXN0SGVhZGVyID0+IHtcbiAgICAgICAgICAgICAgICBsaXN0SGVhZGVyLnZhbHVlLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UuYWRkSGVhZGVyKGxpc3RIZWFkZXIua2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRMaXN0SGVhZGVycyhsaXN0RGF0YSkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgYW4gdXJsIGxvb2tzIGxpa2UgPHByb3RvY29sOnVybD5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGxpc3REYXRhKS5tYXAoa2V5ID0+ICh7XG4gICAgICAgICAgICBrZXk6ICdsaXN0LScgKyBrZXkudG9Mb3dlckNhc2UoKS50cmltKCksXG4gICAgICAgICAgICB2YWx1ZTogW10uY29uY2F0KGxpc3REYXRhW2tleV0gfHwgW10pLm1hcCh2YWx1ZSA9PiAoe1xuICAgICAgICAgICAgICAgIHByZXBhcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZvbGRMaW5lczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh2YWx1ZSB8fCBbXSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLnVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKS50cmltKCkgPT09ICdpZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGlzdC1JRDogXCJjb21tZW50XCIgPGRvbWFpbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1lbnQgPSB2YWx1ZS5jb21tZW50IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWltZUZ1bmNzLmlzUGxhaW5UZXh0KGNvbW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gJ1wiJyArIGNvbW1lbnQgKyAnXCInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IG1pbWVGdW5jcy5lbmNvZGVXb3JkKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZS5jb21tZW50ID8gY29tbWVudCArICcgJyA6ICcnKSArIHRoaXMuX2Zvcm1hdExpc3RVcmwodmFsdWUudXJsKS5yZXBsYWNlKC9ePFteOl0rXFwveywyfS8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMaXN0LSo6IDxodHRwOi8vZG9tYWluPiAoY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29tbWVudCA9IHZhbHVlLmNvbW1lbnQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtaW1lRnVuY3MuaXNQbGFpblRleHQoY29tbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IG1pbWVGdW5jcy5lbmNvZGVXb3JkKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXRMaXN0VXJsKHZhbHVlLnVybCkgKyAodmFsdWUuY29tbWVudCA/ICcgKCcgKyBjb21tZW50ICsgJyknIDogJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIodmFsdWUgPT4gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIF9mb3JtYXRMaXN0VXJsKHVybCkge1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvW1xcczxdK3xbXFxzPl0rL2csICcnKTtcbiAgICAgICAgaWYgKC9eKGh0dHBzP3xtYWlsdG98ZnRwKTovLnRlc3QodXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuICc8JyArIHVybCArICc+JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoL15bXkBdK0BbXkBdKyQvLnRlc3QodXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuICc8bWFpbHRvOicgKyB1cmwgKyAnPic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJzxodHRwOi8vJyArIHVybCArICc+JztcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWFpbE1lc3NhZ2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/mailer/mail-message.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/mime-funcs/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/nodemailer/lib/mime-funcs/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-control-regex:0 */\n\n\n\nconst base64 = __webpack_require__(/*! ../base64 */ \"(rsc)/./node_modules/nodemailer/lib/base64/index.js\");\nconst qp = __webpack_require__(/*! ../qp */ \"(rsc)/./node_modules/nodemailer/lib/qp/index.js\");\nconst mimeTypes = __webpack_require__(/*! ./mime-types */ \"(rsc)/./node_modules/nodemailer/lib/mime-funcs/mime-types.js\");\n\nmodule.exports = {\n    /**\n     * Checks if a value is plaintext string (uses only printable 7bit chars)\n     *\n     * @param {String} value String to be tested\n     * @returns {Boolean} true if it is a plaintext string\n     */\n    isPlainText(value, isParam) {\n        const re = isParam ? /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\"\\u0080-\\uFFFF]/ : /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\u0080-\\uFFFF]/;\n        if (typeof value !== 'string' || re.test(value)) {\n            return false;\n        } else {\n            return true;\n        }\n    },\n\n    /**\n     * Checks if a multi line string containes lines longer than the selected value.\n     *\n     * Useful when detecting if a mail message needs any processing at all –\n     * if only plaintext characters are used and lines are short, then there is\n     * no need to encode the values in any way. If the value is plaintext but has\n     * longer lines then allowed, then use format=flowed\n     *\n     * @param {Number} lineLength Max line length to check for\n     * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars\n     */\n    hasLongerLines(str, lineLength) {\n        if (str.length > 128 * 1024) {\n            // do not test strings longer than 128kB\n            return true;\n        }\n        return new RegExp('^.{' + (lineLength + 1) + ',}', 'm').test(str);\n    },\n\n    /**\n     * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)\n     *\n     * @param {String|Buffer} data String to be encoded\n     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n     * @return {String} Single or several mime words joined together\n     */\n    encodeWord(data, mimeWordEncoding, maxLength) {\n        mimeWordEncoding = (mimeWordEncoding || 'Q').toString().toUpperCase().trim().charAt(0);\n        maxLength = maxLength || 0;\n\n        let encodedStr;\n        let toCharset = 'UTF-8';\n\n        if (maxLength && maxLength > 7 + toCharset.length) {\n            maxLength -= 7 + toCharset.length;\n        }\n\n        if (mimeWordEncoding === 'Q') {\n            // https://tools.ietf.org/html/rfc2047#section-5 rule (3)\n            encodedStr = qp.encode(data).replace(/[^a-z0-9!*+\\-/=]/gi, chr => {\n                let ord = chr.charCodeAt(0).toString(16).toUpperCase();\n                if (chr === ' ') {\n                    return '_';\n                } else {\n                    return '=' + (ord.length === 1 ? '0' + ord : ord);\n                }\n            });\n        } else if (mimeWordEncoding === 'B') {\n            encodedStr = typeof data === 'string' ? data : base64.encode(data);\n            maxLength = maxLength ? Math.max(3, ((maxLength - (maxLength % 4)) / 4) * 3) : 0;\n        }\n\n        if (maxLength && (mimeWordEncoding !== 'B' ? encodedStr : base64.encode(data)).length > maxLength) {\n            if (mimeWordEncoding === 'Q') {\n                encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n            } else {\n                // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences\n                let parts = [];\n                let lpart = '';\n                for (let i = 0, len = encodedStr.length; i < len; i++) {\n                    let chr = encodedStr.charAt(i);\n\n                    if (/[\\ud83c\\ud83d\\ud83e]/.test(chr) && i < len - 1) {\n                        // composite emoji byte, so add the next byte as well\n                        chr += encodedStr.charAt(++i);\n                    }\n\n                    // check if we can add this character to the existing string\n                    // without breaking byte length limit\n                    if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {\n                        lpart += chr;\n                    } else {\n                        // we hit the length limit, so push the existing string and start over\n                        parts.push(base64.encode(lpart));\n                        lpart = chr;\n                    }\n                }\n                if (lpart) {\n                    parts.push(base64.encode(lpart));\n                }\n\n                if (parts.length > 1) {\n                    encodedStr = parts.join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');\n                } else {\n                    encodedStr = parts.join('');\n                }\n            }\n        } else if (mimeWordEncoding === 'B') {\n            encodedStr = base64.encode(data);\n        }\n\n        return '=?' + toCharset + '?' + mimeWordEncoding + '?' + encodedStr + (encodedStr.substr(-2) === '?=' ? '' : '?=');\n    },\n\n    /**\n     * Finds word sequences with non ascii text and converts these to mime words\n     *\n     * @param {String} value String to be encoded\n     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed\n     * @param {Boolean} [encodeAll=false] If true and the value needs encoding then encodes entire string, not just the smallest match\n     * @return {String} String with possible mime words\n     */\n    encodeWords(value, mimeWordEncoding, maxLength, encodeAll) {\n        maxLength = maxLength || 0;\n\n        let encodedValue;\n\n        // find first word with a non-printable ascii or special symbol in it\n        let firstMatch = value.match(/(?:^|\\s)([^\\s]*[\"\\u0080-\\uFFFF])/);\n        if (!firstMatch) {\n            return value;\n        }\n\n        if (encodeAll) {\n            // if it is requested to encode everything or the string contains something that resebles encoded word, then encode everything\n\n            return this.encodeWord(value, mimeWordEncoding, maxLength);\n        }\n\n        // find the last word with a non-printable ascii in it\n        let lastMatch = value.match(/([\"\\u0080-\\uFFFF][^\\s]*)[^\"\\u0080-\\uFFFF]*$/);\n        if (!lastMatch) {\n            // should not happen\n            return value;\n        }\n\n        let startIndex =\n            firstMatch.index +\n            (\n                firstMatch[0].match(/[^\\s]/) || {\n                    index: 0\n                }\n            ).index;\n        let endIndex = lastMatch.index + (lastMatch[1] || '').length;\n\n        encodedValue =\n            (startIndex ? value.substr(0, startIndex) : '') +\n            this.encodeWord(value.substring(startIndex, endIndex), mimeWordEncoding || 'Q', maxLength) +\n            (endIndex < value.length ? value.substr(endIndex) : '');\n\n        return encodedValue;\n    },\n\n    /**\n     * Joins parsed header value together as 'value; param1=value1; param2=value2'\n     * PS: We are following RFC 822 for the list of special characters that we need to keep in quotes.\n     *      Refer: https://www.w3.org/Protocols/rfc1341/4_Content-Type.html\n     * @param {Object} structured Parsed header value\n     * @return {String} joined header value\n     */\n    buildHeaderValue(structured) {\n        let paramsArray = [];\n\n        Object.keys(structured.params || {}).forEach(param => {\n            // filename might include unicode characters so it is a special case\n            // other values probably do not\n            let value = structured.params[param];\n            if (!this.isPlainText(value, true) || value.length >= 75) {\n                this.buildHeaderParam(param, value, 50).forEach(encodedParam => {\n                    if (!/[\\s\"\\\\;:/=(),<>@[\\]?]|^[-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === '*') {\n                        paramsArray.push(encodedParam.key + '=' + encodedParam.value);\n                    } else {\n                        paramsArray.push(encodedParam.key + '=' + JSON.stringify(encodedParam.value));\n                    }\n                });\n            } else if (/[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(value)) {\n                paramsArray.push(param + '=' + JSON.stringify(value));\n            } else {\n                paramsArray.push(param + '=' + value);\n            }\n        });\n\n        return structured.value + (paramsArray.length ? '; ' + paramsArray.join('; ') : '');\n    },\n\n    /**\n     * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n     * Useful for splitting long parameter values.\n     *\n     * For example\n     *      title=\"unicode string\"\n     * becomes\n     *     title*0*=utf-8''unicode\n     *     title*1*=%20string\n     *\n     * @param {String|Buffer} data String to be encoded\n     * @param {Number} [maxLength=50] Max length for generated chunks\n     * @param {String} [fromCharset='UTF-8'] Source sharacter set\n     * @return {Array} A list of encoded keys and headers\n     */\n    buildHeaderParam(key, data, maxLength) {\n        let list = [];\n        let encodedStr = typeof data === 'string' ? data : (data || '').toString();\n        let encodedStrArr;\n        let chr, ord;\n        let line;\n        let startPos = 0;\n        let i, len;\n\n        maxLength = maxLength || 50;\n\n        // process ascii only text\n        if (this.isPlainText(data, true)) {\n            // check if conversion is even needed\n            if (encodedStr.length <= maxLength) {\n                return [\n                    {\n                        key,\n                        value: encodedStr\n                    }\n                ];\n            }\n\n            encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), str => {\n                list.push({\n                    line: str\n                });\n                return '';\n            });\n\n            if (encodedStr) {\n                list.push({\n                    line: encodedStr\n                });\n            }\n        } else {\n            if (/[\\uD800-\\uDBFF]/.test(encodedStr)) {\n                // string containts surrogate pairs, so normalize it to an array of bytes\n                encodedStrArr = [];\n                for (i = 0, len = encodedStr.length; i < len; i++) {\n                    chr = encodedStr.charAt(i);\n                    ord = chr.charCodeAt(0);\n                    if (ord >= 0xd800 && ord <= 0xdbff && i < len - 1) {\n                        chr += encodedStr.charAt(i + 1);\n                        encodedStrArr.push(chr);\n                        i++;\n                    } else {\n                        encodedStrArr.push(chr);\n                    }\n                }\n                encodedStr = encodedStrArr;\n            }\n\n            // first line includes the charset and language info and needs to be encoded\n            // even if it does not contain any unicode characters\n            line = 'utf-8\\x27\\x27';\n            let encoded = true;\n            startPos = 0;\n\n            // process text with unicode or special chars\n            for (i = 0, len = encodedStr.length; i < len; i++) {\n                chr = encodedStr[i];\n\n                if (encoded) {\n                    chr = this.safeEncodeURIComponent(chr);\n                } else {\n                    // try to urlencode current char\n                    chr = chr === ' ' ? chr : this.safeEncodeURIComponent(chr);\n                    // By default it is not required to encode a line, the need\n                    // only appears when the string contains unicode or special chars\n                    // in this case we start processing the line over and encode all chars\n                    if (chr !== encodedStr[i]) {\n                        // Check if it is even possible to add the encoded char to the line\n                        // If not, there is no reason to use this line, just push it to the list\n                        // and start a new line with the char that needs encoding\n                        if ((this.safeEncodeURIComponent(line) + chr).length >= maxLength) {\n                            list.push({\n                                line,\n                                encoded\n                            });\n                            line = '';\n                            startPos = i - 1;\n                        } else {\n                            encoded = true;\n                            i = startPos;\n                            line = '';\n                            continue;\n                        }\n                    }\n                }\n\n                // if the line is already too long, push it to the list and start a new one\n                if ((line + chr).length >= maxLength) {\n                    list.push({\n                        line,\n                        encoded\n                    });\n                    line = chr = encodedStr[i] === ' ' ? ' ' : this.safeEncodeURIComponent(encodedStr[i]);\n                    if (chr === encodedStr[i]) {\n                        encoded = false;\n                        startPos = i - 1;\n                    } else {\n                        encoded = true;\n                    }\n                } else {\n                    line += chr;\n                }\n            }\n\n            if (line) {\n                list.push({\n                    line,\n                    encoded\n                });\n            }\n        }\n\n        return list.map((item, i) => ({\n            // encoded lines: {name}*{part}*\n            // unencoded lines: {name}*{part}\n            // if any line needs to be encoded then the first line (part==0) is always encoded\n            key: key + '*' + i + (item.encoded ? '*' : ''),\n            value: item.line\n        }));\n    },\n\n    /**\n     * Parses a header value with key=value arguments into a structured\n     * object.\n     *\n     *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n     *   {\n     *     'value': 'text/plain',\n     *     'params': {\n     *       'charset': 'UTF-8'\n     *     }\n     *   }\n     *\n     * @param {String} str Header value\n     * @return {Object} Header value as a parsed structure\n     */\n    parseHeaderValue(str) {\n        let response = {\n            value: false,\n            params: {}\n        };\n        let key = false;\n        let value = '';\n        let type = 'value';\n        let quote = false;\n        let escaped = false;\n        let chr;\n\n        for (let i = 0, len = str.length; i < len; i++) {\n            chr = str.charAt(i);\n            if (type === 'key') {\n                if (chr === '=') {\n                    key = value.trim().toLowerCase();\n                    type = 'value';\n                    value = '';\n                    continue;\n                }\n                value += chr;\n            } else {\n                if (escaped) {\n                    value += chr;\n                } else if (chr === '\\\\') {\n                    escaped = true;\n                    continue;\n                } else if (quote && chr === quote) {\n                    quote = false;\n                } else if (!quote && chr === '\"') {\n                    quote = chr;\n                } else if (!quote && chr === ';') {\n                    if (key === false) {\n                        response.value = value.trim();\n                    } else {\n                        response.params[key] = value.trim();\n                    }\n                    type = 'key';\n                    value = '';\n                } else {\n                    value += chr;\n                }\n                escaped = false;\n            }\n        }\n\n        if (type === 'value') {\n            if (key === false) {\n                response.value = value.trim();\n            } else {\n                response.params[key] = value.trim();\n            }\n        } else if (value.trim()) {\n            response.params[value.trim().toLowerCase()] = '';\n        }\n\n        // handle parameter value continuations\n        // https://tools.ietf.org/html/rfc2231#section-3\n\n        // preprocess values\n        Object.keys(response.params).forEach(key => {\n            let actualKey, nr, match, value;\n            if ((match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/))) {\n                actualKey = key.substr(0, match.index);\n                nr = Number(match[2] || match[3]) || 0;\n\n                if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {\n                    response.params[actualKey] = {\n                        charset: false,\n                        values: []\n                    };\n                }\n\n                value = response.params[key];\n\n                if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n                    response.params[actualKey].charset = match[1] || 'iso-8859-1';\n                    value = match[2];\n                }\n\n                response.params[actualKey].values[nr] = value;\n\n                // remove the old reference\n                delete response.params[key];\n            }\n        });\n\n        // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n        Object.keys(response.params).forEach(key => {\n            let value;\n            if (response.params[key] && Array.isArray(response.params[key].values)) {\n                value = response.params[key].values.map(val => val || '').join('');\n\n                if (response.params[key].charset) {\n                    // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n                    response.params[key] =\n                        '=?' +\n                        response.params[key].charset +\n                        '?Q?' +\n                        value\n                            // fix invalidly encoded chars\n                            .replace(/[=?_\\s]/g, s => {\n                                let c = s.charCodeAt(0).toString(16);\n                                if (s === ' ') {\n                                    return '_';\n                                } else {\n                                    return '%' + (c.length < 2 ? '0' : '') + c;\n                                }\n                            })\n                            // change from urlencoding to percent encoding\n                            .replace(/%/g, '=') +\n                        '?=';\n                } else {\n                    response.params[key] = value;\n                }\n            }\n        });\n\n        return response;\n    },\n\n    /**\n     * Returns file extension for a content type string. If no suitable extensions\n     * are found, 'bin' is used as the default extension\n     *\n     * @param {String} mimeType Content type to be checked for\n     * @return {String} File extension\n     */\n    detectExtension: mimeType => mimeTypes.detectExtension(mimeType),\n\n    /**\n     * Returns content type for a file extension. If no suitable content types\n     * are found, 'application/octet-stream' is used as the default content type\n     *\n     * @param {String} extension Extension to be checked for\n     * @return {String} File extension\n     */\n    detectMimeType: extension => mimeTypes.detectMimeType(extension),\n\n    /**\n     * Folds long lines, useful for folding header lines (afterSpace=false) and\n     * flowed text (afterSpace=true)\n     *\n     * @param {String} str String to be folded\n     * @param {Number} [lineLength=76] Maximum length of a line\n     * @param {Boolean} afterSpace If true, leave a space in th end of a line\n     * @return {String} String with folded lines\n     */\n    foldLines(str, lineLength, afterSpace) {\n        str = (str || '').toString();\n        lineLength = lineLength || 76;\n\n        let pos = 0,\n            len = str.length,\n            result = '',\n            line,\n            match;\n\n        while (pos < len) {\n            line = str.substr(pos, lineLength);\n            if (line.length < lineLength) {\n                result += line;\n                break;\n            }\n            if ((match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/))) {\n                line = match[0];\n                result += line;\n                pos += line.length;\n                continue;\n            } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n                line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));\n            } else if ((match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/))) {\n                line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));\n            }\n\n            result += line;\n            pos += line.length;\n            if (pos < len) {\n                result += '\\r\\n';\n            }\n        }\n\n        return result;\n    },\n\n    /**\n     * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n     *\n     * @param {String} str Mime encoded string to be split up\n     * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n     * @return {Array} Split string\n     */\n    splitMimeEncodedString: (str, maxlen) => {\n        let curLine,\n            match,\n            chr,\n            done,\n            lines = [];\n\n        // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n        maxlen = Math.max(maxlen || 0, 12);\n\n        while (str.length) {\n            curLine = str.substr(0, maxlen);\n\n            // move incomplete escaped char back to main\n            if ((match = curLine.match(/[=][0-9A-F]?$/i))) {\n                curLine = curLine.substr(0, match.index);\n            }\n\n            done = false;\n            while (!done) {\n                done = true;\n                // check if not middle of a unicode char sequence\n                if ((match = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i))) {\n                    chr = parseInt(match[1], 16);\n                    // invalid sequence, move one char back anc recheck\n                    if (chr < 0xc2 && chr > 0x7f) {\n                        curLine = curLine.substr(0, curLine.length - 3);\n                        done = false;\n                    }\n                }\n            }\n\n            if (curLine.length) {\n                lines.push(curLine);\n            }\n            str = str.substr(curLine.length);\n        }\n\n        return lines;\n    },\n\n    encodeURICharComponent: chr => {\n        let res = '';\n        let ord = chr.charCodeAt(0).toString(16).toUpperCase();\n\n        if (ord.length % 2) {\n            ord = '0' + ord;\n        }\n\n        if (ord.length > 2) {\n            for (let i = 0, len = ord.length / 2; i < len; i++) {\n                res += '%' + ord.substr(i, 2);\n            }\n        } else {\n            res += '%' + ord;\n        }\n\n        return res;\n    },\n\n    safeEncodeURIComponent(str) {\n        str = (str || '').toString();\n\n        try {\n            // might throw if we try to encode invalid sequences, eg. partial emoji\n            str = encodeURIComponent(str);\n        } catch (E) {\n            // should never run\n            return str.replace(/[^\\x00-\\x1F *'()<>@,;:\\\\\"[\\]?=\\u007F-\\uFFFF]+/g, '');\n        }\n\n        // ensure chars that are not handled by encodeURICompent are converted as well\n        return str.replace(/[\\x00-\\x1F *'()<>@,;:\\\\\"[\\]?=\\u007F-\\uFFFF]/g, chr => this.encodeURICharComponent(chr));\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvbWltZS1mdW5jcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsc0VBQVc7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLDhEQUFPO0FBQzFCLGtCQUFrQixtQkFBTyxDQUFDLGtGQUFjOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxTQUFTO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxxREFBcUQsZUFBZTtBQUNwRTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVULDJEQUEyRCx3QkFBd0I7QUFDbkYsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRCxrQkFBa0I7QUFDNUU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsU0FBUztBQUMxRDs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLEtBQUssRUFBRSxLQUFLO0FBQzNDLGlDQUFpQyxLQUFLLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0IsNkJBQTZCO0FBQy9DO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsRUFBRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9taW1lLWZ1bmNzL2luZGV4LmpzP2M3MzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLWNvbnRyb2wtcmVnZXg6MCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJy4uL2Jhc2U2NCcpO1xuY29uc3QgcXAgPSByZXF1aXJlKCcuLi9xcCcpO1xuY29uc3QgbWltZVR5cGVzID0gcmVxdWlyZSgnLi9taW1lLXR5cGVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIHBsYWludGV4dCBzdHJpbmcgKHVzZXMgb25seSBwcmludGFibGUgN2JpdCBjaGFycylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBTdHJpbmcgdG8gYmUgdGVzdGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgaXQgaXMgYSBwbGFpbnRleHQgc3RyaW5nXG4gICAgICovXG4gICAgaXNQbGFpblRleHQodmFsdWUsIGlzUGFyYW0pIHtcbiAgICAgICAgY29uc3QgcmUgPSBpc1BhcmFtID8gL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlwiXFx1MDA4MC1cXHVGRkZGXS8gOiAvW1xceDAwLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx1MDA4MC1cXHVGRkZGXS87XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8IHJlLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBtdWx0aSBsaW5lIHN0cmluZyBjb250YWluZXMgbGluZXMgbG9uZ2VyIHRoYW4gdGhlIHNlbGVjdGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogVXNlZnVsIHdoZW4gZGV0ZWN0aW5nIGlmIGEgbWFpbCBtZXNzYWdlIG5lZWRzIGFueSBwcm9jZXNzaW5nIGF0IGFsbCDigJNcbiAgICAgKiBpZiBvbmx5IHBsYWludGV4dCBjaGFyYWN0ZXJzIGFyZSB1c2VkIGFuZCBsaW5lcyBhcmUgc2hvcnQsIHRoZW4gdGhlcmUgaXNcbiAgICAgKiBubyBuZWVkIHRvIGVuY29kZSB0aGUgdmFsdWVzIGluIGFueSB3YXkuIElmIHRoZSB2YWx1ZSBpcyBwbGFpbnRleHQgYnV0IGhhc1xuICAgICAqIGxvbmdlciBsaW5lcyB0aGVuIGFsbG93ZWQsIHRoZW4gdXNlIGZvcm1hdD1mbG93ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lTGVuZ3RoIE1heCBsaW5lIGxlbmd0aCB0byBjaGVjayBmb3JcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaW5lIGxvbmdlciB0aGFuIGxpbmVMZW5ndGggY2hhcnNcbiAgICAgKi9cbiAgICBoYXNMb25nZXJMaW5lcyhzdHIsIGxpbmVMZW5ndGgpIHtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAxMjggKiAxMDI0KSB7XG4gICAgICAgICAgICAvLyBkbyBub3QgdGVzdCBzdHJpbmdzIGxvbmdlciB0aGFuIDEyOGtCXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXi57JyArIChsaW5lTGVuZ3RoICsgMSkgKyAnLH0nLCAnbScpLnRlc3Qoc3RyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhIHN0cmluZyBvciBhbiBCdWZmZXIgdG8gYW4gVVRGLTggTUlNRSBXb3JkIChyZmMyMDQ3KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBkYXRhIFN0cmluZyB0byBiZSBlbmNvZGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWVXb3JkRW5jb2Rpbmc9J1EnIEVuY29kaW5nIGZvciB0aGUgbWltZSB3b3JkLCBlaXRoZXIgUSBvciBCXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhMZW5ndGg9MF0gSWYgc2V0LCBzcGxpdCBtaW1lIHdvcmRzIGludG8gc2V2ZXJhbCBjaHVua3MgaWYgbmVlZGVkXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTaW5nbGUgb3Igc2V2ZXJhbCBtaW1lIHdvcmRzIGpvaW5lZCB0b2dldGhlclxuICAgICAqL1xuICAgIGVuY29kZVdvcmQoZGF0YSwgbWltZVdvcmRFbmNvZGluZywgbWF4TGVuZ3RoKSB7XG4gICAgICAgIG1pbWVXb3JkRW5jb2RpbmcgPSAobWltZVdvcmRFbmNvZGluZyB8fCAnUScpLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKS50cmltKCkuY2hhckF0KDApO1xuICAgICAgICBtYXhMZW5ndGggPSBtYXhMZW5ndGggfHwgMDtcblxuICAgICAgICBsZXQgZW5jb2RlZFN0cjtcbiAgICAgICAgbGV0IHRvQ2hhcnNldCA9ICdVVEYtOCc7XG5cbiAgICAgICAgaWYgKG1heExlbmd0aCAmJiBtYXhMZW5ndGggPiA3ICsgdG9DaGFyc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgbWF4TGVuZ3RoIC09IDcgKyB0b0NoYXJzZXQubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbWVXb3JkRW5jb2RpbmcgPT09ICdRJykge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIwNDcjc2VjdGlvbi01IHJ1bGUgKDMpXG4gICAgICAgICAgICBlbmNvZGVkU3RyID0gcXAuZW5jb2RlKGRhdGEpLnJlcGxhY2UoL1teYS16MC05ISorXFwtLz1dL2dpLCBjaHIgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvcmQgPSBjaHIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hyID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdfJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJz0nICsgKG9yZC5sZW5ndGggPT09IDEgPyAnMCcgKyBvcmQgOiBvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbWVXb3JkRW5jb2RpbmcgPT09ICdCJykge1xuICAgICAgICAgICAgZW5jb2RlZFN0ciA9IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBiYXNlNjQuZW5jb2RlKGRhdGEpO1xuICAgICAgICAgICAgbWF4TGVuZ3RoID0gbWF4TGVuZ3RoID8gTWF0aC5tYXgoMywgKChtYXhMZW5ndGggLSAobWF4TGVuZ3RoICUgNCkpIC8gNCkgKiAzKSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4TGVuZ3RoICYmIChtaW1lV29yZEVuY29kaW5nICE9PSAnQicgPyBlbmNvZGVkU3RyIDogYmFzZTY0LmVuY29kZShkYXRhKSkubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWltZVdvcmRFbmNvZGluZyA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlZFN0ciA9IHRoaXMuc3BsaXRNaW1lRW5jb2RlZFN0cmluZyhlbmNvZGVkU3RyLCBtYXhMZW5ndGgpLmpvaW4oJz89ID0/JyArIHRvQ2hhcnNldCArICc/JyArIG1pbWVXb3JkRW5jb2RpbmcgKyAnPycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSRkMyMDQ3IDYuMyAoMikgc3RhdGVzIHRoYXQgZW5jb2RlZC13b3JkIG11c3QgaW5jbHVkZSBhbiBpbnRlZ3JhbCBudW1iZXIgb2YgY2hhcmFjdGVycywgc28gbm8gY2hvcHBpbmcgdW5pY29kZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgbHBhcnQgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZW5jb2RlZFN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hyID0gZW5jb2RlZFN0ci5jaGFyQXQoaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC9bXFx1ZDgzY1xcdWQ4M2RcXHVkODNlXS8udGVzdChjaHIpICYmIGkgPCBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb3NpdGUgZW1vamkgYnl0ZSwgc28gYWRkIHRoZSBuZXh0IGJ5dGUgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hyICs9IGVuY29kZWRTdHIuY2hhckF0KCsraSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gYWRkIHRoaXMgY2hhcmFjdGVyIHRvIHRoZSBleGlzdGluZyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aG91dCBicmVha2luZyBieXRlIGxlbmd0aCBsaW1pdFxuICAgICAgICAgICAgICAgICAgICBpZiAoQnVmZmVyLmJ5dGVMZW5ndGgobHBhcnQgKyBjaHIpIDw9IG1heExlbmd0aCB8fCBpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBscGFydCArPSBjaHI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoaXQgdGhlIGxlbmd0aCBsaW1pdCwgc28gcHVzaCB0aGUgZXhpc3Rpbmcgc3RyaW5nIGFuZCBzdGFydCBvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGJhc2U2NC5lbmNvZGUobHBhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxwYXJ0ID0gY2hyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChscGFydCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGJhc2U2NC5lbmNvZGUobHBhcnQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVkU3RyID0gcGFydHMuam9pbignPz0gPT8nICsgdG9DaGFyc2V0ICsgJz8nICsgbWltZVdvcmRFbmNvZGluZyArICc/Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFN0ciA9IHBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtaW1lV29yZEVuY29kaW5nID09PSAnQicpIHtcbiAgICAgICAgICAgIGVuY29kZWRTdHIgPSBiYXNlNjQuZW5jb2RlKGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICc9PycgKyB0b0NoYXJzZXQgKyAnPycgKyBtaW1lV29yZEVuY29kaW5nICsgJz8nICsgZW5jb2RlZFN0ciArIChlbmNvZGVkU3RyLnN1YnN0cigtMikgPT09ICc/PScgPyAnJyA6ICc/PScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB3b3JkIHNlcXVlbmNlcyB3aXRoIG5vbiBhc2NpaSB0ZXh0IGFuZCBjb252ZXJ0cyB0aGVzZSB0byBtaW1lIHdvcmRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgU3RyaW5nIHRvIGJlIGVuY29kZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZVdvcmRFbmNvZGluZz0nUScgRW5jb2RpbmcgZm9yIHRoZSBtaW1lIHdvcmQsIGVpdGhlciBRIG9yIEJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW21heExlbmd0aD0wXSBJZiBzZXQsIHNwbGl0IG1pbWUgd29yZHMgaW50byBzZXZlcmFsIGNodW5rcyBpZiBuZWVkZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtlbmNvZGVBbGw9ZmFsc2VdIElmIHRydWUgYW5kIHRoZSB2YWx1ZSBuZWVkcyBlbmNvZGluZyB0aGVuIGVuY29kZXMgZW50aXJlIHN0cmluZywgbm90IGp1c3QgdGhlIHNtYWxsZXN0IG1hdGNoXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgd2l0aCBwb3NzaWJsZSBtaW1lIHdvcmRzXG4gICAgICovXG4gICAgZW5jb2RlV29yZHModmFsdWUsIG1pbWVXb3JkRW5jb2RpbmcsIG1heExlbmd0aCwgZW5jb2RlQWxsKSB7XG4gICAgICAgIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCAwO1xuXG4gICAgICAgIGxldCBlbmNvZGVkVmFsdWU7XG5cbiAgICAgICAgLy8gZmluZCBmaXJzdCB3b3JkIHdpdGggYSBub24tcHJpbnRhYmxlIGFzY2lpIG9yIHNwZWNpYWwgc3ltYm9sIGluIGl0XG4gICAgICAgIGxldCBmaXJzdE1hdGNoID0gdmFsdWUubWF0Y2goLyg/Ol58XFxzKShbXlxcc10qW1wiXFx1MDA4MC1cXHVGRkZGXSkvKTtcbiAgICAgICAgaWYgKCFmaXJzdE1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5jb2RlQWxsKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyByZXF1ZXN0ZWQgdG8gZW5jb2RlIGV2ZXJ5dGhpbmcgb3IgdGhlIHN0cmluZyBjb250YWlucyBzb21ldGhpbmcgdGhhdCByZXNlYmxlcyBlbmNvZGVkIHdvcmQsIHRoZW4gZW5jb2RlIGV2ZXJ5dGhpbmdcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlV29yZCh2YWx1ZSwgbWltZVdvcmRFbmNvZGluZywgbWF4TGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgdGhlIGxhc3Qgd29yZCB3aXRoIGEgbm9uLXByaW50YWJsZSBhc2NpaSBpbiBpdFxuICAgICAgICBsZXQgbGFzdE1hdGNoID0gdmFsdWUubWF0Y2goLyhbXCJcXHUwMDgwLVxcdUZGRkZdW15cXHNdKilbXlwiXFx1MDA4MC1cXHVGRkZGXSokLyk7XG4gICAgICAgIGlmICghbGFzdE1hdGNoKSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgbm90IGhhcHBlblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPVxuICAgICAgICAgICAgZmlyc3RNYXRjaC5pbmRleCArXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgZmlyc3RNYXRjaFswXS5tYXRjaCgvW15cXHNdLykgfHwge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkuaW5kZXg7XG4gICAgICAgIGxldCBlbmRJbmRleCA9IGxhc3RNYXRjaC5pbmRleCArIChsYXN0TWF0Y2hbMV0gfHwgJycpLmxlbmd0aDtcblxuICAgICAgICBlbmNvZGVkVmFsdWUgPVxuICAgICAgICAgICAgKHN0YXJ0SW5kZXggPyB2YWx1ZS5zdWJzdHIoMCwgc3RhcnRJbmRleCkgOiAnJykgK1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVXb3JkKHZhbHVlLnN1YnN0cmluZyhzdGFydEluZGV4LCBlbmRJbmRleCksIG1pbWVXb3JkRW5jb2RpbmcgfHwgJ1EnLCBtYXhMZW5ndGgpICtcbiAgICAgICAgICAgIChlbmRJbmRleCA8IHZhbHVlLmxlbmd0aCA/IHZhbHVlLnN1YnN0cihlbmRJbmRleCkgOiAnJyk7XG5cbiAgICAgICAgcmV0dXJuIGVuY29kZWRWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSm9pbnMgcGFyc2VkIGhlYWRlciB2YWx1ZSB0b2dldGhlciBhcyAndmFsdWU7IHBhcmFtMT12YWx1ZTE7IHBhcmFtMj12YWx1ZTInXG4gICAgICogUFM6IFdlIGFyZSBmb2xsb3dpbmcgUkZDIDgyMiBmb3IgdGhlIGxpc3Qgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd2UgbmVlZCB0byBrZWVwIGluIHF1b3Rlcy5cbiAgICAgKiAgICAgIFJlZmVyOiBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzEzNDEvNF9Db250ZW50LVR5cGUuaHRtbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHJ1Y3R1cmVkIFBhcnNlZCBoZWFkZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGpvaW5lZCBoZWFkZXIgdmFsdWVcbiAgICAgKi9cbiAgICBidWlsZEhlYWRlclZhbHVlKHN0cnVjdHVyZWQpIHtcbiAgICAgICAgbGV0IHBhcmFtc0FycmF5ID0gW107XG5cbiAgICAgICAgT2JqZWN0LmtleXMoc3RydWN0dXJlZC5wYXJhbXMgfHwge30pLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgICAgICAgLy8gZmlsZW5hbWUgbWlnaHQgaW5jbHVkZSB1bmljb2RlIGNoYXJhY3RlcnMgc28gaXQgaXMgYSBzcGVjaWFsIGNhc2VcbiAgICAgICAgICAgIC8vIG90aGVyIHZhbHVlcyBwcm9iYWJseSBkbyBub3RcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHN0cnVjdHVyZWQucGFyYW1zW3BhcmFtXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1BsYWluVGV4dCh2YWx1ZSwgdHJ1ZSkgfHwgdmFsdWUubGVuZ3RoID49IDc1KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZEhlYWRlclBhcmFtKHBhcmFtLCB2YWx1ZSwgNTApLmZvckVhY2goZW5jb2RlZFBhcmFtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEvW1xcc1wiXFxcXDs6Lz0oKSw8PkBbXFxdP118XlstJ118JyQvLnRlc3QoZW5jb2RlZFBhcmFtLnZhbHVlKSB8fCBlbmNvZGVkUGFyYW0ua2V5LnN1YnN0cigtMSkgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zQXJyYXkucHVzaChlbmNvZGVkUGFyYW0ua2V5ICsgJz0nICsgZW5jb2RlZFBhcmFtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc0FycmF5LnB1c2goZW5jb2RlZFBhcmFtLmtleSArICc9JyArIEpTT04uc3RyaW5naWZ5KGVuY29kZWRQYXJhbS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9bXFxzJ1wiXFxcXDs6Lz0oKSw8PkBbXFxdP118Xi0vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zQXJyYXkucHVzaChwYXJhbSArICc9JyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtc0FycmF5LnB1c2gocGFyYW0gKyAnPScgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkLnZhbHVlICsgKHBhcmFtc0FycmF5Lmxlbmd0aCA/ICc7ICcgKyBwYXJhbXNBcnJheS5qb2luKCc7ICcpIDogJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGEgc3RyaW5nIG9yIGFuIEJ1ZmZlciB0byBhbiBVVEYtOCBQYXJhbWV0ZXIgVmFsdWUgQ29udGludWF0aW9uIGVuY29kaW5nIChyZmMyMjMxKVxuICAgICAqIFVzZWZ1bCBmb3Igc3BsaXR0aW5nIGxvbmcgcGFyYW1ldGVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlXG4gICAgICogICAgICB0aXRsZT1cInVuaWNvZGUgc3RyaW5nXCJcbiAgICAgKiBiZWNvbWVzXG4gICAgICogICAgIHRpdGxlKjAqPXV0Zi04Jyd1bmljb2RlXG4gICAgICogICAgIHRpdGxlKjEqPSUyMHN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBkYXRhIFN0cmluZyB0byBiZSBlbmNvZGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhMZW5ndGg9NTBdIE1heCBsZW5ndGggZm9yIGdlbmVyYXRlZCBjaHVua3NcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2Zyb21DaGFyc2V0PSdVVEYtOCddIFNvdXJjZSBzaGFyYWN0ZXIgc2V0XG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbGlzdCBvZiBlbmNvZGVkIGtleXMgYW5kIGhlYWRlcnNcbiAgICAgKi9cbiAgICBidWlsZEhlYWRlclBhcmFtKGtleSwgZGF0YSwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaXN0ID0gW107XG4gICAgICAgIGxldCBlbmNvZGVkU3RyID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gZGF0YSA6IChkYXRhIHx8ICcnKS50b1N0cmluZygpO1xuICAgICAgICBsZXQgZW5jb2RlZFN0ckFycjtcbiAgICAgICAgbGV0IGNociwgb3JkO1xuICAgICAgICBsZXQgbGluZTtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gMDtcbiAgICAgICAgbGV0IGksIGxlbjtcblxuICAgICAgICBtYXhMZW5ndGggPSBtYXhMZW5ndGggfHwgNTA7XG5cbiAgICAgICAgLy8gcHJvY2VzcyBhc2NpaSBvbmx5IHRleHRcbiAgICAgICAgaWYgKHRoaXMuaXNQbGFpblRleHQoZGF0YSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGNvbnZlcnNpb24gaXMgZXZlbiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChlbmNvZGVkU3RyLmxlbmd0aCA8PSBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZW5jb2RlZFN0clxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW5jb2RlZFN0ciA9IGVuY29kZWRTdHIucmVwbGFjZShuZXcgUmVnRXhwKCcueycgKyBtYXhMZW5ndGggKyAnfScsICdnJyksIHN0ciA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogc3RyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChlbmNvZGVkU3RyKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogZW5jb2RlZFN0clxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKC9bXFx1RDgwMC1cXHVEQkZGXS8udGVzdChlbmNvZGVkU3RyKSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cmluZyBjb250YWludHMgc3Vycm9nYXRlIHBhaXJzLCBzbyBub3JtYWxpemUgaXQgdG8gYW4gYXJyYXkgb2YgYnl0ZXNcbiAgICAgICAgICAgICAgICBlbmNvZGVkU3RyQXJyID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZW5jb2RlZFN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjaHIgPSBlbmNvZGVkU3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgb3JkID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmQgPj0gMHhkODAwICYmIG9yZCA8PSAweGRiZmYgJiYgaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNociArPSBlbmNvZGVkU3RyLmNoYXJBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkU3RyQXJyLnB1c2goY2hyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWRTdHJBcnIucHVzaChjaHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuY29kZWRTdHIgPSBlbmNvZGVkU3RyQXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaXJzdCBsaW5lIGluY2x1ZGVzIHRoZSBjaGFyc2V0IGFuZCBsYW5ndWFnZSBpbmZvIGFuZCBuZWVkcyB0byBiZSBlbmNvZGVkXG4gICAgICAgICAgICAvLyBldmVuIGlmIGl0IGRvZXMgbm90IGNvbnRhaW4gYW55IHVuaWNvZGUgY2hhcmFjdGVyc1xuICAgICAgICAgICAgbGluZSA9ICd1dGYtOFxceDI3XFx4MjcnO1xuICAgICAgICAgICAgbGV0IGVuY29kZWQgPSB0cnVlO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSAwO1xuXG4gICAgICAgICAgICAvLyBwcm9jZXNzIHRleHQgd2l0aCB1bmljb2RlIG9yIHNwZWNpYWwgY2hhcnNcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGVuY29kZWRTdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBlbmNvZGVkU3RyW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hyID0gdGhpcy5zYWZlRW5jb2RlVVJJQ29tcG9uZW50KGNocik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHVybGVuY29kZSBjdXJyZW50IGNoYXJcbiAgICAgICAgICAgICAgICAgICAgY2hyID0gY2hyID09PSAnICcgPyBjaHIgOiB0aGlzLnNhZmVFbmNvZGVVUklDb21wb25lbnQoY2hyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCBpdCBpcyBub3QgcmVxdWlyZWQgdG8gZW5jb2RlIGEgbGluZSwgdGhlIG5lZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBhcHBlYXJzIHdoZW4gdGhlIHN0cmluZyBjb250YWlucyB1bmljb2RlIG9yIHNwZWNpYWwgY2hhcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIGxpbmUgb3ZlciBhbmQgZW5jb2RlIGFsbCBjaGFyc1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hyICE9PSBlbmNvZGVkU3RyW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdCBpcyBldmVuIHBvc3NpYmxlIHRvIGFkZCB0aGUgZW5jb2RlZCBjaGFyIHRvIHRoZSBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QsIHRoZXJlIGlzIG5vIHJlYXNvbiB0byB1c2UgdGhpcyBsaW5lLCBqdXN0IHB1c2ggaXQgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBzdGFydCBhIG5ldyBsaW5lIHdpdGggdGhlIGNoYXIgdGhhdCBuZWVkcyBlbmNvZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLnNhZmVFbmNvZGVVUklDb21wb25lbnQobGluZSkgKyBjaHIpLmxlbmd0aCA+PSBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBzdGFydFBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGluZSBpcyBhbHJlYWR5IHRvbyBsb25nLCBwdXNoIGl0IHRvIHRoZSBsaXN0IGFuZCBzdGFydCBhIG5ldyBvbmVcbiAgICAgICAgICAgICAgICBpZiAoKGxpbmUgKyBjaHIpLmxlbmd0aCA+PSBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gY2hyID0gZW5jb2RlZFN0cltpXSA9PT0gJyAnID8gJyAnIDogdGhpcy5zYWZlRW5jb2RlVVJJQ29tcG9uZW50KGVuY29kZWRTdHJbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hyID09PSBlbmNvZGVkU3RyW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFBvcyA9IGkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaW5lICs9IGNocjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3QubWFwKChpdGVtLCBpKSA9PiAoe1xuICAgICAgICAgICAgLy8gZW5jb2RlZCBsaW5lczoge25hbWV9KntwYXJ0fSpcbiAgICAgICAgICAgIC8vIHVuZW5jb2RlZCBsaW5lczoge25hbWV9KntwYXJ0fVxuICAgICAgICAgICAgLy8gaWYgYW55IGxpbmUgbmVlZHMgdG8gYmUgZW5jb2RlZCB0aGVuIHRoZSBmaXJzdCBsaW5lIChwYXJ0PT0wKSBpcyBhbHdheXMgZW5jb2RlZFxuICAgICAgICAgICAga2V5OiBrZXkgKyAnKicgKyBpICsgKGl0ZW0uZW5jb2RlZCA/ICcqJyA6ICcnKSxcbiAgICAgICAgICAgIHZhbHVlOiBpdGVtLmxpbmVcbiAgICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBoZWFkZXIgdmFsdWUgd2l0aCBrZXk9dmFsdWUgYXJndW1lbnRzIGludG8gYSBzdHJ1Y3R1cmVkXG4gICAgICogb2JqZWN0LlxuICAgICAqXG4gICAgICogICBwYXJzZUhlYWRlclZhbHVlKCdjb250ZW50LXR5cGU6IHRleHQvcGxhaW47IENIQVJTRVQ9J1VURi04JycpIC0+XG4gICAgICogICB7XG4gICAgICogICAgICd2YWx1ZSc6ICd0ZXh0L3BsYWluJyxcbiAgICAgKiAgICAgJ3BhcmFtcyc6IHtcbiAgICAgKiAgICAgICAnY2hhcnNldCc6ICdVVEYtOCdcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBIZWFkZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEhlYWRlciB2YWx1ZSBhcyBhIHBhcnNlZCBzdHJ1Y3R1cmVcbiAgICAgKi9cbiAgICBwYXJzZUhlYWRlclZhbHVlKHN0cikge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICBwYXJhbXM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBrZXkgPSBmYWxzZTtcbiAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgIGxldCB0eXBlID0gJ3ZhbHVlJztcbiAgICAgICAgbGV0IHF1b3RlID0gZmFsc2U7XG4gICAgICAgIGxldCBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBjaHI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hyID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAna2V5Jykge1xuICAgICAgICAgICAgICAgIGlmIChjaHIgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSB2YWx1ZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICd2YWx1ZSc7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBjaHI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGNocjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHF1b3RlICYmIGNociA9PT0gcXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFxdW90ZSAmJiBjaHIgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSBjaHI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcXVvdGUgJiYgY2hyID09PSAnOycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGFyYW1zW2tleV0gPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdrZXknO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGNocjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UudmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnBhcmFtc1trZXldID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLnRyaW0oKSkge1xuICAgICAgICAgICAgcmVzcG9uc2UucGFyYW1zW3ZhbHVlLnRyaW0oKS50b0xvd2VyQ2FzZSgpXSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHBhcmFtZXRlciB2YWx1ZSBjb250aW51YXRpb25zXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMjMxI3NlY3Rpb24tM1xuXG4gICAgICAgIC8vIHByZXByb2Nlc3MgdmFsdWVzXG4gICAgICAgIE9iamVjdC5rZXlzKHJlc3BvbnNlLnBhcmFtcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IGFjdHVhbEtleSwgbnIsIG1hdGNoLCB2YWx1ZTtcbiAgICAgICAgICAgIGlmICgobWF0Y2ggPSBrZXkubWF0Y2goLyhcXCooXFxkKyl8XFwqKFxcZCspXFwqfFxcKikkLykpKSB7XG4gICAgICAgICAgICAgICAgYWN0dWFsS2V5ID0ga2V5LnN1YnN0cigwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICAgICAgbnIgPSBOdW1iZXIobWF0Y2hbMl0gfHwgbWF0Y2hbM10pIHx8IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLnBhcmFtc1thY3R1YWxLZXldIHx8IHR5cGVvZiByZXNwb25zZS5wYXJhbXNbYWN0dWFsS2V5XSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGFyYW1zW2FjdHVhbEtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyc2V0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogW11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3BvbnNlLnBhcmFtc1trZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5yID09PSAwICYmIG1hdGNoWzBdLnN1YnN0cigtMSkgPT09ICcqJyAmJiAobWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXihbXiddKiknW14nXSonKC4qKSQvKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGFyYW1zW2FjdHVhbEtleV0uY2hhcnNldCA9IG1hdGNoWzFdIHx8ICdpc28tODg1OS0xJztcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNwb25zZS5wYXJhbXNbYWN0dWFsS2V5XS52YWx1ZXNbbnJdID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG9sZCByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzcG9uc2UucGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNvbmNhdGVuYXRlIHNwbGl0IHJmYzIyMzEgc3RyaW5ncyBhbmQgY29udmVydCBlbmNvZGVkIHN0cmluZ3MgdG8gbWltZSBlbmNvZGVkIHdvcmRzXG4gICAgICAgIE9iamVjdC5rZXlzKHJlc3BvbnNlLnBhcmFtcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnBhcmFtc1trZXldICYmIEFycmF5LmlzQXJyYXkocmVzcG9uc2UucGFyYW1zW2tleV0udmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzcG9uc2UucGFyYW1zW2tleV0udmFsdWVzLm1hcCh2YWwgPT4gdmFsIHx8ICcnKS5qb2luKCcnKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5wYXJhbXNba2V5XS5jaGFyc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgXCIlQUJcIiB0byBcIj0/Y2hhcnNldD9RPz1BQj89XCJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGFyYW1zW2tleV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgJz0/JyArXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5wYXJhbXNba2V5XS5jaGFyc2V0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc/UT8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4IGludmFsaWRseSBlbmNvZGVkIGNoYXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1s9P19cXHNdL2csIHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYyA9IHMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnXyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyUnICsgKGMubGVuZ3RoIDwgMiA/ICcwJyA6ICcnKSArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBmcm9tIHVybGVuY29kaW5nIHRvIHBlcmNlbnQgZW5jb2RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJS9nLCAnPScpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc/PSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaWxlIGV4dGVuc2lvbiBmb3IgYSBjb250ZW50IHR5cGUgc3RyaW5nLiBJZiBubyBzdWl0YWJsZSBleHRlbnNpb25zXG4gICAgICogYXJlIGZvdW5kLCAnYmluJyBpcyB1c2VkIGFzIHRoZSBkZWZhdWx0IGV4dGVuc2lvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIENvbnRlbnQgdHlwZSB0byBiZSBjaGVja2VkIGZvclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gRmlsZSBleHRlbnNpb25cbiAgICAgKi9cbiAgICBkZXRlY3RFeHRlbnNpb246IG1pbWVUeXBlID0+IG1pbWVUeXBlcy5kZXRlY3RFeHRlbnNpb24obWltZVR5cGUpLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250ZW50IHR5cGUgZm9yIGEgZmlsZSBleHRlbnNpb24uIElmIG5vIHN1aXRhYmxlIGNvbnRlbnQgdHlwZXNcbiAgICAgKiBhcmUgZm91bmQsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIGlzIHVzZWQgYXMgdGhlIGRlZmF1bHQgY29udGVudCB0eXBlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXh0ZW5zaW9uIEV4dGVuc2lvbiB0byBiZSBjaGVja2VkIGZvclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gRmlsZSBleHRlbnNpb25cbiAgICAgKi9cbiAgICBkZXRlY3RNaW1lVHlwZTogZXh0ZW5zaW9uID0+IG1pbWVUeXBlcy5kZXRlY3RNaW1lVHlwZShleHRlbnNpb24pLFxuXG4gICAgLyoqXG4gICAgICogRm9sZHMgbG9uZyBsaW5lcywgdXNlZnVsIGZvciBmb2xkaW5nIGhlYWRlciBsaW5lcyAoYWZ0ZXJTcGFjZT1mYWxzZSkgYW5kXG4gICAgICogZmxvd2VkIHRleHQgKGFmdGVyU3BhY2U9dHJ1ZSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIGJlIGZvbGRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGluZUxlbmd0aD03Nl0gTWF4aW11bSBsZW5ndGggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhZnRlclNwYWNlIElmIHRydWUsIGxlYXZlIGEgc3BhY2UgaW4gdGggZW5kIG9mIGEgbGluZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHdpdGggZm9sZGVkIGxpbmVzXG4gICAgICovXG4gICAgZm9sZExpbmVzKHN0ciwgbGluZUxlbmd0aCwgYWZ0ZXJTcGFjZSkge1xuICAgICAgICBzdHIgPSAoc3RyIHx8ICcnKS50b1N0cmluZygpO1xuICAgICAgICBsaW5lTGVuZ3RoID0gbGluZUxlbmd0aCB8fCA3NjtcblxuICAgICAgICBsZXQgcG9zID0gMCxcbiAgICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSAnJyxcbiAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICBtYXRjaDtcblxuICAgICAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgICAgICBsaW5lID0gc3RyLnN1YnN0cihwb3MsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgbGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtYXRjaCA9IGxpbmUubWF0Y2goL15bXlxcblxccl0qKFxccj9cXG58XFxyKS8pKSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBtYXRjaFswXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGxpbmUubWF0Y2goLyhcXHMrKVteXFxzXSokLykpICYmIG1hdGNoWzBdLmxlbmd0aCAtIChhZnRlclNwYWNlID8gKG1hdGNoWzFdIHx8ICcnKS5sZW5ndGggOiAwKSA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gKG1hdGNoWzBdLmxlbmd0aCAtIChhZnRlclNwYWNlID8gKG1hdGNoWzFdIHx8ICcnKS5sZW5ndGggOiAwKSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBzdHIuc3Vic3RyKHBvcyArIGxpbmUubGVuZ3RoKS5tYXRjaCgvXlteXFxzXSsoXFxzKikvKSkpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZSArIG1hdGNoWzBdLnN1YnN0cigwLCBtYXRjaFswXS5sZW5ndGggLSAoIWFmdGVyU3BhY2UgPyAobWF0Y2hbMV0gfHwgJycpLmxlbmd0aCA6IDApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmU7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHJcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGEgbWltZSBlbmNvZGVkIHN0cmluZy4gTmVlZGVkIGZvciBkaXZpZGluZyBtaW1lIHdvcmRzIGludG8gc21hbGxlciBjaHVua3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgTWltZSBlbmNvZGVkIHN0cmluZyB0byBiZSBzcGxpdCB1cFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhsZW4gTWF4aW11bSBsZW5ndGggb2YgY2hhcmFjdGVycyBmb3Igb25lIHBhcnQgKG1pbmltdW0gMTIpXG4gICAgICogQHJldHVybiB7QXJyYXl9IFNwbGl0IHN0cmluZ1xuICAgICAqL1xuICAgIHNwbGl0TWltZUVuY29kZWRTdHJpbmc6IChzdHIsIG1heGxlbikgPT4ge1xuICAgICAgICBsZXQgY3VyTGluZSxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgY2hyLFxuICAgICAgICAgICAgZG9uZSxcbiAgICAgICAgICAgIGxpbmVzID0gW107XG5cbiAgICAgICAgLy8gcmVxdWlyZSBhdCBsZWFzdCAxMiBzeW1ib2xzIHRvIGZpdCBwb3NzaWJsZSA0IG9jdGV0IFVURi04IHNlcXVlbmNlc1xuICAgICAgICBtYXhsZW4gPSBNYXRoLm1heChtYXhsZW4gfHwgMCwgMTIpO1xuXG4gICAgICAgIHdoaWxlIChzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJMaW5lID0gc3RyLnN1YnN0cigwLCBtYXhsZW4pO1xuXG4gICAgICAgICAgICAvLyBtb3ZlIGluY29tcGxldGUgZXNjYXBlZCBjaGFyIGJhY2sgdG8gbWFpblxuICAgICAgICAgICAgaWYgKChtYXRjaCA9IGN1ckxpbmUubWF0Y2goL1s9XVswLTlBLUZdPyQvaSkpKSB7XG4gICAgICAgICAgICAgICAgY3VyTGluZSA9IGN1ckxpbmUuc3Vic3RyKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbm90IG1pZGRsZSBvZiBhIHVuaWNvZGUgY2hhciBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgIGlmICgobWF0Y2ggPSBzdHIuc3Vic3RyKGN1ckxpbmUubGVuZ3RoKS5tYXRjaCgvXls9XShbMC05QS1GXXsyfSkvaSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNociA9IHBhcnNlSW50KG1hdGNoWzFdLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGludmFsaWQgc2VxdWVuY2UsIG1vdmUgb25lIGNoYXIgYmFjayBhbmMgcmVjaGVja1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hyIDwgMHhjMiAmJiBjaHIgPiAweDdmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJMaW5lID0gY3VyTGluZS5zdWJzdHIoMCwgY3VyTGluZS5sZW5ndGggLSAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1ckxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChjdXJMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoY3VyTGluZS5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH0sXG5cbiAgICBlbmNvZGVVUklDaGFyQ29tcG9uZW50OiBjaHIgPT4ge1xuICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgIGxldCBvcmQgPSBjaHIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblxuICAgICAgICBpZiAob3JkLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIG9yZCA9ICcwJyArIG9yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcmQubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9yZC5sZW5ndGggLyAyOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gJyUnICsgb3JkLnN1YnN0cihpLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyArPSAnJScgKyBvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICBzYWZlRW5jb2RlVVJJQ29tcG9uZW50KHN0cikge1xuICAgICAgICBzdHIgPSAoc3RyIHx8ICcnKS50b1N0cmluZygpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBtaWdodCB0aHJvdyBpZiB3ZSB0cnkgdG8gZW5jb2RlIGludmFsaWQgc2VxdWVuY2VzLCBlZy4gcGFydGlhbCBlbW9qaVxuICAgICAgICAgICAgc3RyID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG4gICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCBuZXZlciBydW5cbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW15cXHgwMC1cXHgxRiAqJygpPD5ALDs6XFxcXFwiW1xcXT89XFx1MDA3Ri1cXHVGRkZGXSsvZywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIGNoYXJzIHRoYXQgYXJlIG5vdCBoYW5kbGVkIGJ5IGVuY29kZVVSSUNvbXBlbnQgYXJlIGNvbnZlcnRlZCBhcyB3ZWxsXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xceDAwLVxceDFGIConKCk8PkAsOzpcXFxcXCJbXFxdPz1cXHUwMDdGLVxcdUZGRkZdL2csIGNociA9PiB0aGlzLmVuY29kZVVSSUNoYXJDb21wb25lbnQoY2hyKSk7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/mime-funcs/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/mime-funcs/mime-types.js":
/*!**************************************************************!*\
  !*** ./node_modules/nodemailer/lib/mime-funcs/mime-types.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint quote-props: 0 */\n\n\n\nconst path = __webpack_require__(/*! path */ \"path\");\n\nconst defaultMimeType = 'application/octet-stream';\nconst defaultExtension = 'bin';\n\nconst mimeTypes = new Map([\n    ['application/acad', 'dwg'],\n    ['application/applixware', 'aw'],\n    ['application/arj', 'arj'],\n    ['application/atom+xml', 'xml'],\n    ['application/atomcat+xml', 'atomcat'],\n    ['application/atomsvc+xml', 'atomsvc'],\n    ['application/base64', ['mm', 'mme']],\n    ['application/binhex', 'hqx'],\n    ['application/binhex4', 'hqx'],\n    ['application/book', ['book', 'boo']],\n    ['application/ccxml+xml,', 'ccxml'],\n    ['application/cdf', 'cdf'],\n    ['application/cdmi-capability', 'cdmia'],\n    ['application/cdmi-container', 'cdmic'],\n    ['application/cdmi-domain', 'cdmid'],\n    ['application/cdmi-object', 'cdmio'],\n    ['application/cdmi-queue', 'cdmiq'],\n    ['application/clariscad', 'ccad'],\n    ['application/commonground', 'dp'],\n    ['application/cu-seeme', 'cu'],\n    ['application/davmount+xml', 'davmount'],\n    ['application/drafting', 'drw'],\n    ['application/dsptype', 'tsp'],\n    ['application/dssc+der', 'dssc'],\n    ['application/dssc+xml', 'xdssc'],\n    ['application/dxf', 'dxf'],\n    ['application/ecmascript', ['js', 'es']],\n    ['application/emma+xml', 'emma'],\n    ['application/envoy', 'evy'],\n    ['application/epub+zip', 'epub'],\n    ['application/excel', ['xls', 'xl', 'xla', 'xlb', 'xlc', 'xld', 'xlk', 'xll', 'xlm', 'xlt', 'xlv', 'xlw']],\n    ['application/exi', 'exi'],\n    ['application/font-tdpfr', 'pfr'],\n    ['application/fractals', 'fif'],\n    ['application/freeloader', 'frl'],\n    ['application/futuresplash', 'spl'],\n    ['application/gnutar', 'tgz'],\n    ['application/groupwise', 'vew'],\n    ['application/hlp', 'hlp'],\n    ['application/hta', 'hta'],\n    ['application/hyperstudio', 'stk'],\n    ['application/i-deas', 'unv'],\n    ['application/iges', ['iges', 'igs']],\n    ['application/inf', 'inf'],\n    ['application/internet-property-stream', 'acx'],\n    ['application/ipfix', 'ipfix'],\n    ['application/java', 'class'],\n    ['application/java-archive', 'jar'],\n    ['application/java-byte-code', 'class'],\n    ['application/java-serialized-object', 'ser'],\n    ['application/java-vm', 'class'],\n    ['application/javascript', 'js'],\n    ['application/json', 'json'],\n    ['application/lha', 'lha'],\n    ['application/lzx', 'lzx'],\n    ['application/mac-binary', 'bin'],\n    ['application/mac-binhex', 'hqx'],\n    ['application/mac-binhex40', 'hqx'],\n    ['application/mac-compactpro', 'cpt'],\n    ['application/macbinary', 'bin'],\n    ['application/mads+xml', 'mads'],\n    ['application/marc', 'mrc'],\n    ['application/marcxml+xml', 'mrcx'],\n    ['application/mathematica', 'ma'],\n    ['application/mathml+xml', 'mathml'],\n    ['application/mbedlet', 'mbd'],\n    ['application/mbox', 'mbox'],\n    ['application/mcad', 'mcd'],\n    ['application/mediaservercontrol+xml', 'mscml'],\n    ['application/metalink4+xml', 'meta4'],\n    ['application/mets+xml', 'mets'],\n    ['application/mime', 'aps'],\n    ['application/mods+xml', 'mods'],\n    ['application/mp21', 'm21'],\n    ['application/mp4', 'mp4'],\n    ['application/mspowerpoint', ['ppt', 'pot', 'pps', 'ppz']],\n    ['application/msword', ['doc', 'dot', 'w6w', 'wiz', 'word']],\n    ['application/mswrite', 'wri'],\n    ['application/mxf', 'mxf'],\n    ['application/netmc', 'mcp'],\n    ['application/octet-stream', ['*']],\n    ['application/oda', 'oda'],\n    ['application/oebps-package+xml', 'opf'],\n    ['application/ogg', 'ogx'],\n    ['application/olescript', 'axs'],\n    ['application/onenote', 'onetoc'],\n    ['application/patch-ops-error+xml', 'xer'],\n    ['application/pdf', 'pdf'],\n    ['application/pgp-encrypted', 'asc'],\n    ['application/pgp-signature', 'pgp'],\n    ['application/pics-rules', 'prf'],\n    ['application/pkcs-12', 'p12'],\n    ['application/pkcs-crl', 'crl'],\n    ['application/pkcs10', 'p10'],\n    ['application/pkcs7-mime', ['p7c', 'p7m']],\n    ['application/pkcs7-signature', 'p7s'],\n    ['application/pkcs8', 'p8'],\n    ['application/pkix-attr-cert', 'ac'],\n    ['application/pkix-cert', ['cer', 'crt']],\n    ['application/pkix-crl', 'crl'],\n    ['application/pkix-pkipath', 'pkipath'],\n    ['application/pkixcmp', 'pki'],\n    ['application/plain', 'text'],\n    ['application/pls+xml', 'pls'],\n    ['application/postscript', ['ps', 'ai', 'eps']],\n    ['application/powerpoint', 'ppt'],\n    ['application/pro_eng', ['part', 'prt']],\n    ['application/prs.cww', 'cww'],\n    ['application/pskc+xml', 'pskcxml'],\n    ['application/rdf+xml', 'rdf'],\n    ['application/reginfo+xml', 'rif'],\n    ['application/relax-ng-compact-syntax', 'rnc'],\n    ['application/resource-lists+xml', 'rl'],\n    ['application/resource-lists-diff+xml', 'rld'],\n    ['application/ringing-tones', 'rng'],\n    ['application/rls-services+xml', 'rs'],\n    ['application/rsd+xml', 'rsd'],\n    ['application/rss+xml', 'xml'],\n    ['application/rtf', ['rtf', 'rtx']],\n    ['application/sbml+xml', 'sbml'],\n    ['application/scvp-cv-request', 'scq'],\n    ['application/scvp-cv-response', 'scs'],\n    ['application/scvp-vp-request', 'spq'],\n    ['application/scvp-vp-response', 'spp'],\n    ['application/sdp', 'sdp'],\n    ['application/sea', 'sea'],\n    ['application/set', 'set'],\n    ['application/set-payment-initiation', 'setpay'],\n    ['application/set-registration-initiation', 'setreg'],\n    ['application/shf+xml', 'shf'],\n    ['application/sla', 'stl'],\n    ['application/smil', ['smi', 'smil']],\n    ['application/smil+xml', 'smi'],\n    ['application/solids', 'sol'],\n    ['application/sounder', 'sdr'],\n    ['application/sparql-query', 'rq'],\n    ['application/sparql-results+xml', 'srx'],\n    ['application/srgs', 'gram'],\n    ['application/srgs+xml', 'grxml'],\n    ['application/sru+xml', 'sru'],\n    ['application/ssml+xml', 'ssml'],\n    ['application/step', ['step', 'stp']],\n    ['application/streamingmedia', 'ssm'],\n    ['application/tei+xml', 'tei'],\n    ['application/thraud+xml', 'tfi'],\n    ['application/timestamped-data', 'tsd'],\n    ['application/toolbook', 'tbk'],\n    ['application/vda', 'vda'],\n    ['application/vnd.3gpp.pic-bw-large', 'plb'],\n    ['application/vnd.3gpp.pic-bw-small', 'psb'],\n    ['application/vnd.3gpp.pic-bw-var', 'pvb'],\n    ['application/vnd.3gpp2.tcap', 'tcap'],\n    ['application/vnd.3m.post-it-notes', 'pwn'],\n    ['application/vnd.accpac.simply.aso', 'aso'],\n    ['application/vnd.accpac.simply.imp', 'imp'],\n    ['application/vnd.acucobol', 'acu'],\n    ['application/vnd.acucorp', 'atc'],\n    ['application/vnd.adobe.air-application-installer-package+zip', 'air'],\n    ['application/vnd.adobe.fxp', 'fxp'],\n    ['application/vnd.adobe.xdp+xml', 'xdp'],\n    ['application/vnd.adobe.xfdf', 'xfdf'],\n    ['application/vnd.ahead.space', 'ahead'],\n    ['application/vnd.airzip.filesecure.azf', 'azf'],\n    ['application/vnd.airzip.filesecure.azs', 'azs'],\n    ['application/vnd.amazon.ebook', 'azw'],\n    ['application/vnd.americandynamics.acc', 'acc'],\n    ['application/vnd.amiga.ami', 'ami'],\n    ['application/vnd.android.package-archive', 'apk'],\n    ['application/vnd.anser-web-certificate-issue-initiation', 'cii'],\n    ['application/vnd.anser-web-funds-transfer-initiation', 'fti'],\n    ['application/vnd.antix.game-component', 'atx'],\n    ['application/vnd.apple.installer+xml', 'mpkg'],\n    ['application/vnd.apple.mpegurl', 'm3u8'],\n    ['application/vnd.aristanetworks.swi', 'swi'],\n    ['application/vnd.audiograph', 'aep'],\n    ['application/vnd.blueice.multipass', 'mpm'],\n    ['application/vnd.bmi', 'bmi'],\n    ['application/vnd.businessobjects', 'rep'],\n    ['application/vnd.chemdraw+xml', 'cdxml'],\n    ['application/vnd.chipnuts.karaoke-mmd', 'mmd'],\n    ['application/vnd.cinderella', 'cdy'],\n    ['application/vnd.claymore', 'cla'],\n    ['application/vnd.cloanto.rp9', 'rp9'],\n    ['application/vnd.clonk.c4group', 'c4g'],\n    ['application/vnd.cluetrust.cartomobile-config', 'c11amc'],\n    ['application/vnd.cluetrust.cartomobile-config-pkg', 'c11amz'],\n    ['application/vnd.commonspace', 'csp'],\n    ['application/vnd.contact.cmsg', 'cdbcmsg'],\n    ['application/vnd.cosmocaller', 'cmc'],\n    ['application/vnd.crick.clicker', 'clkx'],\n    ['application/vnd.crick.clicker.keyboard', 'clkk'],\n    ['application/vnd.crick.clicker.palette', 'clkp'],\n    ['application/vnd.crick.clicker.template', 'clkt'],\n    ['application/vnd.crick.clicker.wordbank', 'clkw'],\n    ['application/vnd.criticaltools.wbs+xml', 'wbs'],\n    ['application/vnd.ctc-posml', 'pml'],\n    ['application/vnd.cups-ppd', 'ppd'],\n    ['application/vnd.curl.car', 'car'],\n    ['application/vnd.curl.pcurl', 'pcurl'],\n    ['application/vnd.data-vision.rdz', 'rdz'],\n    ['application/vnd.denovo.fcselayout-link', 'fe_launch'],\n    ['application/vnd.dna', 'dna'],\n    ['application/vnd.dolby.mlp', 'mlp'],\n    ['application/vnd.dpgraph', 'dpg'],\n    ['application/vnd.dreamfactory', 'dfac'],\n    ['application/vnd.dvb.ait', 'ait'],\n    ['application/vnd.dvb.service', 'svc'],\n    ['application/vnd.dynageo', 'geo'],\n    ['application/vnd.ecowin.chart', 'mag'],\n    ['application/vnd.enliven', 'nml'],\n    ['application/vnd.epson.esf', 'esf'],\n    ['application/vnd.epson.msf', 'msf'],\n    ['application/vnd.epson.quickanime', 'qam'],\n    ['application/vnd.epson.salt', 'slt'],\n    ['application/vnd.epson.ssf', 'ssf'],\n    ['application/vnd.eszigno3+xml', 'es3'],\n    ['application/vnd.ezpix-album', 'ez2'],\n    ['application/vnd.ezpix-package', 'ez3'],\n    ['application/vnd.fdf', 'fdf'],\n    ['application/vnd.fdsn.seed', 'seed'],\n    ['application/vnd.flographit', 'gph'],\n    ['application/vnd.fluxtime.clip', 'ftc'],\n    ['application/vnd.framemaker', 'fm'],\n    ['application/vnd.frogans.fnc', 'fnc'],\n    ['application/vnd.frogans.ltf', 'ltf'],\n    ['application/vnd.fsc.weblaunch', 'fsc'],\n    ['application/vnd.fujitsu.oasys', 'oas'],\n    ['application/vnd.fujitsu.oasys2', 'oa2'],\n    ['application/vnd.fujitsu.oasys3', 'oa3'],\n    ['application/vnd.fujitsu.oasysgp', 'fg5'],\n    ['application/vnd.fujitsu.oasysprs', 'bh2'],\n    ['application/vnd.fujixerox.ddd', 'ddd'],\n    ['application/vnd.fujixerox.docuworks', 'xdw'],\n    ['application/vnd.fujixerox.docuworks.binder', 'xbd'],\n    ['application/vnd.fuzzysheet', 'fzs'],\n    ['application/vnd.genomatix.tuxedo', 'txd'],\n    ['application/vnd.geogebra.file', 'ggb'],\n    ['application/vnd.geogebra.tool', 'ggt'],\n    ['application/vnd.geometry-explorer', 'gex'],\n    ['application/vnd.geonext', 'gxt'],\n    ['application/vnd.geoplan', 'g2w'],\n    ['application/vnd.geospace', 'g3w'],\n    ['application/vnd.gmx', 'gmx'],\n    ['application/vnd.google-earth.kml+xml', 'kml'],\n    ['application/vnd.google-earth.kmz', 'kmz'],\n    ['application/vnd.grafeq', 'gqf'],\n    ['application/vnd.groove-account', 'gac'],\n    ['application/vnd.groove-help', 'ghf'],\n    ['application/vnd.groove-identity-message', 'gim'],\n    ['application/vnd.groove-injector', 'grv'],\n    ['application/vnd.groove-tool-message', 'gtm'],\n    ['application/vnd.groove-tool-template', 'tpl'],\n    ['application/vnd.groove-vcard', 'vcg'],\n    ['application/vnd.hal+xml', 'hal'],\n    ['application/vnd.handheld-entertainment+xml', 'zmm'],\n    ['application/vnd.hbci', 'hbci'],\n    ['application/vnd.hhe.lesson-player', 'les'],\n    ['application/vnd.hp-hpgl', ['hgl', 'hpg', 'hpgl']],\n    ['application/vnd.hp-hpid', 'hpid'],\n    ['application/vnd.hp-hps', 'hps'],\n    ['application/vnd.hp-jlyt', 'jlt'],\n    ['application/vnd.hp-pcl', 'pcl'],\n    ['application/vnd.hp-pclxl', 'pclxl'],\n    ['application/vnd.hydrostatix.sof-data', 'sfd-hdstx'],\n    ['application/vnd.hzn-3d-crossword', 'x3d'],\n    ['application/vnd.ibm.minipay', 'mpy'],\n    ['application/vnd.ibm.modcap', 'afp'],\n    ['application/vnd.ibm.rights-management', 'irm'],\n    ['application/vnd.ibm.secure-container', 'sc'],\n    ['application/vnd.iccprofile', 'icc'],\n    ['application/vnd.igloader', 'igl'],\n    ['application/vnd.immervision-ivp', 'ivp'],\n    ['application/vnd.immervision-ivu', 'ivu'],\n    ['application/vnd.insors.igm', 'igm'],\n    ['application/vnd.intercon.formnet', 'xpw'],\n    ['application/vnd.intergeo', 'i2g'],\n    ['application/vnd.intu.qbo', 'qbo'],\n    ['application/vnd.intu.qfx', 'qfx'],\n    ['application/vnd.ipunplugged.rcprofile', 'rcprofile'],\n    ['application/vnd.irepository.package+xml', 'irp'],\n    ['application/vnd.is-xpr', 'xpr'],\n    ['application/vnd.isac.fcs', 'fcs'],\n    ['application/vnd.jam', 'jam'],\n    ['application/vnd.jcp.javame.midlet-rms', 'rms'],\n    ['application/vnd.jisp', 'jisp'],\n    ['application/vnd.joost.joda-archive', 'joda'],\n    ['application/vnd.kahootz', 'ktz'],\n    ['application/vnd.kde.karbon', 'karbon'],\n    ['application/vnd.kde.kchart', 'chrt'],\n    ['application/vnd.kde.kformula', 'kfo'],\n    ['application/vnd.kde.kivio', 'flw'],\n    ['application/vnd.kde.kontour', 'kon'],\n    ['application/vnd.kde.kpresenter', 'kpr'],\n    ['application/vnd.kde.kspread', 'ksp'],\n    ['application/vnd.kde.kword', 'kwd'],\n    ['application/vnd.kenameaapp', 'htke'],\n    ['application/vnd.kidspiration', 'kia'],\n    ['application/vnd.kinar', 'kne'],\n    ['application/vnd.koan', 'skp'],\n    ['application/vnd.kodak-descriptor', 'sse'],\n    ['application/vnd.las.las+xml', 'lasxml'],\n    ['application/vnd.llamagraphics.life-balance.desktop', 'lbd'],\n    ['application/vnd.llamagraphics.life-balance.exchange+xml', 'lbe'],\n    ['application/vnd.lotus-1-2-3', '123'],\n    ['application/vnd.lotus-approach', 'apr'],\n    ['application/vnd.lotus-freelance', 'pre'],\n    ['application/vnd.lotus-notes', 'nsf'],\n    ['application/vnd.lotus-organizer', 'org'],\n    ['application/vnd.lotus-screencam', 'scm'],\n    ['application/vnd.lotus-wordpro', 'lwp'],\n    ['application/vnd.macports.portpkg', 'portpkg'],\n    ['application/vnd.mcd', 'mcd'],\n    ['application/vnd.medcalcdata', 'mc1'],\n    ['application/vnd.mediastation.cdkey', 'cdkey'],\n    ['application/vnd.mfer', 'mwf'],\n    ['application/vnd.mfmp', 'mfm'],\n    ['application/vnd.micrografx.flo', 'flo'],\n    ['application/vnd.micrografx.igx', 'igx'],\n    ['application/vnd.mif', 'mif'],\n    ['application/vnd.mobius.daf', 'daf'],\n    ['application/vnd.mobius.dis', 'dis'],\n    ['application/vnd.mobius.mbk', 'mbk'],\n    ['application/vnd.mobius.mqy', 'mqy'],\n    ['application/vnd.mobius.msl', 'msl'],\n    ['application/vnd.mobius.plc', 'plc'],\n    ['application/vnd.mobius.txf', 'txf'],\n    ['application/vnd.mophun.application', 'mpn'],\n    ['application/vnd.mophun.certificate', 'mpc'],\n    ['application/vnd.mozilla.xul+xml', 'xul'],\n    ['application/vnd.ms-artgalry', 'cil'],\n    ['application/vnd.ms-cab-compressed', 'cab'],\n    ['application/vnd.ms-excel', ['xls', 'xla', 'xlc', 'xlm', 'xlt', 'xlw', 'xlb', 'xll']],\n    ['application/vnd.ms-excel.addin.macroenabled.12', 'xlam'],\n    ['application/vnd.ms-excel.sheet.binary.macroenabled.12', 'xlsb'],\n    ['application/vnd.ms-excel.sheet.macroenabled.12', 'xlsm'],\n    ['application/vnd.ms-excel.template.macroenabled.12', 'xltm'],\n    ['application/vnd.ms-fontobject', 'eot'],\n    ['application/vnd.ms-htmlhelp', 'chm'],\n    ['application/vnd.ms-ims', 'ims'],\n    ['application/vnd.ms-lrm', 'lrm'],\n    ['application/vnd.ms-officetheme', 'thmx'],\n    ['application/vnd.ms-outlook', 'msg'],\n    ['application/vnd.ms-pki.certstore', 'sst'],\n    ['application/vnd.ms-pki.pko', 'pko'],\n    ['application/vnd.ms-pki.seccat', 'cat'],\n    ['application/vnd.ms-pki.stl', 'stl'],\n    ['application/vnd.ms-pkicertstore', 'sst'],\n    ['application/vnd.ms-pkiseccat', 'cat'],\n    ['application/vnd.ms-pkistl', 'stl'],\n    ['application/vnd.ms-powerpoint', ['ppt', 'pot', 'pps', 'ppa', 'pwz']],\n    ['application/vnd.ms-powerpoint.addin.macroenabled.12', 'ppam'],\n    ['application/vnd.ms-powerpoint.presentation.macroenabled.12', 'pptm'],\n    ['application/vnd.ms-powerpoint.slide.macroenabled.12', 'sldm'],\n    ['application/vnd.ms-powerpoint.slideshow.macroenabled.12', 'ppsm'],\n    ['application/vnd.ms-powerpoint.template.macroenabled.12', 'potm'],\n    ['application/vnd.ms-project', 'mpp'],\n    ['application/vnd.ms-word.document.macroenabled.12', 'docm'],\n    ['application/vnd.ms-word.template.macroenabled.12', 'dotm'],\n    ['application/vnd.ms-works', ['wks', 'wcm', 'wdb', 'wps']],\n    ['application/vnd.ms-wpl', 'wpl'],\n    ['application/vnd.ms-xpsdocument', 'xps'],\n    ['application/vnd.mseq', 'mseq'],\n    ['application/vnd.musician', 'mus'],\n    ['application/vnd.muvee.style', 'msty'],\n    ['application/vnd.neurolanguage.nlu', 'nlu'],\n    ['application/vnd.noblenet-directory', 'nnd'],\n    ['application/vnd.noblenet-sealer', 'nns'],\n    ['application/vnd.noblenet-web', 'nnw'],\n    ['application/vnd.nokia.configuration-message', 'ncm'],\n    ['application/vnd.nokia.n-gage.data', 'ngdat'],\n    ['application/vnd.nokia.n-gage.symbian.install', 'n-gage'],\n    ['application/vnd.nokia.radio-preset', 'rpst'],\n    ['application/vnd.nokia.radio-presets', 'rpss'],\n    ['application/vnd.nokia.ringing-tone', 'rng'],\n    ['application/vnd.novadigm.edm', 'edm'],\n    ['application/vnd.novadigm.edx', 'edx'],\n    ['application/vnd.novadigm.ext', 'ext'],\n    ['application/vnd.oasis.opendocument.chart', 'odc'],\n    ['application/vnd.oasis.opendocument.chart-template', 'otc'],\n    ['application/vnd.oasis.opendocument.database', 'odb'],\n    ['application/vnd.oasis.opendocument.formula', 'odf'],\n    ['application/vnd.oasis.opendocument.formula-template', 'odft'],\n    ['application/vnd.oasis.opendocument.graphics', 'odg'],\n    ['application/vnd.oasis.opendocument.graphics-template', 'otg'],\n    ['application/vnd.oasis.opendocument.image', 'odi'],\n    ['application/vnd.oasis.opendocument.image-template', 'oti'],\n    ['application/vnd.oasis.opendocument.presentation', 'odp'],\n    ['application/vnd.oasis.opendocument.presentation-template', 'otp'],\n    ['application/vnd.oasis.opendocument.spreadsheet', 'ods'],\n    ['application/vnd.oasis.opendocument.spreadsheet-template', 'ots'],\n    ['application/vnd.oasis.opendocument.text', 'odt'],\n    ['application/vnd.oasis.opendocument.text-master', 'odm'],\n    ['application/vnd.oasis.opendocument.text-template', 'ott'],\n    ['application/vnd.oasis.opendocument.text-web', 'oth'],\n    ['application/vnd.olpc-sugar', 'xo'],\n    ['application/vnd.oma.dd2+xml', 'dd2'],\n    ['application/vnd.openofficeorg.extension', 'oxt'],\n    ['application/vnd.openxmlformats-officedocument.presentationml.presentation', 'pptx'],\n    ['application/vnd.openxmlformats-officedocument.presentationml.slide', 'sldx'],\n    ['application/vnd.openxmlformats-officedocument.presentationml.slideshow', 'ppsx'],\n    ['application/vnd.openxmlformats-officedocument.presentationml.template', 'potx'],\n    ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'xlsx'],\n    ['application/vnd.openxmlformats-officedocument.spreadsheetml.template', 'xltx'],\n    ['application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'docx'],\n    ['application/vnd.openxmlformats-officedocument.wordprocessingml.template', 'dotx'],\n    ['application/vnd.osgeo.mapguide.package', 'mgp'],\n    ['application/vnd.osgi.dp', 'dp'],\n    ['application/vnd.palm', 'pdb'],\n    ['application/vnd.pawaafile', 'paw'],\n    ['application/vnd.pg.format', 'str'],\n    ['application/vnd.pg.osasli', 'ei6'],\n    ['application/vnd.picsel', 'efif'],\n    ['application/vnd.pmi.widget', 'wg'],\n    ['application/vnd.pocketlearn', 'plf'],\n    ['application/vnd.powerbuilder6', 'pbd'],\n    ['application/vnd.previewsystems.box', 'box'],\n    ['application/vnd.proteus.magazine', 'mgz'],\n    ['application/vnd.publishare-delta-tree', 'qps'],\n    ['application/vnd.pvi.ptid1', 'ptid'],\n    ['application/vnd.quark.quarkxpress', 'qxd'],\n    ['application/vnd.realvnc.bed', 'bed'],\n    ['application/vnd.recordare.musicxml', 'mxl'],\n    ['application/vnd.recordare.musicxml+xml', 'musicxml'],\n    ['application/vnd.rig.cryptonote', 'cryptonote'],\n    ['application/vnd.rim.cod', 'cod'],\n    ['application/vnd.rn-realmedia', 'rm'],\n    ['application/vnd.rn-realplayer', 'rnx'],\n    ['application/vnd.route66.link66+xml', 'link66'],\n    ['application/vnd.sailingtracker.track', 'st'],\n    ['application/vnd.seemail', 'see'],\n    ['application/vnd.sema', 'sema'],\n    ['application/vnd.semd', 'semd'],\n    ['application/vnd.semf', 'semf'],\n    ['application/vnd.shana.informed.formdata', 'ifm'],\n    ['application/vnd.shana.informed.formtemplate', 'itp'],\n    ['application/vnd.shana.informed.interchange', 'iif'],\n    ['application/vnd.shana.informed.package', 'ipk'],\n    ['application/vnd.simtech-mindmapper', 'twd'],\n    ['application/vnd.smaf', 'mmf'],\n    ['application/vnd.smart.teacher', 'teacher'],\n    ['application/vnd.solent.sdkm+xml', 'sdkm'],\n    ['application/vnd.spotfire.dxp', 'dxp'],\n    ['application/vnd.spotfire.sfs', 'sfs'],\n    ['application/vnd.stardivision.calc', 'sdc'],\n    ['application/vnd.stardivision.draw', 'sda'],\n    ['application/vnd.stardivision.impress', 'sdd'],\n    ['application/vnd.stardivision.math', 'smf'],\n    ['application/vnd.stardivision.writer', 'sdw'],\n    ['application/vnd.stardivision.writer-global', 'sgl'],\n    ['application/vnd.stepmania.stepchart', 'sm'],\n    ['application/vnd.sun.xml.calc', 'sxc'],\n    ['application/vnd.sun.xml.calc.template', 'stc'],\n    ['application/vnd.sun.xml.draw', 'sxd'],\n    ['application/vnd.sun.xml.draw.template', 'std'],\n    ['application/vnd.sun.xml.impress', 'sxi'],\n    ['application/vnd.sun.xml.impress.template', 'sti'],\n    ['application/vnd.sun.xml.math', 'sxm'],\n    ['application/vnd.sun.xml.writer', 'sxw'],\n    ['application/vnd.sun.xml.writer.global', 'sxg'],\n    ['application/vnd.sun.xml.writer.template', 'stw'],\n    ['application/vnd.sus-calendar', 'sus'],\n    ['application/vnd.svd', 'svd'],\n    ['application/vnd.symbian.install', 'sis'],\n    ['application/vnd.syncml+xml', 'xsm'],\n    ['application/vnd.syncml.dm+wbxml', 'bdm'],\n    ['application/vnd.syncml.dm+xml', 'xdm'],\n    ['application/vnd.tao.intent-module-archive', 'tao'],\n    ['application/vnd.tmobile-livetv', 'tmo'],\n    ['application/vnd.trid.tpt', 'tpt'],\n    ['application/vnd.triscape.mxs', 'mxs'],\n    ['application/vnd.trueapp', 'tra'],\n    ['application/vnd.ufdl', 'ufd'],\n    ['application/vnd.uiq.theme', 'utz'],\n    ['application/vnd.umajin', 'umj'],\n    ['application/vnd.unity', 'unityweb'],\n    ['application/vnd.uoml+xml', 'uoml'],\n    ['application/vnd.vcx', 'vcx'],\n    ['application/vnd.visio', 'vsd'],\n    ['application/vnd.visionary', 'vis'],\n    ['application/vnd.vsf', 'vsf'],\n    ['application/vnd.wap.wbxml', 'wbxml'],\n    ['application/vnd.wap.wmlc', 'wmlc'],\n    ['application/vnd.wap.wmlscriptc', 'wmlsc'],\n    ['application/vnd.webturbo', 'wtb'],\n    ['application/vnd.wolfram.player', 'nbp'],\n    ['application/vnd.wordperfect', 'wpd'],\n    ['application/vnd.wqd', 'wqd'],\n    ['application/vnd.wt.stf', 'stf'],\n    ['application/vnd.xara', ['web', 'xar']],\n    ['application/vnd.xfdl', 'xfdl'],\n    ['application/vnd.yamaha.hv-dic', 'hvd'],\n    ['application/vnd.yamaha.hv-script', 'hvs'],\n    ['application/vnd.yamaha.hv-voice', 'hvp'],\n    ['application/vnd.yamaha.openscoreformat', 'osf'],\n    ['application/vnd.yamaha.openscoreformat.osfpvg+xml', 'osfpvg'],\n    ['application/vnd.yamaha.smaf-audio', 'saf'],\n    ['application/vnd.yamaha.smaf-phrase', 'spf'],\n    ['application/vnd.yellowriver-custom-menu', 'cmp'],\n    ['application/vnd.zul', 'zir'],\n    ['application/vnd.zzazz.deck+xml', 'zaz'],\n    ['application/vocaltec-media-desc', 'vmd'],\n    ['application/vocaltec-media-file', 'vmf'],\n    ['application/voicexml+xml', 'vxml'],\n    ['application/widget', 'wgt'],\n    ['application/winhlp', 'hlp'],\n    ['application/wordperfect', ['wp', 'wp5', 'wp6', 'wpd']],\n    ['application/wordperfect6.0', ['w60', 'wp5']],\n    ['application/wordperfect6.1', 'w61'],\n    ['application/wsdl+xml', 'wsdl'],\n    ['application/wspolicy+xml', 'wspolicy'],\n    ['application/x-123', 'wk1'],\n    ['application/x-7z-compressed', '7z'],\n    ['application/x-abiword', 'abw'],\n    ['application/x-ace-compressed', 'ace'],\n    ['application/x-aim', 'aim'],\n    ['application/x-authorware-bin', 'aab'],\n    ['application/x-authorware-map', 'aam'],\n    ['application/x-authorware-seg', 'aas'],\n    ['application/x-bcpio', 'bcpio'],\n    ['application/x-binary', 'bin'],\n    ['application/x-binhex40', 'hqx'],\n    ['application/x-bittorrent', 'torrent'],\n    ['application/x-bsh', ['bsh', 'sh', 'shar']],\n    ['application/x-bytecode.elisp', 'elc'],\n    ['application/x-bytecode.python', 'pyc'],\n    ['application/x-bzip', 'bz'],\n    ['application/x-bzip2', ['boz', 'bz2']],\n    ['application/x-cdf', 'cdf'],\n    ['application/x-cdlink', 'vcd'],\n    ['application/x-chat', ['cha', 'chat']],\n    ['application/x-chess-pgn', 'pgn'],\n    ['application/x-cmu-raster', 'ras'],\n    ['application/x-cocoa', 'cco'],\n    ['application/x-compactpro', 'cpt'],\n    ['application/x-compress', 'z'],\n    ['application/x-compressed', ['tgz', 'gz', 'z', 'zip']],\n    ['application/x-conference', 'nsc'],\n    ['application/x-cpio', 'cpio'],\n    ['application/x-cpt', 'cpt'],\n    ['application/x-csh', 'csh'],\n    ['application/x-debian-package', 'deb'],\n    ['application/x-deepv', 'deepv'],\n    ['application/x-director', ['dir', 'dcr', 'dxr']],\n    ['application/x-doom', 'wad'],\n    ['application/x-dtbncx+xml', 'ncx'],\n    ['application/x-dtbook+xml', 'dtb'],\n    ['application/x-dtbresource+xml', 'res'],\n    ['application/x-dvi', 'dvi'],\n    ['application/x-elc', 'elc'],\n    ['application/x-envoy', ['env', 'evy']],\n    ['application/x-esrehber', 'es'],\n    ['application/x-excel', ['xls', 'xla', 'xlb', 'xlc', 'xld', 'xlk', 'xll', 'xlm', 'xlt', 'xlv', 'xlw']],\n    ['application/x-font-bdf', 'bdf'],\n    ['application/x-font-ghostscript', 'gsf'],\n    ['application/x-font-linux-psf', 'psf'],\n    ['application/x-font-otf', 'otf'],\n    ['application/x-font-pcf', 'pcf'],\n    ['application/x-font-snf', 'snf'],\n    ['application/x-font-ttf', 'ttf'],\n    ['application/x-font-type1', 'pfa'],\n    ['application/x-font-woff', 'woff'],\n    ['application/x-frame', 'mif'],\n    ['application/x-freelance', 'pre'],\n    ['application/x-futuresplash', 'spl'],\n    ['application/x-gnumeric', 'gnumeric'],\n    ['application/x-gsp', 'gsp'],\n    ['application/x-gss', 'gss'],\n    ['application/x-gtar', 'gtar'],\n    ['application/x-gzip', ['gz', 'gzip']],\n    ['application/x-hdf', 'hdf'],\n    ['application/x-helpfile', ['help', 'hlp']],\n    ['application/x-httpd-imap', 'imap'],\n    ['application/x-ima', 'ima'],\n    ['application/x-internet-signup', ['ins', 'isp']],\n    ['application/x-internett-signup', 'ins'],\n    ['application/x-inventor', 'iv'],\n    ['application/x-ip2', 'ip'],\n    ['application/x-iphone', 'iii'],\n    ['application/x-java-class', 'class'],\n    ['application/x-java-commerce', 'jcm'],\n    ['application/x-java-jnlp-file', 'jnlp'],\n    ['application/x-javascript', 'js'],\n    ['application/x-koan', ['skd', 'skm', 'skp', 'skt']],\n    ['application/x-ksh', 'ksh'],\n    ['application/x-latex', ['latex', 'ltx']],\n    ['application/x-lha', 'lha'],\n    ['application/x-lisp', 'lsp'],\n    ['application/x-livescreen', 'ivy'],\n    ['application/x-lotus', 'wq1'],\n    ['application/x-lotusscreencam', 'scm'],\n    ['application/x-lzh', 'lzh'],\n    ['application/x-lzx', 'lzx'],\n    ['application/x-mac-binhex40', 'hqx'],\n    ['application/x-macbinary', 'bin'],\n    ['application/x-magic-cap-package-1.0', 'mc$'],\n    ['application/x-mathcad', 'mcd'],\n    ['application/x-meme', 'mm'],\n    ['application/x-midi', ['mid', 'midi']],\n    ['application/x-mif', 'mif'],\n    ['application/x-mix-transfer', 'nix'],\n    ['application/x-mobipocket-ebook', 'prc'],\n    ['application/x-mplayer2', 'asx'],\n    ['application/x-ms-application', 'application'],\n    ['application/x-ms-wmd', 'wmd'],\n    ['application/x-ms-wmz', 'wmz'],\n    ['application/x-ms-xbap', 'xbap'],\n    ['application/x-msaccess', 'mdb'],\n    ['application/x-msbinder', 'obd'],\n    ['application/x-mscardfile', 'crd'],\n    ['application/x-msclip', 'clp'],\n    ['application/x-msdownload', ['exe', 'dll']],\n    ['application/x-msexcel', ['xls', 'xla', 'xlw']],\n    ['application/x-msmediaview', ['mvb', 'm13', 'm14']],\n    ['application/x-msmetafile', 'wmf'],\n    ['application/x-msmoney', 'mny'],\n    ['application/x-mspowerpoint', 'ppt'],\n    ['application/x-mspublisher', 'pub'],\n    ['application/x-msschedule', 'scd'],\n    ['application/x-msterminal', 'trm'],\n    ['application/x-mswrite', 'wri'],\n    ['application/x-navi-animation', 'ani'],\n    ['application/x-navidoc', 'nvd'],\n    ['application/x-navimap', 'map'],\n    ['application/x-navistyle', 'stl'],\n    ['application/x-netcdf', ['cdf', 'nc']],\n    ['application/x-newton-compatible-pkg', 'pkg'],\n    ['application/x-nokia-9000-communicator-add-on-software', 'aos'],\n    ['application/x-omc', 'omc'],\n    ['application/x-omcdatamaker', 'omcd'],\n    ['application/x-omcregerator', 'omcr'],\n    ['application/x-pagemaker', ['pm4', 'pm5']],\n    ['application/x-pcl', 'pcl'],\n    ['application/x-perfmon', ['pma', 'pmc', 'pml', 'pmr', 'pmw']],\n    ['application/x-pixclscript', 'plx'],\n    ['application/x-pkcs10', 'p10'],\n    ['application/x-pkcs12', ['p12', 'pfx']],\n    ['application/x-pkcs7-certificates', ['p7b', 'spc']],\n    ['application/x-pkcs7-certreqresp', 'p7r'],\n    ['application/x-pkcs7-mime', ['p7m', 'p7c']],\n    ['application/x-pkcs7-signature', ['p7s', 'p7a']],\n    ['application/x-pointplus', 'css'],\n    ['application/x-portable-anymap', 'pnm'],\n    ['application/x-project', ['mpc', 'mpt', 'mpv', 'mpx']],\n    ['application/x-qpro', 'wb1'],\n    ['application/x-rar-compressed', 'rar'],\n    ['application/x-rtf', 'rtf'],\n    ['application/x-sdp', 'sdp'],\n    ['application/x-sea', 'sea'],\n    ['application/x-seelogo', 'sl'],\n    ['application/x-sh', 'sh'],\n    ['application/x-shar', ['shar', 'sh']],\n    ['application/x-shockwave-flash', 'swf'],\n    ['application/x-silverlight-app', 'xap'],\n    ['application/x-sit', 'sit'],\n    ['application/x-sprite', ['spr', 'sprite']],\n    ['application/x-stuffit', 'sit'],\n    ['application/x-stuffitx', 'sitx'],\n    ['application/x-sv4cpio', 'sv4cpio'],\n    ['application/x-sv4crc', 'sv4crc'],\n    ['application/x-tar', 'tar'],\n    ['application/x-tbook', ['sbk', 'tbk']],\n    ['application/x-tcl', 'tcl'],\n    ['application/x-tex', 'tex'],\n    ['application/x-tex-tfm', 'tfm'],\n    ['application/x-texinfo', ['texi', 'texinfo']],\n    ['application/x-troff', ['roff', 't', 'tr']],\n    ['application/x-troff-man', 'man'],\n    ['application/x-troff-me', 'me'],\n    ['application/x-troff-ms', 'ms'],\n    ['application/x-troff-msvideo', 'avi'],\n    ['application/x-ustar', 'ustar'],\n    ['application/x-visio', ['vsd', 'vst', 'vsw']],\n    ['application/x-vnd.audioexplosion.mzz', 'mzz'],\n    ['application/x-vnd.ls-xpix', 'xpix'],\n    ['application/x-vrml', 'vrml'],\n    ['application/x-wais-source', ['src', 'wsrc']],\n    ['application/x-winhelp', 'hlp'],\n    ['application/x-wintalk', 'wtk'],\n    ['application/x-world', ['wrl', 'svr']],\n    ['application/x-wpwin', 'wpd'],\n    ['application/x-wri', 'wri'],\n    ['application/x-x509-ca-cert', ['cer', 'crt', 'der']],\n    ['application/x-x509-user-cert', 'crt'],\n    ['application/x-xfig', 'fig'],\n    ['application/x-xpinstall', 'xpi'],\n    ['application/x-zip-compressed', 'zip'],\n    ['application/xcap-diff+xml', 'xdf'],\n    ['application/xenc+xml', 'xenc'],\n    ['application/xhtml+xml', 'xhtml'],\n    ['application/xml', 'xml'],\n    ['application/xml-dtd', 'dtd'],\n    ['application/xop+xml', 'xop'],\n    ['application/xslt+xml', 'xslt'],\n    ['application/xspf+xml', 'xspf'],\n    ['application/xv+xml', 'mxml'],\n    ['application/yang', 'yang'],\n    ['application/yin+xml', 'yin'],\n    ['application/ynd.ms-pkipko', 'pko'],\n    ['application/zip', 'zip'],\n    ['audio/adpcm', 'adp'],\n    ['audio/aiff', ['aiff', 'aif', 'aifc']],\n    ['audio/basic', ['snd', 'au']],\n    ['audio/it', 'it'],\n    ['audio/make', ['funk', 'my', 'pfunk']],\n    ['audio/make.my.funk', 'pfunk'],\n    ['audio/mid', ['mid', 'rmi']],\n    ['audio/midi', ['midi', 'kar', 'mid']],\n    ['audio/mod', 'mod'],\n    ['audio/mp4', 'mp4a'],\n    ['audio/mpeg', ['mpga', 'mp3', 'm2a', 'mp2', 'mpa', 'mpg']],\n    ['audio/mpeg3', 'mp3'],\n    ['audio/nspaudio', ['la', 'lma']],\n    ['audio/ogg', 'oga'],\n    ['audio/s3m', 's3m'],\n    ['audio/tsp-audio', 'tsi'],\n    ['audio/tsplayer', 'tsp'],\n    ['audio/vnd.dece.audio', 'uva'],\n    ['audio/vnd.digital-winds', 'eol'],\n    ['audio/vnd.dra', 'dra'],\n    ['audio/vnd.dts', 'dts'],\n    ['audio/vnd.dts.hd', 'dtshd'],\n    ['audio/vnd.lucent.voice', 'lvp'],\n    ['audio/vnd.ms-playready.media.pya', 'pya'],\n    ['audio/vnd.nuera.ecelp4800', 'ecelp4800'],\n    ['audio/vnd.nuera.ecelp7470', 'ecelp7470'],\n    ['audio/vnd.nuera.ecelp9600', 'ecelp9600'],\n    ['audio/vnd.qcelp', 'qcp'],\n    ['audio/vnd.rip', 'rip'],\n    ['audio/voc', 'voc'],\n    ['audio/voxware', 'vox'],\n    ['audio/wav', 'wav'],\n    ['audio/webm', 'weba'],\n    ['audio/x-aac', 'aac'],\n    ['audio/x-adpcm', 'snd'],\n    ['audio/x-aiff', ['aiff', 'aif', 'aifc']],\n    ['audio/x-au', 'au'],\n    ['audio/x-gsm', ['gsd', 'gsm']],\n    ['audio/x-jam', 'jam'],\n    ['audio/x-liveaudio', 'lam'],\n    ['audio/x-mid', ['mid', 'midi']],\n    ['audio/x-midi', ['midi', 'mid']],\n    ['audio/x-mod', 'mod'],\n    ['audio/x-mpeg', 'mp2'],\n    ['audio/x-mpeg-3', 'mp3'],\n    ['audio/x-mpegurl', 'm3u'],\n    ['audio/x-mpequrl', 'm3u'],\n    ['audio/x-ms-wax', 'wax'],\n    ['audio/x-ms-wma', 'wma'],\n    ['audio/x-nspaudio', ['la', 'lma']],\n    ['audio/x-pn-realaudio', ['ra', 'ram', 'rm', 'rmm', 'rmp']],\n    ['audio/x-pn-realaudio-plugin', ['ra', 'rmp', 'rpm']],\n    ['audio/x-psid', 'sid'],\n    ['audio/x-realaudio', 'ra'],\n    ['audio/x-twinvq', 'vqf'],\n    ['audio/x-twinvq-plugin', ['vqe', 'vql']],\n    ['audio/x-vnd.audioexplosion.mjuicemediafile', 'mjf'],\n    ['audio/x-voc', 'voc'],\n    ['audio/x-wav', 'wav'],\n    ['audio/xm', 'xm'],\n    ['chemical/x-cdx', 'cdx'],\n    ['chemical/x-cif', 'cif'],\n    ['chemical/x-cmdf', 'cmdf'],\n    ['chemical/x-cml', 'cml'],\n    ['chemical/x-csml', 'csml'],\n    ['chemical/x-pdb', ['pdb', 'xyz']],\n    ['chemical/x-xyz', 'xyz'],\n    ['drawing/x-dwf', 'dwf'],\n    ['i-world/i-vrml', 'ivr'],\n    ['image/bmp', ['bmp', 'bm']],\n    ['image/cgm', 'cgm'],\n    ['image/cis-cod', 'cod'],\n    ['image/cmu-raster', ['ras', 'rast']],\n    ['image/fif', 'fif'],\n    ['image/florian', ['flo', 'turbot']],\n    ['image/g3fax', 'g3'],\n    ['image/gif', 'gif'],\n    ['image/ief', ['ief', 'iefs']],\n    ['image/jpeg', ['jpeg', 'jpe', 'jpg', 'jfif', 'jfif-tbnl']],\n    ['image/jutvision', 'jut'],\n    ['image/ktx', 'ktx'],\n    ['image/naplps', ['nap', 'naplps']],\n    ['image/pict', ['pic', 'pict']],\n    ['image/pipeg', 'jfif'],\n    ['image/pjpeg', ['jfif', 'jpe', 'jpeg', 'jpg']],\n    ['image/png', ['png', 'x-png']],\n    ['image/prs.btif', 'btif'],\n    ['image/svg+xml', 'svg'],\n    ['image/tiff', ['tif', 'tiff']],\n    ['image/vasa', 'mcf'],\n    ['image/vnd.adobe.photoshop', 'psd'],\n    ['image/vnd.dece.graphic', 'uvi'],\n    ['image/vnd.djvu', 'djvu'],\n    ['image/vnd.dvb.subtitle', 'sub'],\n    ['image/vnd.dwg', ['dwg', 'dxf', 'svf']],\n    ['image/vnd.dxf', 'dxf'],\n    ['image/vnd.fastbidsheet', 'fbs'],\n    ['image/vnd.fpx', 'fpx'],\n    ['image/vnd.fst', 'fst'],\n    ['image/vnd.fujixerox.edmics-mmr', 'mmr'],\n    ['image/vnd.fujixerox.edmics-rlc', 'rlc'],\n    ['image/vnd.ms-modi', 'mdi'],\n    ['image/vnd.net-fpx', ['fpx', 'npx']],\n    ['image/vnd.rn-realflash', 'rf'],\n    ['image/vnd.rn-realpix', 'rp'],\n    ['image/vnd.wap.wbmp', 'wbmp'],\n    ['image/vnd.xiff', 'xif'],\n    ['image/webp', 'webp'],\n    ['image/x-cmu-raster', 'ras'],\n    ['image/x-cmx', 'cmx'],\n    ['image/x-dwg', ['dwg', 'dxf', 'svf']],\n    ['image/x-freehand', 'fh'],\n    ['image/x-icon', 'ico'],\n    ['image/x-jg', 'art'],\n    ['image/x-jps', 'jps'],\n    ['image/x-niff', ['niff', 'nif']],\n    ['image/x-pcx', 'pcx'],\n    ['image/x-pict', ['pct', 'pic']],\n    ['image/x-portable-anymap', 'pnm'],\n    ['image/x-portable-bitmap', 'pbm'],\n    ['image/x-portable-graymap', 'pgm'],\n    ['image/x-portable-greymap', 'pgm'],\n    ['image/x-portable-pixmap', 'ppm'],\n    ['image/x-quicktime', ['qif', 'qti', 'qtif']],\n    ['image/x-rgb', 'rgb'],\n    ['image/x-tiff', ['tif', 'tiff']],\n    ['image/x-windows-bmp', 'bmp'],\n    ['image/x-xbitmap', 'xbm'],\n    ['image/x-xbm', 'xbm'],\n    ['image/x-xpixmap', ['xpm', 'pm']],\n    ['image/x-xwd', 'xwd'],\n    ['image/x-xwindowdump', 'xwd'],\n    ['image/xbm', 'xbm'],\n    ['image/xpm', 'xpm'],\n    ['message/rfc822', ['eml', 'mht', 'mhtml', 'nws', 'mime']],\n    ['model/iges', ['iges', 'igs']],\n    ['model/mesh', 'msh'],\n    ['model/vnd.collada+xml', 'dae'],\n    ['model/vnd.dwf', 'dwf'],\n    ['model/vnd.gdl', 'gdl'],\n    ['model/vnd.gtw', 'gtw'],\n    ['model/vnd.mts', 'mts'],\n    ['model/vnd.vtu', 'vtu'],\n    ['model/vrml', ['vrml', 'wrl', 'wrz']],\n    ['model/x-pov', 'pov'],\n    ['multipart/x-gzip', 'gzip'],\n    ['multipart/x-ustar', 'ustar'],\n    ['multipart/x-zip', 'zip'],\n    ['music/crescendo', ['mid', 'midi']],\n    ['music/x-karaoke', 'kar'],\n    ['paleovu/x-pv', 'pvu'],\n    ['text/asp', 'asp'],\n    ['text/calendar', 'ics'],\n    ['text/css', 'css'],\n    ['text/csv', 'csv'],\n    ['text/ecmascript', 'js'],\n    ['text/h323', '323'],\n    ['text/html', ['html', 'htm', 'stm', 'acgi', 'htmls', 'htx', 'shtml']],\n    ['text/iuls', 'uls'],\n    ['text/javascript', 'js'],\n    ['text/mcf', 'mcf'],\n    ['text/n3', 'n3'],\n    ['text/pascal', 'pas'],\n    [\n        'text/plain',\n        [\n            'txt',\n            'bas',\n            'c',\n            'h',\n            'c++',\n            'cc',\n            'com',\n            'conf',\n            'cxx',\n            'def',\n            'f',\n            'f90',\n            'for',\n            'g',\n            'hh',\n            'idc',\n            'jav',\n            'java',\n            'list',\n            'log',\n            'lst',\n            'm',\n            'mar',\n            'pl',\n            'sdml',\n            'text'\n        ]\n    ],\n    ['text/plain-bas', 'par'],\n    ['text/prs.lines.tag', 'dsc'],\n    ['text/richtext', ['rtx', 'rt', 'rtf']],\n    ['text/scriplet', 'wsc'],\n    ['text/scriptlet', 'sct'],\n    ['text/sgml', ['sgm', 'sgml']],\n    ['text/tab-separated-values', 'tsv'],\n    ['text/troff', 't'],\n    ['text/turtle', 'ttl'],\n    ['text/uri-list', ['uni', 'unis', 'uri', 'uris']],\n    ['text/vnd.abc', 'abc'],\n    ['text/vnd.curl', 'curl'],\n    ['text/vnd.curl.dcurl', 'dcurl'],\n    ['text/vnd.curl.mcurl', 'mcurl'],\n    ['text/vnd.curl.scurl', 'scurl'],\n    ['text/vnd.fly', 'fly'],\n    ['text/vnd.fmi.flexstor', 'flx'],\n    ['text/vnd.graphviz', 'gv'],\n    ['text/vnd.in3d.3dml', '3dml'],\n    ['text/vnd.in3d.spot', 'spot'],\n    ['text/vnd.rn-realtext', 'rt'],\n    ['text/vnd.sun.j2me.app-descriptor', 'jad'],\n    ['text/vnd.wap.wml', 'wml'],\n    ['text/vnd.wap.wmlscript', 'wmls'],\n    ['text/webviewhtml', 'htt'],\n    ['text/x-asm', ['asm', 's']],\n    ['text/x-audiosoft-intra', 'aip'],\n    ['text/x-c', ['c', 'cc', 'cpp']],\n    ['text/x-component', 'htc'],\n    ['text/x-fortran', ['for', 'f', 'f77', 'f90']],\n    ['text/x-h', ['h', 'hh']],\n    ['text/x-java-source', ['java', 'jav']],\n    ['text/x-java-source,java', 'java'],\n    ['text/x-la-asf', 'lsx'],\n    ['text/x-m', 'm'],\n    ['text/x-pascal', 'p'],\n    ['text/x-script', 'hlb'],\n    ['text/x-script.csh', 'csh'],\n    ['text/x-script.elisp', 'el'],\n    ['text/x-script.guile', 'scm'],\n    ['text/x-script.ksh', 'ksh'],\n    ['text/x-script.lisp', 'lsp'],\n    ['text/x-script.perl', 'pl'],\n    ['text/x-script.perl-module', 'pm'],\n    ['text/x-script.phyton', 'py'],\n    ['text/x-script.rexx', 'rexx'],\n    ['text/x-script.scheme', 'scm'],\n    ['text/x-script.sh', 'sh'],\n    ['text/x-script.tcl', 'tcl'],\n    ['text/x-script.tcsh', 'tcsh'],\n    ['text/x-script.zsh', 'zsh'],\n    ['text/x-server-parsed-html', ['shtml', 'ssi']],\n    ['text/x-setext', 'etx'],\n    ['text/x-sgml', ['sgm', 'sgml']],\n    ['text/x-speech', ['spc', 'talk']],\n    ['text/x-uil', 'uil'],\n    ['text/x-uuencode', ['uu', 'uue']],\n    ['text/x-vcalendar', 'vcs'],\n    ['text/x-vcard', 'vcf'],\n    ['text/xml', 'xml'],\n    ['video/3gpp', '3gp'],\n    ['video/3gpp2', '3g2'],\n    ['video/animaflex', 'afl'],\n    ['video/avi', 'avi'],\n    ['video/avs-video', 'avs'],\n    ['video/dl', 'dl'],\n    ['video/fli', 'fli'],\n    ['video/gl', 'gl'],\n    ['video/h261', 'h261'],\n    ['video/h263', 'h263'],\n    ['video/h264', 'h264'],\n    ['video/jpeg', 'jpgv'],\n    ['video/jpm', 'jpm'],\n    ['video/mj2', 'mj2'],\n    ['video/mp4', 'mp4'],\n    ['video/mpeg', ['mpeg', 'mp2', 'mpa', 'mpe', 'mpg', 'mpv2', 'm1v', 'm2v', 'mp3']],\n    ['video/msvideo', 'avi'],\n    ['video/ogg', 'ogv'],\n    ['video/quicktime', ['mov', 'qt', 'moov']],\n    ['video/vdo', 'vdo'],\n    ['video/vivo', ['viv', 'vivo']],\n    ['video/vnd.dece.hd', 'uvh'],\n    ['video/vnd.dece.mobile', 'uvm'],\n    ['video/vnd.dece.pd', 'uvp'],\n    ['video/vnd.dece.sd', 'uvs'],\n    ['video/vnd.dece.video', 'uvv'],\n    ['video/vnd.fvt', 'fvt'],\n    ['video/vnd.mpegurl', 'mxu'],\n    ['video/vnd.ms-playready.media.pyv', 'pyv'],\n    ['video/vnd.rn-realvideo', 'rv'],\n    ['video/vnd.uvvu.mp4', 'uvu'],\n    ['video/vnd.vivo', ['viv', 'vivo']],\n    ['video/vosaic', 'vos'],\n    ['video/webm', 'webm'],\n    ['video/x-amt-demorun', 'xdr'],\n    ['video/x-amt-showrun', 'xsr'],\n    ['video/x-atomic3d-feature', 'fmf'],\n    ['video/x-dl', 'dl'],\n    ['video/x-dv', ['dif', 'dv']],\n    ['video/x-f4v', 'f4v'],\n    ['video/x-fli', 'fli'],\n    ['video/x-flv', 'flv'],\n    ['video/x-gl', 'gl'],\n    ['video/x-isvideo', 'isu'],\n    ['video/x-la-asf', ['lsf', 'lsx']],\n    ['video/x-m4v', 'm4v'],\n    ['video/x-motion-jpeg', 'mjpg'],\n    ['video/x-mpeg', ['mp3', 'mp2']],\n    ['video/x-mpeq2a', 'mp2'],\n    ['video/x-ms-asf', ['asf', 'asr', 'asx']],\n    ['video/x-ms-asf-plugin', 'asx'],\n    ['video/x-ms-wm', 'wm'],\n    ['video/x-ms-wmv', 'wmv'],\n    ['video/x-ms-wmx', 'wmx'],\n    ['video/x-ms-wvx', 'wvx'],\n    ['video/x-msvideo', 'avi'],\n    ['video/x-qtc', 'qtc'],\n    ['video/x-scm', 'scm'],\n    ['video/x-sgi-movie', ['movie', 'mv']],\n    ['windows/metafile', 'wmf'],\n    ['www/mime', 'mime'],\n    ['x-conference/x-cooltalk', 'ice'],\n    ['x-music/x-midi', ['mid', 'midi']],\n    ['x-world/x-3dmf', ['3dm', '3dmf', 'qd3', 'qd3d']],\n    ['x-world/x-svr', 'svr'],\n    ['x-world/x-vrml', ['flr', 'vrml', 'wrl', 'wrz', 'xaf', 'xof']],\n    ['x-world/x-vrt', 'vrt'],\n    ['xgl/drawing', 'xgz'],\n    ['xgl/movie', 'xmz']\n]);\nconst extensions = new Map([\n    ['123', 'application/vnd.lotus-1-2-3'],\n    ['323', 'text/h323'],\n    ['*', 'application/octet-stream'],\n    ['3dm', 'x-world/x-3dmf'],\n    ['3dmf', 'x-world/x-3dmf'],\n    ['3dml', 'text/vnd.in3d.3dml'],\n    ['3g2', 'video/3gpp2'],\n    ['3gp', 'video/3gpp'],\n    ['7z', 'application/x-7z-compressed'],\n    ['a', 'application/octet-stream'],\n    ['aab', 'application/x-authorware-bin'],\n    ['aac', 'audio/x-aac'],\n    ['aam', 'application/x-authorware-map'],\n    ['aas', 'application/x-authorware-seg'],\n    ['abc', 'text/vnd.abc'],\n    ['abw', 'application/x-abiword'],\n    ['ac', 'application/pkix-attr-cert'],\n    ['acc', 'application/vnd.americandynamics.acc'],\n    ['ace', 'application/x-ace-compressed'],\n    ['acgi', 'text/html'],\n    ['acu', 'application/vnd.acucobol'],\n    ['acx', 'application/internet-property-stream'],\n    ['adp', 'audio/adpcm'],\n    ['aep', 'application/vnd.audiograph'],\n    ['afl', 'video/animaflex'],\n    ['afp', 'application/vnd.ibm.modcap'],\n    ['ahead', 'application/vnd.ahead.space'],\n    ['ai', 'application/postscript'],\n    ['aif', ['audio/aiff', 'audio/x-aiff']],\n    ['aifc', ['audio/aiff', 'audio/x-aiff']],\n    ['aiff', ['audio/aiff', 'audio/x-aiff']],\n    ['aim', 'application/x-aim'],\n    ['aip', 'text/x-audiosoft-intra'],\n    ['air', 'application/vnd.adobe.air-application-installer-package+zip'],\n    ['ait', 'application/vnd.dvb.ait'],\n    ['ami', 'application/vnd.amiga.ami'],\n    ['ani', 'application/x-navi-animation'],\n    ['aos', 'application/x-nokia-9000-communicator-add-on-software'],\n    ['apk', 'application/vnd.android.package-archive'],\n    ['application', 'application/x-ms-application'],\n    ['apr', 'application/vnd.lotus-approach'],\n    ['aps', 'application/mime'],\n    ['arc', 'application/octet-stream'],\n    ['arj', ['application/arj', 'application/octet-stream']],\n    ['art', 'image/x-jg'],\n    ['asf', 'video/x-ms-asf'],\n    ['asm', 'text/x-asm'],\n    ['aso', 'application/vnd.accpac.simply.aso'],\n    ['asp', 'text/asp'],\n    ['asr', 'video/x-ms-asf'],\n    ['asx', ['video/x-ms-asf', 'application/x-mplayer2', 'video/x-ms-asf-plugin']],\n    ['atc', 'application/vnd.acucorp'],\n    ['atomcat', 'application/atomcat+xml'],\n    ['atomsvc', 'application/atomsvc+xml'],\n    ['atx', 'application/vnd.antix.game-component'],\n    ['au', ['audio/basic', 'audio/x-au']],\n    ['avi', ['video/avi', 'video/msvideo', 'application/x-troff-msvideo', 'video/x-msvideo']],\n    ['avs', 'video/avs-video'],\n    ['aw', 'application/applixware'],\n    ['axs', 'application/olescript'],\n    ['azf', 'application/vnd.airzip.filesecure.azf'],\n    ['azs', 'application/vnd.airzip.filesecure.azs'],\n    ['azw', 'application/vnd.amazon.ebook'],\n    ['bas', 'text/plain'],\n    ['bcpio', 'application/x-bcpio'],\n    ['bdf', 'application/x-font-bdf'],\n    ['bdm', 'application/vnd.syncml.dm+wbxml'],\n    ['bed', 'application/vnd.realvnc.bed'],\n    ['bh2', 'application/vnd.fujitsu.oasysprs'],\n    ['bin', ['application/octet-stream', 'application/mac-binary', 'application/macbinary', 'application/x-macbinary', 'application/x-binary']],\n    ['bm', 'image/bmp'],\n    ['bmi', 'application/vnd.bmi'],\n    ['bmp', ['image/bmp', 'image/x-windows-bmp']],\n    ['boo', 'application/book'],\n    ['book', 'application/book'],\n    ['box', 'application/vnd.previewsystems.box'],\n    ['boz', 'application/x-bzip2'],\n    ['bsh', 'application/x-bsh'],\n    ['btif', 'image/prs.btif'],\n    ['bz', 'application/x-bzip'],\n    ['bz2', 'application/x-bzip2'],\n    ['c', ['text/plain', 'text/x-c']],\n    ['c++', 'text/plain'],\n    ['c11amc', 'application/vnd.cluetrust.cartomobile-config'],\n    ['c11amz', 'application/vnd.cluetrust.cartomobile-config-pkg'],\n    ['c4g', 'application/vnd.clonk.c4group'],\n    ['cab', 'application/vnd.ms-cab-compressed'],\n    ['car', 'application/vnd.curl.car'],\n    ['cat', ['application/vnd.ms-pkiseccat', 'application/vnd.ms-pki.seccat']],\n    ['cc', ['text/plain', 'text/x-c']],\n    ['ccad', 'application/clariscad'],\n    ['cco', 'application/x-cocoa'],\n    ['ccxml', 'application/ccxml+xml,'],\n    ['cdbcmsg', 'application/vnd.contact.cmsg'],\n    ['cdf', ['application/cdf', 'application/x-cdf', 'application/x-netcdf']],\n    ['cdkey', 'application/vnd.mediastation.cdkey'],\n    ['cdmia', 'application/cdmi-capability'],\n    ['cdmic', 'application/cdmi-container'],\n    ['cdmid', 'application/cdmi-domain'],\n    ['cdmio', 'application/cdmi-object'],\n    ['cdmiq', 'application/cdmi-queue'],\n    ['cdx', 'chemical/x-cdx'],\n    ['cdxml', 'application/vnd.chemdraw+xml'],\n    ['cdy', 'application/vnd.cinderella'],\n    ['cer', ['application/pkix-cert', 'application/x-x509-ca-cert']],\n    ['cgm', 'image/cgm'],\n    ['cha', 'application/x-chat'],\n    ['chat', 'application/x-chat'],\n    ['chm', 'application/vnd.ms-htmlhelp'],\n    ['chrt', 'application/vnd.kde.kchart'],\n    ['cif', 'chemical/x-cif'],\n    ['cii', 'application/vnd.anser-web-certificate-issue-initiation'],\n    ['cil', 'application/vnd.ms-artgalry'],\n    ['cla', 'application/vnd.claymore'],\n    ['class', ['application/octet-stream', 'application/java', 'application/java-byte-code', 'application/java-vm', 'application/x-java-class']],\n    ['clkk', 'application/vnd.crick.clicker.keyboard'],\n    ['clkp', 'application/vnd.crick.clicker.palette'],\n    ['clkt', 'application/vnd.crick.clicker.template'],\n    ['clkw', 'application/vnd.crick.clicker.wordbank'],\n    ['clkx', 'application/vnd.crick.clicker'],\n    ['clp', 'application/x-msclip'],\n    ['cmc', 'application/vnd.cosmocaller'],\n    ['cmdf', 'chemical/x-cmdf'],\n    ['cml', 'chemical/x-cml'],\n    ['cmp', 'application/vnd.yellowriver-custom-menu'],\n    ['cmx', 'image/x-cmx'],\n    ['cod', ['image/cis-cod', 'application/vnd.rim.cod']],\n    ['com', ['application/octet-stream', 'text/plain']],\n    ['conf', 'text/plain'],\n    ['cpio', 'application/x-cpio'],\n    ['cpp', 'text/x-c'],\n    ['cpt', ['application/mac-compactpro', 'application/x-compactpro', 'application/x-cpt']],\n    ['crd', 'application/x-mscardfile'],\n    ['crl', ['application/pkix-crl', 'application/pkcs-crl']],\n    ['crt', ['application/pkix-cert', 'application/x-x509-user-cert', 'application/x-x509-ca-cert']],\n    ['cryptonote', 'application/vnd.rig.cryptonote'],\n    ['csh', ['text/x-script.csh', 'application/x-csh']],\n    ['csml', 'chemical/x-csml'],\n    ['csp', 'application/vnd.commonspace'],\n    ['css', ['text/css', 'application/x-pointplus']],\n    ['csv', 'text/csv'],\n    ['cu', 'application/cu-seeme'],\n    ['curl', 'text/vnd.curl'],\n    ['cww', 'application/prs.cww'],\n    ['cxx', 'text/plain'],\n    ['dae', 'model/vnd.collada+xml'],\n    ['daf', 'application/vnd.mobius.daf'],\n    ['davmount', 'application/davmount+xml'],\n    ['dcr', 'application/x-director'],\n    ['dcurl', 'text/vnd.curl.dcurl'],\n    ['dd2', 'application/vnd.oma.dd2+xml'],\n    ['ddd', 'application/vnd.fujixerox.ddd'],\n    ['deb', 'application/x-debian-package'],\n    ['deepv', 'application/x-deepv'],\n    ['def', 'text/plain'],\n    ['der', 'application/x-x509-ca-cert'],\n    ['dfac', 'application/vnd.dreamfactory'],\n    ['dif', 'video/x-dv'],\n    ['dir', 'application/x-director'],\n    ['dis', 'application/vnd.mobius.dis'],\n    ['djvu', 'image/vnd.djvu'],\n    ['dl', ['video/dl', 'video/x-dl']],\n    ['dll', 'application/x-msdownload'],\n    ['dms', 'application/octet-stream'],\n    ['dna', 'application/vnd.dna'],\n    ['doc', 'application/msword'],\n    ['docm', 'application/vnd.ms-word.document.macroenabled.12'],\n    ['docx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],\n    ['dot', 'application/msword'],\n    ['dotm', 'application/vnd.ms-word.template.macroenabled.12'],\n    ['dotx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.template'],\n    ['dp', ['application/commonground', 'application/vnd.osgi.dp']],\n    ['dpg', 'application/vnd.dpgraph'],\n    ['dra', 'audio/vnd.dra'],\n    ['drw', 'application/drafting'],\n    ['dsc', 'text/prs.lines.tag'],\n    ['dssc', 'application/dssc+der'],\n    ['dtb', 'application/x-dtbook+xml'],\n    ['dtd', 'application/xml-dtd'],\n    ['dts', 'audio/vnd.dts'],\n    ['dtshd', 'audio/vnd.dts.hd'],\n    ['dump', 'application/octet-stream'],\n    ['dv', 'video/x-dv'],\n    ['dvi', 'application/x-dvi'],\n    ['dwf', ['model/vnd.dwf', 'drawing/x-dwf']],\n    ['dwg', ['application/acad', 'image/vnd.dwg', 'image/x-dwg']],\n    ['dxf', ['application/dxf', 'image/vnd.dwg', 'image/vnd.dxf', 'image/x-dwg']],\n    ['dxp', 'application/vnd.spotfire.dxp'],\n    ['dxr', 'application/x-director'],\n    ['ecelp4800', 'audio/vnd.nuera.ecelp4800'],\n    ['ecelp7470', 'audio/vnd.nuera.ecelp7470'],\n    ['ecelp9600', 'audio/vnd.nuera.ecelp9600'],\n    ['edm', 'application/vnd.novadigm.edm'],\n    ['edx', 'application/vnd.novadigm.edx'],\n    ['efif', 'application/vnd.picsel'],\n    ['ei6', 'application/vnd.pg.osasli'],\n    ['el', 'text/x-script.elisp'],\n    ['elc', ['application/x-elc', 'application/x-bytecode.elisp']],\n    ['eml', 'message/rfc822'],\n    ['emma', 'application/emma+xml'],\n    ['env', 'application/x-envoy'],\n    ['eol', 'audio/vnd.digital-winds'],\n    ['eot', 'application/vnd.ms-fontobject'],\n    ['eps', 'application/postscript'],\n    ['epub', 'application/epub+zip'],\n    ['es', ['application/ecmascript', 'application/x-esrehber']],\n    ['es3', 'application/vnd.eszigno3+xml'],\n    ['esf', 'application/vnd.epson.esf'],\n    ['etx', 'text/x-setext'],\n    ['evy', ['application/envoy', 'application/x-envoy']],\n    ['exe', ['application/octet-stream', 'application/x-msdownload']],\n    ['exi', 'application/exi'],\n    ['ext', 'application/vnd.novadigm.ext'],\n    ['ez2', 'application/vnd.ezpix-album'],\n    ['ez3', 'application/vnd.ezpix-package'],\n    ['f', ['text/plain', 'text/x-fortran']],\n    ['f4v', 'video/x-f4v'],\n    ['f77', 'text/x-fortran'],\n    ['f90', ['text/plain', 'text/x-fortran']],\n    ['fbs', 'image/vnd.fastbidsheet'],\n    ['fcs', 'application/vnd.isac.fcs'],\n    ['fdf', 'application/vnd.fdf'],\n    ['fe_launch', 'application/vnd.denovo.fcselayout-link'],\n    ['fg5', 'application/vnd.fujitsu.oasysgp'],\n    ['fh', 'image/x-freehand'],\n    ['fif', ['application/fractals', 'image/fif']],\n    ['fig', 'application/x-xfig'],\n    ['fli', ['video/fli', 'video/x-fli']],\n    ['flo', ['image/florian', 'application/vnd.micrografx.flo']],\n    ['flr', 'x-world/x-vrml'],\n    ['flv', 'video/x-flv'],\n    ['flw', 'application/vnd.kde.kivio'],\n    ['flx', 'text/vnd.fmi.flexstor'],\n    ['fly', 'text/vnd.fly'],\n    ['fm', 'application/vnd.framemaker'],\n    ['fmf', 'video/x-atomic3d-feature'],\n    ['fnc', 'application/vnd.frogans.fnc'],\n    ['for', ['text/plain', 'text/x-fortran']],\n    ['fpx', ['image/vnd.fpx', 'image/vnd.net-fpx']],\n    ['frl', 'application/freeloader'],\n    ['fsc', 'application/vnd.fsc.weblaunch'],\n    ['fst', 'image/vnd.fst'],\n    ['ftc', 'application/vnd.fluxtime.clip'],\n    ['fti', 'application/vnd.anser-web-funds-transfer-initiation'],\n    ['funk', 'audio/make'],\n    ['fvt', 'video/vnd.fvt'],\n    ['fxp', 'application/vnd.adobe.fxp'],\n    ['fzs', 'application/vnd.fuzzysheet'],\n    ['g', 'text/plain'],\n    ['g2w', 'application/vnd.geoplan'],\n    ['g3', 'image/g3fax'],\n    ['g3w', 'application/vnd.geospace'],\n    ['gac', 'application/vnd.groove-account'],\n    ['gdl', 'model/vnd.gdl'],\n    ['geo', 'application/vnd.dynageo'],\n    ['gex', 'application/vnd.geometry-explorer'],\n    ['ggb', 'application/vnd.geogebra.file'],\n    ['ggt', 'application/vnd.geogebra.tool'],\n    ['ghf', 'application/vnd.groove-help'],\n    ['gif', 'image/gif'],\n    ['gim', 'application/vnd.groove-identity-message'],\n    ['gl', ['video/gl', 'video/x-gl']],\n    ['gmx', 'application/vnd.gmx'],\n    ['gnumeric', 'application/x-gnumeric'],\n    ['gph', 'application/vnd.flographit'],\n    ['gqf', 'application/vnd.grafeq'],\n    ['gram', 'application/srgs'],\n    ['grv', 'application/vnd.groove-injector'],\n    ['grxml', 'application/srgs+xml'],\n    ['gsd', 'audio/x-gsm'],\n    ['gsf', 'application/x-font-ghostscript'],\n    ['gsm', 'audio/x-gsm'],\n    ['gsp', 'application/x-gsp'],\n    ['gss', 'application/x-gss'],\n    ['gtar', 'application/x-gtar'],\n    ['gtm', 'application/vnd.groove-tool-message'],\n    ['gtw', 'model/vnd.gtw'],\n    ['gv', 'text/vnd.graphviz'],\n    ['gxt', 'application/vnd.geonext'],\n    ['gz', ['application/x-gzip', 'application/x-compressed']],\n    ['gzip', ['multipart/x-gzip', 'application/x-gzip']],\n    ['h', ['text/plain', 'text/x-h']],\n    ['h261', 'video/h261'],\n    ['h263', 'video/h263'],\n    ['h264', 'video/h264'],\n    ['hal', 'application/vnd.hal+xml'],\n    ['hbci', 'application/vnd.hbci'],\n    ['hdf', 'application/x-hdf'],\n    ['help', 'application/x-helpfile'],\n    ['hgl', 'application/vnd.hp-hpgl'],\n    ['hh', ['text/plain', 'text/x-h']],\n    ['hlb', 'text/x-script'],\n    ['hlp', ['application/winhlp', 'application/hlp', 'application/x-helpfile', 'application/x-winhelp']],\n    ['hpg', 'application/vnd.hp-hpgl'],\n    ['hpgl', 'application/vnd.hp-hpgl'],\n    ['hpid', 'application/vnd.hp-hpid'],\n    ['hps', 'application/vnd.hp-hps'],\n    [\n        'hqx',\n        [\n            'application/mac-binhex40',\n            'application/binhex',\n            'application/binhex4',\n            'application/mac-binhex',\n            'application/x-binhex40',\n            'application/x-mac-binhex40'\n        ]\n    ],\n    ['hta', 'application/hta'],\n    ['htc', 'text/x-component'],\n    ['htke', 'application/vnd.kenameaapp'],\n    ['htm', 'text/html'],\n    ['html', 'text/html'],\n    ['htmls', 'text/html'],\n    ['htt', 'text/webviewhtml'],\n    ['htx', 'text/html'],\n    ['hvd', 'application/vnd.yamaha.hv-dic'],\n    ['hvp', 'application/vnd.yamaha.hv-voice'],\n    ['hvs', 'application/vnd.yamaha.hv-script'],\n    ['i2g', 'application/vnd.intergeo'],\n    ['icc', 'application/vnd.iccprofile'],\n    ['ice', 'x-conference/x-cooltalk'],\n    ['ico', 'image/x-icon'],\n    ['ics', 'text/calendar'],\n    ['idc', 'text/plain'],\n    ['ief', 'image/ief'],\n    ['iefs', 'image/ief'],\n    ['ifm', 'application/vnd.shana.informed.formdata'],\n    ['iges', ['application/iges', 'model/iges']],\n    ['igl', 'application/vnd.igloader'],\n    ['igm', 'application/vnd.insors.igm'],\n    ['igs', ['application/iges', 'model/iges']],\n    ['igx', 'application/vnd.micrografx.igx'],\n    ['iif', 'application/vnd.shana.informed.interchange'],\n    ['iii', 'application/x-iphone'],\n    ['ima', 'application/x-ima'],\n    ['imap', 'application/x-httpd-imap'],\n    ['imp', 'application/vnd.accpac.simply.imp'],\n    ['ims', 'application/vnd.ms-ims'],\n    ['inf', 'application/inf'],\n    ['ins', ['application/x-internet-signup', 'application/x-internett-signup']],\n    ['ip', 'application/x-ip2'],\n    ['ipfix', 'application/ipfix'],\n    ['ipk', 'application/vnd.shana.informed.package'],\n    ['irm', 'application/vnd.ibm.rights-management'],\n    ['irp', 'application/vnd.irepository.package+xml'],\n    ['isp', 'application/x-internet-signup'],\n    ['isu', 'video/x-isvideo'],\n    ['it', 'audio/it'],\n    ['itp', 'application/vnd.shana.informed.formtemplate'],\n    ['iv', 'application/x-inventor'],\n    ['ivp', 'application/vnd.immervision-ivp'],\n    ['ivr', 'i-world/i-vrml'],\n    ['ivu', 'application/vnd.immervision-ivu'],\n    ['ivy', 'application/x-livescreen'],\n    ['jad', 'text/vnd.sun.j2me.app-descriptor'],\n    ['jam', ['application/vnd.jam', 'audio/x-jam']],\n    ['jar', 'application/java-archive'],\n    ['jav', ['text/plain', 'text/x-java-source']],\n    ['java', ['text/plain', 'text/x-java-source,java', 'text/x-java-source']],\n    ['jcm', 'application/x-java-commerce'],\n    ['jfif', ['image/pipeg', 'image/jpeg', 'image/pjpeg']],\n    ['jfif-tbnl', 'image/jpeg'],\n    ['jisp', 'application/vnd.jisp'],\n    ['jlt', 'application/vnd.hp-jlyt'],\n    ['jnlp', 'application/x-java-jnlp-file'],\n    ['joda', 'application/vnd.joost.joda-archive'],\n    ['jpe', ['image/jpeg', 'image/pjpeg']],\n    ['jpeg', ['image/jpeg', 'image/pjpeg']],\n    ['jpg', ['image/jpeg', 'image/pjpeg']],\n    ['jpgv', 'video/jpeg'],\n    ['jpm', 'video/jpm'],\n    ['jps', 'image/x-jps'],\n    ['js', ['application/javascript', 'application/ecmascript', 'text/javascript', 'text/ecmascript', 'application/x-javascript']],\n    ['json', 'application/json'],\n    ['jut', 'image/jutvision'],\n    ['kar', ['audio/midi', 'music/x-karaoke']],\n    ['karbon', 'application/vnd.kde.karbon'],\n    ['kfo', 'application/vnd.kde.kformula'],\n    ['kia', 'application/vnd.kidspiration'],\n    ['kml', 'application/vnd.google-earth.kml+xml'],\n    ['kmz', 'application/vnd.google-earth.kmz'],\n    ['kne', 'application/vnd.kinar'],\n    ['kon', 'application/vnd.kde.kontour'],\n    ['kpr', 'application/vnd.kde.kpresenter'],\n    ['ksh', ['application/x-ksh', 'text/x-script.ksh']],\n    ['ksp', 'application/vnd.kde.kspread'],\n    ['ktx', 'image/ktx'],\n    ['ktz', 'application/vnd.kahootz'],\n    ['kwd', 'application/vnd.kde.kword'],\n    ['la', ['audio/nspaudio', 'audio/x-nspaudio']],\n    ['lam', 'audio/x-liveaudio'],\n    ['lasxml', 'application/vnd.las.las+xml'],\n    ['latex', 'application/x-latex'],\n    ['lbd', 'application/vnd.llamagraphics.life-balance.desktop'],\n    ['lbe', 'application/vnd.llamagraphics.life-balance.exchange+xml'],\n    ['les', 'application/vnd.hhe.lesson-player'],\n    ['lha', ['application/octet-stream', 'application/lha', 'application/x-lha']],\n    ['lhx', 'application/octet-stream'],\n    ['link66', 'application/vnd.route66.link66+xml'],\n    ['list', 'text/plain'],\n    ['lma', ['audio/nspaudio', 'audio/x-nspaudio']],\n    ['log', 'text/plain'],\n    ['lrm', 'application/vnd.ms-lrm'],\n    ['lsf', 'video/x-la-asf'],\n    ['lsp', ['application/x-lisp', 'text/x-script.lisp']],\n    ['lst', 'text/plain'],\n    ['lsx', ['video/x-la-asf', 'text/x-la-asf']],\n    ['ltf', 'application/vnd.frogans.ltf'],\n    ['ltx', 'application/x-latex'],\n    ['lvp', 'audio/vnd.lucent.voice'],\n    ['lwp', 'application/vnd.lotus-wordpro'],\n    ['lzh', ['application/octet-stream', 'application/x-lzh']],\n    ['lzx', ['application/lzx', 'application/octet-stream', 'application/x-lzx']],\n    ['m', ['text/plain', 'text/x-m']],\n    ['m13', 'application/x-msmediaview'],\n    ['m14', 'application/x-msmediaview'],\n    ['m1v', 'video/mpeg'],\n    ['m21', 'application/mp21'],\n    ['m2a', 'audio/mpeg'],\n    ['m2v', 'video/mpeg'],\n    ['m3u', ['audio/x-mpegurl', 'audio/x-mpequrl']],\n    ['m3u8', 'application/vnd.apple.mpegurl'],\n    ['m4v', 'video/x-m4v'],\n    ['ma', 'application/mathematica'],\n    ['mads', 'application/mads+xml'],\n    ['mag', 'application/vnd.ecowin.chart'],\n    ['man', 'application/x-troff-man'],\n    ['map', 'application/x-navimap'],\n    ['mar', 'text/plain'],\n    ['mathml', 'application/mathml+xml'],\n    ['mbd', 'application/mbedlet'],\n    ['mbk', 'application/vnd.mobius.mbk'],\n    ['mbox', 'application/mbox'],\n    ['mc$', 'application/x-magic-cap-package-1.0'],\n    ['mc1', 'application/vnd.medcalcdata'],\n    ['mcd', ['application/mcad', 'application/vnd.mcd', 'application/x-mathcad']],\n    ['mcf', ['image/vasa', 'text/mcf']],\n    ['mcp', 'application/netmc'],\n    ['mcurl', 'text/vnd.curl.mcurl'],\n    ['mdb', 'application/x-msaccess'],\n    ['mdi', 'image/vnd.ms-modi'],\n    ['me', 'application/x-troff-me'],\n    ['meta4', 'application/metalink4+xml'],\n    ['mets', 'application/mets+xml'],\n    ['mfm', 'application/vnd.mfmp'],\n    ['mgp', 'application/vnd.osgeo.mapguide.package'],\n    ['mgz', 'application/vnd.proteus.magazine'],\n    ['mht', 'message/rfc822'],\n    ['mhtml', 'message/rfc822'],\n    ['mid', ['audio/mid', 'audio/midi', 'music/crescendo', 'x-music/x-midi', 'audio/x-midi', 'application/x-midi', 'audio/x-mid']],\n    ['midi', ['audio/midi', 'music/crescendo', 'x-music/x-midi', 'audio/x-midi', 'application/x-midi', 'audio/x-mid']],\n    ['mif', ['application/vnd.mif', 'application/x-mif', 'application/x-frame']],\n    ['mime', ['message/rfc822', 'www/mime']],\n    ['mj2', 'video/mj2'],\n    ['mjf', 'audio/x-vnd.audioexplosion.mjuicemediafile'],\n    ['mjpg', 'video/x-motion-jpeg'],\n    ['mlp', 'application/vnd.dolby.mlp'],\n    ['mm', ['application/base64', 'application/x-meme']],\n    ['mmd', 'application/vnd.chipnuts.karaoke-mmd'],\n    ['mme', 'application/base64'],\n    ['mmf', 'application/vnd.smaf'],\n    ['mmr', 'image/vnd.fujixerox.edmics-mmr'],\n    ['mny', 'application/x-msmoney'],\n    ['mod', ['audio/mod', 'audio/x-mod']],\n    ['mods', 'application/mods+xml'],\n    ['moov', 'video/quicktime'],\n    ['mov', 'video/quicktime'],\n    ['movie', 'video/x-sgi-movie'],\n    ['mp2', ['video/mpeg', 'audio/mpeg', 'video/x-mpeg', 'audio/x-mpeg', 'video/x-mpeq2a']],\n    ['mp3', ['audio/mpeg', 'audio/mpeg3', 'video/mpeg', 'audio/x-mpeg-3', 'video/x-mpeg']],\n    ['mp4', ['video/mp4', 'application/mp4']],\n    ['mp4a', 'audio/mp4'],\n    ['mpa', ['video/mpeg', 'audio/mpeg']],\n    ['mpc', ['application/vnd.mophun.certificate', 'application/x-project']],\n    ['mpe', 'video/mpeg'],\n    ['mpeg', 'video/mpeg'],\n    ['mpg', ['video/mpeg', 'audio/mpeg']],\n    ['mpga', 'audio/mpeg'],\n    ['mpkg', 'application/vnd.apple.installer+xml'],\n    ['mpm', 'application/vnd.blueice.multipass'],\n    ['mpn', 'application/vnd.mophun.application'],\n    ['mpp', 'application/vnd.ms-project'],\n    ['mpt', 'application/x-project'],\n    ['mpv', 'application/x-project'],\n    ['mpv2', 'video/mpeg'],\n    ['mpx', 'application/x-project'],\n    ['mpy', 'application/vnd.ibm.minipay'],\n    ['mqy', 'application/vnd.mobius.mqy'],\n    ['mrc', 'application/marc'],\n    ['mrcx', 'application/marcxml+xml'],\n    ['ms', 'application/x-troff-ms'],\n    ['mscml', 'application/mediaservercontrol+xml'],\n    ['mseq', 'application/vnd.mseq'],\n    ['msf', 'application/vnd.epson.msf'],\n    ['msg', 'application/vnd.ms-outlook'],\n    ['msh', 'model/mesh'],\n    ['msl', 'application/vnd.mobius.msl'],\n    ['msty', 'application/vnd.muvee.style'],\n    ['mts', 'model/vnd.mts'],\n    ['mus', 'application/vnd.musician'],\n    ['musicxml', 'application/vnd.recordare.musicxml+xml'],\n    ['mv', 'video/x-sgi-movie'],\n    ['mvb', 'application/x-msmediaview'],\n    ['mwf', 'application/vnd.mfer'],\n    ['mxf', 'application/mxf'],\n    ['mxl', 'application/vnd.recordare.musicxml'],\n    ['mxml', 'application/xv+xml'],\n    ['mxs', 'application/vnd.triscape.mxs'],\n    ['mxu', 'video/vnd.mpegurl'],\n    ['my', 'audio/make'],\n    ['mzz', 'application/x-vnd.audioexplosion.mzz'],\n    ['n-gage', 'application/vnd.nokia.n-gage.symbian.install'],\n    ['n3', 'text/n3'],\n    ['nap', 'image/naplps'],\n    ['naplps', 'image/naplps'],\n    ['nbp', 'application/vnd.wolfram.player'],\n    ['nc', 'application/x-netcdf'],\n    ['ncm', 'application/vnd.nokia.configuration-message'],\n    ['ncx', 'application/x-dtbncx+xml'],\n    ['ngdat', 'application/vnd.nokia.n-gage.data'],\n    ['nif', 'image/x-niff'],\n    ['niff', 'image/x-niff'],\n    ['nix', 'application/x-mix-transfer'],\n    ['nlu', 'application/vnd.neurolanguage.nlu'],\n    ['nml', 'application/vnd.enliven'],\n    ['nnd', 'application/vnd.noblenet-directory'],\n    ['nns', 'application/vnd.noblenet-sealer'],\n    ['nnw', 'application/vnd.noblenet-web'],\n    ['npx', 'image/vnd.net-fpx'],\n    ['nsc', 'application/x-conference'],\n    ['nsf', 'application/vnd.lotus-notes'],\n    ['nvd', 'application/x-navidoc'],\n    ['nws', 'message/rfc822'],\n    ['o', 'application/octet-stream'],\n    ['oa2', 'application/vnd.fujitsu.oasys2'],\n    ['oa3', 'application/vnd.fujitsu.oasys3'],\n    ['oas', 'application/vnd.fujitsu.oasys'],\n    ['obd', 'application/x-msbinder'],\n    ['oda', 'application/oda'],\n    ['odb', 'application/vnd.oasis.opendocument.database'],\n    ['odc', 'application/vnd.oasis.opendocument.chart'],\n    ['odf', 'application/vnd.oasis.opendocument.formula'],\n    ['odft', 'application/vnd.oasis.opendocument.formula-template'],\n    ['odg', 'application/vnd.oasis.opendocument.graphics'],\n    ['odi', 'application/vnd.oasis.opendocument.image'],\n    ['odm', 'application/vnd.oasis.opendocument.text-master'],\n    ['odp', 'application/vnd.oasis.opendocument.presentation'],\n    ['ods', 'application/vnd.oasis.opendocument.spreadsheet'],\n    ['odt', 'application/vnd.oasis.opendocument.text'],\n    ['oga', 'audio/ogg'],\n    ['ogv', 'video/ogg'],\n    ['ogx', 'application/ogg'],\n    ['omc', 'application/x-omc'],\n    ['omcd', 'application/x-omcdatamaker'],\n    ['omcr', 'application/x-omcregerator'],\n    ['onetoc', 'application/onenote'],\n    ['opf', 'application/oebps-package+xml'],\n    ['org', 'application/vnd.lotus-organizer'],\n    ['osf', 'application/vnd.yamaha.openscoreformat'],\n    ['osfpvg', 'application/vnd.yamaha.openscoreformat.osfpvg+xml'],\n    ['otc', 'application/vnd.oasis.opendocument.chart-template'],\n    ['otf', 'application/x-font-otf'],\n    ['otg', 'application/vnd.oasis.opendocument.graphics-template'],\n    ['oth', 'application/vnd.oasis.opendocument.text-web'],\n    ['oti', 'application/vnd.oasis.opendocument.image-template'],\n    ['otp', 'application/vnd.oasis.opendocument.presentation-template'],\n    ['ots', 'application/vnd.oasis.opendocument.spreadsheet-template'],\n    ['ott', 'application/vnd.oasis.opendocument.text-template'],\n    ['oxt', 'application/vnd.openofficeorg.extension'],\n    ['p', 'text/x-pascal'],\n    ['p10', ['application/pkcs10', 'application/x-pkcs10']],\n    ['p12', ['application/pkcs-12', 'application/x-pkcs12']],\n    ['p7a', 'application/x-pkcs7-signature'],\n    ['p7b', 'application/x-pkcs7-certificates'],\n    ['p7c', ['application/pkcs7-mime', 'application/x-pkcs7-mime']],\n    ['p7m', ['application/pkcs7-mime', 'application/x-pkcs7-mime']],\n    ['p7r', 'application/x-pkcs7-certreqresp'],\n    ['p7s', ['application/pkcs7-signature', 'application/x-pkcs7-signature']],\n    ['p8', 'application/pkcs8'],\n    ['par', 'text/plain-bas'],\n    ['part', 'application/pro_eng'],\n    ['pas', 'text/pascal'],\n    ['paw', 'application/vnd.pawaafile'],\n    ['pbd', 'application/vnd.powerbuilder6'],\n    ['pbm', 'image/x-portable-bitmap'],\n    ['pcf', 'application/x-font-pcf'],\n    ['pcl', ['application/vnd.hp-pcl', 'application/x-pcl']],\n    ['pclxl', 'application/vnd.hp-pclxl'],\n    ['pct', 'image/x-pict'],\n    ['pcurl', 'application/vnd.curl.pcurl'],\n    ['pcx', 'image/x-pcx'],\n    ['pdb', ['application/vnd.palm', 'chemical/x-pdb']],\n    ['pdf', 'application/pdf'],\n    ['pfa', 'application/x-font-type1'],\n    ['pfr', 'application/font-tdpfr'],\n    ['pfunk', ['audio/make', 'audio/make.my.funk']],\n    ['pfx', 'application/x-pkcs12'],\n    ['pgm', ['image/x-portable-graymap', 'image/x-portable-greymap']],\n    ['pgn', 'application/x-chess-pgn'],\n    ['pgp', 'application/pgp-signature'],\n    ['pic', ['image/pict', 'image/x-pict']],\n    ['pict', 'image/pict'],\n    ['pkg', 'application/x-newton-compatible-pkg'],\n    ['pki', 'application/pkixcmp'],\n    ['pkipath', 'application/pkix-pkipath'],\n    ['pko', ['application/ynd.ms-pkipko', 'application/vnd.ms-pki.pko']],\n    ['pl', ['text/plain', 'text/x-script.perl']],\n    ['plb', 'application/vnd.3gpp.pic-bw-large'],\n    ['plc', 'application/vnd.mobius.plc'],\n    ['plf', 'application/vnd.pocketlearn'],\n    ['pls', 'application/pls+xml'],\n    ['plx', 'application/x-pixclscript'],\n    ['pm', ['text/x-script.perl-module', 'image/x-xpixmap']],\n    ['pm4', 'application/x-pagemaker'],\n    ['pm5', 'application/x-pagemaker'],\n    ['pma', 'application/x-perfmon'],\n    ['pmc', 'application/x-perfmon'],\n    ['pml', ['application/vnd.ctc-posml', 'application/x-perfmon']],\n    ['pmr', 'application/x-perfmon'],\n    ['pmw', 'application/x-perfmon'],\n    ['png', 'image/png'],\n    ['pnm', ['application/x-portable-anymap', 'image/x-portable-anymap']],\n    ['portpkg', 'application/vnd.macports.portpkg'],\n    ['pot', ['application/vnd.ms-powerpoint', 'application/mspowerpoint']],\n    ['potm', 'application/vnd.ms-powerpoint.template.macroenabled.12'],\n    ['potx', 'application/vnd.openxmlformats-officedocument.presentationml.template'],\n    ['pov', 'model/x-pov'],\n    ['ppa', 'application/vnd.ms-powerpoint'],\n    ['ppam', 'application/vnd.ms-powerpoint.addin.macroenabled.12'],\n    ['ppd', 'application/vnd.cups-ppd'],\n    ['ppm', 'image/x-portable-pixmap'],\n    ['pps', ['application/vnd.ms-powerpoint', 'application/mspowerpoint']],\n    ['ppsm', 'application/vnd.ms-powerpoint.slideshow.macroenabled.12'],\n    ['ppsx', 'application/vnd.openxmlformats-officedocument.presentationml.slideshow'],\n    ['ppt', ['application/vnd.ms-powerpoint', 'application/mspowerpoint', 'application/powerpoint', 'application/x-mspowerpoint']],\n    ['pptm', 'application/vnd.ms-powerpoint.presentation.macroenabled.12'],\n    ['pptx', 'application/vnd.openxmlformats-officedocument.presentationml.presentation'],\n    ['ppz', 'application/mspowerpoint'],\n    ['prc', 'application/x-mobipocket-ebook'],\n    ['pre', ['application/vnd.lotus-freelance', 'application/x-freelance']],\n    ['prf', 'application/pics-rules'],\n    ['prt', 'application/pro_eng'],\n    ['ps', 'application/postscript'],\n    ['psb', 'application/vnd.3gpp.pic-bw-small'],\n    ['psd', ['application/octet-stream', 'image/vnd.adobe.photoshop']],\n    ['psf', 'application/x-font-linux-psf'],\n    ['pskcxml', 'application/pskc+xml'],\n    ['ptid', 'application/vnd.pvi.ptid1'],\n    ['pub', 'application/x-mspublisher'],\n    ['pvb', 'application/vnd.3gpp.pic-bw-var'],\n    ['pvu', 'paleovu/x-pv'],\n    ['pwn', 'application/vnd.3m.post-it-notes'],\n    ['pwz', 'application/vnd.ms-powerpoint'],\n    ['py', 'text/x-script.phyton'],\n    ['pya', 'audio/vnd.ms-playready.media.pya'],\n    ['pyc', 'application/x-bytecode.python'],\n    ['pyv', 'video/vnd.ms-playready.media.pyv'],\n    ['qam', 'application/vnd.epson.quickanime'],\n    ['qbo', 'application/vnd.intu.qbo'],\n    ['qcp', 'audio/vnd.qcelp'],\n    ['qd3', 'x-world/x-3dmf'],\n    ['qd3d', 'x-world/x-3dmf'],\n    ['qfx', 'application/vnd.intu.qfx'],\n    ['qif', 'image/x-quicktime'],\n    ['qps', 'application/vnd.publishare-delta-tree'],\n    ['qt', 'video/quicktime'],\n    ['qtc', 'video/x-qtc'],\n    ['qti', 'image/x-quicktime'],\n    ['qtif', 'image/x-quicktime'],\n    ['qxd', 'application/vnd.quark.quarkxpress'],\n    ['ra', ['audio/x-realaudio', 'audio/x-pn-realaudio', 'audio/x-pn-realaudio-plugin']],\n    ['ram', 'audio/x-pn-realaudio'],\n    ['rar', 'application/x-rar-compressed'],\n    ['ras', ['image/cmu-raster', 'application/x-cmu-raster', 'image/x-cmu-raster']],\n    ['rast', 'image/cmu-raster'],\n    ['rcprofile', 'application/vnd.ipunplugged.rcprofile'],\n    ['rdf', 'application/rdf+xml'],\n    ['rdz', 'application/vnd.data-vision.rdz'],\n    ['rep', 'application/vnd.businessobjects'],\n    ['res', 'application/x-dtbresource+xml'],\n    ['rexx', 'text/x-script.rexx'],\n    ['rf', 'image/vnd.rn-realflash'],\n    ['rgb', 'image/x-rgb'],\n    ['rif', 'application/reginfo+xml'],\n    ['rip', 'audio/vnd.rip'],\n    ['rl', 'application/resource-lists+xml'],\n    ['rlc', 'image/vnd.fujixerox.edmics-rlc'],\n    ['rld', 'application/resource-lists-diff+xml'],\n    ['rm', ['application/vnd.rn-realmedia', 'audio/x-pn-realaudio']],\n    ['rmi', 'audio/mid'],\n    ['rmm', 'audio/x-pn-realaudio'],\n    ['rmp', ['audio/x-pn-realaudio-plugin', 'audio/x-pn-realaudio']],\n    ['rms', 'application/vnd.jcp.javame.midlet-rms'],\n    ['rnc', 'application/relax-ng-compact-syntax'],\n    ['rng', ['application/ringing-tones', 'application/vnd.nokia.ringing-tone']],\n    ['rnx', 'application/vnd.rn-realplayer'],\n    ['roff', 'application/x-troff'],\n    ['rp', 'image/vnd.rn-realpix'],\n    ['rp9', 'application/vnd.cloanto.rp9'],\n    ['rpm', 'audio/x-pn-realaudio-plugin'],\n    ['rpss', 'application/vnd.nokia.radio-presets'],\n    ['rpst', 'application/vnd.nokia.radio-preset'],\n    ['rq', 'application/sparql-query'],\n    ['rs', 'application/rls-services+xml'],\n    ['rsd', 'application/rsd+xml'],\n    ['rt', ['text/richtext', 'text/vnd.rn-realtext']],\n    ['rtf', ['application/rtf', 'text/richtext', 'application/x-rtf']],\n    ['rtx', ['text/richtext', 'application/rtf']],\n    ['rv', 'video/vnd.rn-realvideo'],\n    ['s', 'text/x-asm'],\n    ['s3m', 'audio/s3m'],\n    ['saf', 'application/vnd.yamaha.smaf-audio'],\n    ['saveme', 'application/octet-stream'],\n    ['sbk', 'application/x-tbook'],\n    ['sbml', 'application/sbml+xml'],\n    ['sc', 'application/vnd.ibm.secure-container'],\n    ['scd', 'application/x-msschedule'],\n    ['scm', ['application/vnd.lotus-screencam', 'video/x-scm', 'text/x-script.guile', 'application/x-lotusscreencam', 'text/x-script.scheme']],\n    ['scq', 'application/scvp-cv-request'],\n    ['scs', 'application/scvp-cv-response'],\n    ['sct', 'text/scriptlet'],\n    ['scurl', 'text/vnd.curl.scurl'],\n    ['sda', 'application/vnd.stardivision.draw'],\n    ['sdc', 'application/vnd.stardivision.calc'],\n    ['sdd', 'application/vnd.stardivision.impress'],\n    ['sdkm', 'application/vnd.solent.sdkm+xml'],\n    ['sdml', 'text/plain'],\n    ['sdp', ['application/sdp', 'application/x-sdp']],\n    ['sdr', 'application/sounder'],\n    ['sdw', 'application/vnd.stardivision.writer'],\n    ['sea', ['application/sea', 'application/x-sea']],\n    ['see', 'application/vnd.seemail'],\n    ['seed', 'application/vnd.fdsn.seed'],\n    ['sema', 'application/vnd.sema'],\n    ['semd', 'application/vnd.semd'],\n    ['semf', 'application/vnd.semf'],\n    ['ser', 'application/java-serialized-object'],\n    ['set', 'application/set'],\n    ['setpay', 'application/set-payment-initiation'],\n    ['setreg', 'application/set-registration-initiation'],\n    ['sfd-hdstx', 'application/vnd.hydrostatix.sof-data'],\n    ['sfs', 'application/vnd.spotfire.sfs'],\n    ['sgl', 'application/vnd.stardivision.writer-global'],\n    ['sgm', ['text/sgml', 'text/x-sgml']],\n    ['sgml', ['text/sgml', 'text/x-sgml']],\n    ['sh', ['application/x-shar', 'application/x-bsh', 'application/x-sh', 'text/x-script.sh']],\n    ['shar', ['application/x-bsh', 'application/x-shar']],\n    ['shf', 'application/shf+xml'],\n    ['shtml', ['text/html', 'text/x-server-parsed-html']],\n    ['sid', 'audio/x-psid'],\n    ['sis', 'application/vnd.symbian.install'],\n    ['sit', ['application/x-stuffit', 'application/x-sit']],\n    ['sitx', 'application/x-stuffitx'],\n    ['skd', 'application/x-koan'],\n    ['skm', 'application/x-koan'],\n    ['skp', ['application/vnd.koan', 'application/x-koan']],\n    ['skt', 'application/x-koan'],\n    ['sl', 'application/x-seelogo'],\n    ['sldm', 'application/vnd.ms-powerpoint.slide.macroenabled.12'],\n    ['sldx', 'application/vnd.openxmlformats-officedocument.presentationml.slide'],\n    ['slt', 'application/vnd.epson.salt'],\n    ['sm', 'application/vnd.stepmania.stepchart'],\n    ['smf', 'application/vnd.stardivision.math'],\n    ['smi', ['application/smil', 'application/smil+xml']],\n    ['smil', 'application/smil'],\n    ['snd', ['audio/basic', 'audio/x-adpcm']],\n    ['snf', 'application/x-font-snf'],\n    ['sol', 'application/solids'],\n    ['spc', ['text/x-speech', 'application/x-pkcs7-certificates']],\n    ['spf', 'application/vnd.yamaha.smaf-phrase'],\n    ['spl', ['application/futuresplash', 'application/x-futuresplash']],\n    ['spot', 'text/vnd.in3d.spot'],\n    ['spp', 'application/scvp-vp-response'],\n    ['spq', 'application/scvp-vp-request'],\n    ['spr', 'application/x-sprite'],\n    ['sprite', 'application/x-sprite'],\n    ['src', 'application/x-wais-source'],\n    ['sru', 'application/sru+xml'],\n    ['srx', 'application/sparql-results+xml'],\n    ['sse', 'application/vnd.kodak-descriptor'],\n    ['ssf', 'application/vnd.epson.ssf'],\n    ['ssi', 'text/x-server-parsed-html'],\n    ['ssm', 'application/streamingmedia'],\n    ['ssml', 'application/ssml+xml'],\n    ['sst', ['application/vnd.ms-pkicertstore', 'application/vnd.ms-pki.certstore']],\n    ['st', 'application/vnd.sailingtracker.track'],\n    ['stc', 'application/vnd.sun.xml.calc.template'],\n    ['std', 'application/vnd.sun.xml.draw.template'],\n    ['step', 'application/step'],\n    ['stf', 'application/vnd.wt.stf'],\n    ['sti', 'application/vnd.sun.xml.impress.template'],\n    ['stk', 'application/hyperstudio'],\n    ['stl', ['application/vnd.ms-pkistl', 'application/sla', 'application/vnd.ms-pki.stl', 'application/x-navistyle']],\n    ['stm', 'text/html'],\n    ['stp', 'application/step'],\n    ['str', 'application/vnd.pg.format'],\n    ['stw', 'application/vnd.sun.xml.writer.template'],\n    ['sub', 'image/vnd.dvb.subtitle'],\n    ['sus', 'application/vnd.sus-calendar'],\n    ['sv4cpio', 'application/x-sv4cpio'],\n    ['sv4crc', 'application/x-sv4crc'],\n    ['svc', 'application/vnd.dvb.service'],\n    ['svd', 'application/vnd.svd'],\n    ['svf', ['image/vnd.dwg', 'image/x-dwg']],\n    ['svg', 'image/svg+xml'],\n    ['svr', ['x-world/x-svr', 'application/x-world']],\n    ['swf', 'application/x-shockwave-flash'],\n    ['swi', 'application/vnd.aristanetworks.swi'],\n    ['sxc', 'application/vnd.sun.xml.calc'],\n    ['sxd', 'application/vnd.sun.xml.draw'],\n    ['sxg', 'application/vnd.sun.xml.writer.global'],\n    ['sxi', 'application/vnd.sun.xml.impress'],\n    ['sxm', 'application/vnd.sun.xml.math'],\n    ['sxw', 'application/vnd.sun.xml.writer'],\n    ['t', ['text/troff', 'application/x-troff']],\n    ['talk', 'text/x-speech'],\n    ['tao', 'application/vnd.tao.intent-module-archive'],\n    ['tar', 'application/x-tar'],\n    ['tbk', ['application/toolbook', 'application/x-tbook']],\n    ['tcap', 'application/vnd.3gpp2.tcap'],\n    ['tcl', ['text/x-script.tcl', 'application/x-tcl']],\n    ['tcsh', 'text/x-script.tcsh'],\n    ['teacher', 'application/vnd.smart.teacher'],\n    ['tei', 'application/tei+xml'],\n    ['tex', 'application/x-tex'],\n    ['texi', 'application/x-texinfo'],\n    ['texinfo', 'application/x-texinfo'],\n    ['text', ['application/plain', 'text/plain']],\n    ['tfi', 'application/thraud+xml'],\n    ['tfm', 'application/x-tex-tfm'],\n    ['tgz', ['application/gnutar', 'application/x-compressed']],\n    ['thmx', 'application/vnd.ms-officetheme'],\n    ['tif', ['image/tiff', 'image/x-tiff']],\n    ['tiff', ['image/tiff', 'image/x-tiff']],\n    ['tmo', 'application/vnd.tmobile-livetv'],\n    ['torrent', 'application/x-bittorrent'],\n    ['tpl', 'application/vnd.groove-tool-template'],\n    ['tpt', 'application/vnd.trid.tpt'],\n    ['tr', 'application/x-troff'],\n    ['tra', 'application/vnd.trueapp'],\n    ['trm', 'application/x-msterminal'],\n    ['tsd', 'application/timestamped-data'],\n    ['tsi', 'audio/tsp-audio'],\n    ['tsp', ['application/dsptype', 'audio/tsplayer']],\n    ['tsv', 'text/tab-separated-values'],\n    ['ttf', 'application/x-font-ttf'],\n    ['ttl', 'text/turtle'],\n    ['turbot', 'image/florian'],\n    ['twd', 'application/vnd.simtech-mindmapper'],\n    ['txd', 'application/vnd.genomatix.tuxedo'],\n    ['txf', 'application/vnd.mobius.txf'],\n    ['txt', 'text/plain'],\n    ['ufd', 'application/vnd.ufdl'],\n    ['uil', 'text/x-uil'],\n    ['uls', 'text/iuls'],\n    ['umj', 'application/vnd.umajin'],\n    ['uni', 'text/uri-list'],\n    ['unis', 'text/uri-list'],\n    ['unityweb', 'application/vnd.unity'],\n    ['unv', 'application/i-deas'],\n    ['uoml', 'application/vnd.uoml+xml'],\n    ['uri', 'text/uri-list'],\n    ['uris', 'text/uri-list'],\n    ['ustar', ['application/x-ustar', 'multipart/x-ustar']],\n    ['utz', 'application/vnd.uiq.theme'],\n    ['uu', ['application/octet-stream', 'text/x-uuencode']],\n    ['uue', 'text/x-uuencode'],\n    ['uva', 'audio/vnd.dece.audio'],\n    ['uvh', 'video/vnd.dece.hd'],\n    ['uvi', 'image/vnd.dece.graphic'],\n    ['uvm', 'video/vnd.dece.mobile'],\n    ['uvp', 'video/vnd.dece.pd'],\n    ['uvs', 'video/vnd.dece.sd'],\n    ['uvu', 'video/vnd.uvvu.mp4'],\n    ['uvv', 'video/vnd.dece.video'],\n    ['vcd', 'application/x-cdlink'],\n    ['vcf', 'text/x-vcard'],\n    ['vcg', 'application/vnd.groove-vcard'],\n    ['vcs', 'text/x-vcalendar'],\n    ['vcx', 'application/vnd.vcx'],\n    ['vda', 'application/vda'],\n    ['vdo', 'video/vdo'],\n    ['vew', 'application/groupwise'],\n    ['vis', 'application/vnd.visionary'],\n    ['viv', ['video/vivo', 'video/vnd.vivo']],\n    ['vivo', ['video/vivo', 'video/vnd.vivo']],\n    ['vmd', 'application/vocaltec-media-desc'],\n    ['vmf', 'application/vocaltec-media-file'],\n    ['voc', ['audio/voc', 'audio/x-voc']],\n    ['vos', 'video/vosaic'],\n    ['vox', 'audio/voxware'],\n    ['vqe', 'audio/x-twinvq-plugin'],\n    ['vqf', 'audio/x-twinvq'],\n    ['vql', 'audio/x-twinvq-plugin'],\n    ['vrml', ['model/vrml', 'x-world/x-vrml', 'application/x-vrml']],\n    ['vrt', 'x-world/x-vrt'],\n    ['vsd', ['application/vnd.visio', 'application/x-visio']],\n    ['vsf', 'application/vnd.vsf'],\n    ['vst', 'application/x-visio'],\n    ['vsw', 'application/x-visio'],\n    ['vtu', 'model/vnd.vtu'],\n    ['vxml', 'application/voicexml+xml'],\n    ['w60', 'application/wordperfect6.0'],\n    ['w61', 'application/wordperfect6.1'],\n    ['w6w', 'application/msword'],\n    ['wad', 'application/x-doom'],\n    ['wav', ['audio/wav', 'audio/x-wav']],\n    ['wax', 'audio/x-ms-wax'],\n    ['wb1', 'application/x-qpro'],\n    ['wbmp', 'image/vnd.wap.wbmp'],\n    ['wbs', 'application/vnd.criticaltools.wbs+xml'],\n    ['wbxml', 'application/vnd.wap.wbxml'],\n    ['wcm', 'application/vnd.ms-works'],\n    ['wdb', 'application/vnd.ms-works'],\n    ['web', 'application/vnd.xara'],\n    ['weba', 'audio/webm'],\n    ['webm', 'video/webm'],\n    ['webp', 'image/webp'],\n    ['wg', 'application/vnd.pmi.widget'],\n    ['wgt', 'application/widget'],\n    ['wiz', 'application/msword'],\n    ['wk1', 'application/x-123'],\n    ['wks', 'application/vnd.ms-works'],\n    ['wm', 'video/x-ms-wm'],\n    ['wma', 'audio/x-ms-wma'],\n    ['wmd', 'application/x-ms-wmd'],\n    ['wmf', ['windows/metafile', 'application/x-msmetafile']],\n    ['wml', 'text/vnd.wap.wml'],\n    ['wmlc', 'application/vnd.wap.wmlc'],\n    ['wmls', 'text/vnd.wap.wmlscript'],\n    ['wmlsc', 'application/vnd.wap.wmlscriptc'],\n    ['wmv', 'video/x-ms-wmv'],\n    ['wmx', 'video/x-ms-wmx'],\n    ['wmz', 'application/x-ms-wmz'],\n    ['woff', 'application/x-font-woff'],\n    ['word', 'application/msword'],\n    ['wp', 'application/wordperfect'],\n    ['wp5', ['application/wordperfect', 'application/wordperfect6.0']],\n    ['wp6', 'application/wordperfect'],\n    ['wpd', ['application/wordperfect', 'application/vnd.wordperfect', 'application/x-wpwin']],\n    ['wpl', 'application/vnd.ms-wpl'],\n    ['wps', 'application/vnd.ms-works'],\n    ['wq1', 'application/x-lotus'],\n    ['wqd', 'application/vnd.wqd'],\n    ['wri', ['application/mswrite', 'application/x-wri', 'application/x-mswrite']],\n    ['wrl', ['model/vrml', 'x-world/x-vrml', 'application/x-world']],\n    ['wrz', ['model/vrml', 'x-world/x-vrml']],\n    ['wsc', 'text/scriplet'],\n    ['wsdl', 'application/wsdl+xml'],\n    ['wspolicy', 'application/wspolicy+xml'],\n    ['wsrc', 'application/x-wais-source'],\n    ['wtb', 'application/vnd.webturbo'],\n    ['wtk', 'application/x-wintalk'],\n    ['wvx', 'video/x-ms-wvx'],\n    ['x-png', 'image/png'],\n    ['x3d', 'application/vnd.hzn-3d-crossword'],\n    ['xaf', 'x-world/x-vrml'],\n    ['xap', 'application/x-silverlight-app'],\n    ['xar', 'application/vnd.xara'],\n    ['xbap', 'application/x-ms-xbap'],\n    ['xbd', 'application/vnd.fujixerox.docuworks.binder'],\n    ['xbm', ['image/xbm', 'image/x-xbm', 'image/x-xbitmap']],\n    ['xdf', 'application/xcap-diff+xml'],\n    ['xdm', 'application/vnd.syncml.dm+xml'],\n    ['xdp', 'application/vnd.adobe.xdp+xml'],\n    ['xdr', 'video/x-amt-demorun'],\n    ['xdssc', 'application/dssc+xml'],\n    ['xdw', 'application/vnd.fujixerox.docuworks'],\n    ['xenc', 'application/xenc+xml'],\n    ['xer', 'application/patch-ops-error+xml'],\n    ['xfdf', 'application/vnd.adobe.xfdf'],\n    ['xfdl', 'application/vnd.xfdl'],\n    ['xgz', 'xgl/drawing'],\n    ['xhtml', 'application/xhtml+xml'],\n    ['xif', 'image/vnd.xiff'],\n    ['xl', 'application/excel'],\n    ['xla', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],\n    ['xlam', 'application/vnd.ms-excel.addin.macroenabled.12'],\n    ['xlb', ['application/excel', 'application/vnd.ms-excel', 'application/x-excel']],\n    ['xlc', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],\n    ['xld', ['application/excel', 'application/x-excel']],\n    ['xlk', ['application/excel', 'application/x-excel']],\n    ['xll', ['application/excel', 'application/vnd.ms-excel', 'application/x-excel']],\n    ['xlm', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],\n    ['xls', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],\n    ['xlsb', 'application/vnd.ms-excel.sheet.binary.macroenabled.12'],\n    ['xlsm', 'application/vnd.ms-excel.sheet.macroenabled.12'],\n    ['xlsx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'],\n    ['xlt', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],\n    ['xltm', 'application/vnd.ms-excel.template.macroenabled.12'],\n    ['xltx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.template'],\n    ['xlv', ['application/excel', 'application/x-excel']],\n    ['xlw', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],\n    ['xm', 'audio/xm'],\n    ['xml', ['application/xml', 'text/xml', 'application/atom+xml', 'application/rss+xml']],\n    ['xmz', 'xgl/movie'],\n    ['xo', 'application/vnd.olpc-sugar'],\n    ['xof', 'x-world/x-vrml'],\n    ['xop', 'application/xop+xml'],\n    ['xpi', 'application/x-xpinstall'],\n    ['xpix', 'application/x-vnd.ls-xpix'],\n    ['xpm', ['image/xpm', 'image/x-xpixmap']],\n    ['xpr', 'application/vnd.is-xpr'],\n    ['xps', 'application/vnd.ms-xpsdocument'],\n    ['xpw', 'application/vnd.intercon.formnet'],\n    ['xslt', 'application/xslt+xml'],\n    ['xsm', 'application/vnd.syncml+xml'],\n    ['xspf', 'application/xspf+xml'],\n    ['xsr', 'video/x-amt-showrun'],\n    ['xul', 'application/vnd.mozilla.xul+xml'],\n    ['xwd', ['image/x-xwd', 'image/x-xwindowdump']],\n    ['xyz', ['chemical/x-xyz', 'chemical/x-pdb']],\n    ['yang', 'application/yang'],\n    ['yin', 'application/yin+xml'],\n    ['z', ['application/x-compressed', 'application/x-compress']],\n    ['zaz', 'application/vnd.zzazz.deck+xml'],\n    ['zip', ['application/zip', 'multipart/x-zip', 'application/x-zip-compressed', 'application/x-compressed']],\n    ['zir', 'application/vnd.zul'],\n    ['zmm', 'application/vnd.handheld-entertainment+xml'],\n    ['zoo', 'application/octet-stream'],\n    ['zsh', 'text/x-script.zsh']\n]);\n\nmodule.exports = {\n    detectMimeType(filename) {\n        if (!filename) {\n            return defaultMimeType;\n        }\n\n        let parsed = path.parse(filename);\n        let extension = (parsed.ext.substr(1) || parsed.name || '').split('?').shift().trim().toLowerCase();\n        let value = defaultMimeType;\n\n        if (extensions.has(extension)) {\n            value = extensions.get(extension);\n        }\n\n        if (Array.isArray(value)) {\n            return value[0];\n        }\n        return value;\n    },\n\n    detectExtension(mimeType) {\n        if (!mimeType) {\n            return defaultExtension;\n        }\n        let parts = (mimeType || '').toLowerCase().trim().split('/');\n        let rootType = parts.shift().trim();\n        let subType = parts.join('/').trim();\n\n        if (mimeTypes.has(rootType + '/' + subType)) {\n            let value = mimeTypes.get(rootType + '/' + subType);\n            if (Array.isArray(value)) {\n                return value[0];\n            }\n            return value;\n        }\n\n        switch (rootType) {\n            case 'text':\n                return 'txt';\n            default:\n                return 'bin';\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvbWltZS1mdW5jcy9taW1lLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlbWFya2V0Ly4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL21pbWUtZnVuY3MvbWltZS10eXBlcy5qcz9iMGY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBxdW90ZS1wcm9wczogMCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmNvbnN0IGRlZmF1bHRNaW1lVHlwZSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuY29uc3QgZGVmYXVsdEV4dGVuc2lvbiA9ICdiaW4nO1xuXG5jb25zdCBtaW1lVHlwZXMgPSBuZXcgTWFwKFtcbiAgICBbJ2FwcGxpY2F0aW9uL2FjYWQnLCAnZHdnJ10sXG4gICAgWydhcHBsaWNhdGlvbi9hcHBsaXh3YXJlJywgJ2F3J10sXG4gICAgWydhcHBsaWNhdGlvbi9hcmonLCAnYXJqJ10sXG4gICAgWydhcHBsaWNhdGlvbi9hdG9tK3htbCcsICd4bWwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2F0b21jYXQreG1sJywgJ2F0b21jYXQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2F0b21zdmMreG1sJywgJ2F0b21zdmMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2Jhc2U2NCcsIFsnbW0nLCAnbW1lJ11dLFxuICAgIFsnYXBwbGljYXRpb24vYmluaGV4JywgJ2hxeCddLFxuICAgIFsnYXBwbGljYXRpb24vYmluaGV4NCcsICdocXgnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2Jvb2snLCBbJ2Jvb2snLCAnYm9vJ11dLFxuICAgIFsnYXBwbGljYXRpb24vY2N4bWwreG1sLCcsICdjY3htbCddLFxuICAgIFsnYXBwbGljYXRpb24vY2RmJywgJ2NkZiddLFxuICAgIFsnYXBwbGljYXRpb24vY2RtaS1jYXBhYmlsaXR5JywgJ2NkbWlhJ10sXG4gICAgWydhcHBsaWNhdGlvbi9jZG1pLWNvbnRhaW5lcicsICdjZG1pYyddLFxuICAgIFsnYXBwbGljYXRpb24vY2RtaS1kb21haW4nLCAnY2RtaWQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2NkbWktb2JqZWN0JywgJ2NkbWlvJ10sXG4gICAgWydhcHBsaWNhdGlvbi9jZG1pLXF1ZXVlJywgJ2NkbWlxJ10sXG4gICAgWydhcHBsaWNhdGlvbi9jbGFyaXNjYWQnLCAnY2NhZCddLFxuICAgIFsnYXBwbGljYXRpb24vY29tbW9uZ3JvdW5kJywgJ2RwJ10sXG4gICAgWydhcHBsaWNhdGlvbi9jdS1zZWVtZScsICdjdSddLFxuICAgIFsnYXBwbGljYXRpb24vZGF2bW91bnQreG1sJywgJ2Rhdm1vdW50J10sXG4gICAgWydhcHBsaWNhdGlvbi9kcmFmdGluZycsICdkcncnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2RzcHR5cGUnLCAndHNwJ10sXG4gICAgWydhcHBsaWNhdGlvbi9kc3NjK2RlcicsICdkc3NjJ10sXG4gICAgWydhcHBsaWNhdGlvbi9kc3NjK3htbCcsICd4ZHNzYyddLFxuICAgIFsnYXBwbGljYXRpb24vZHhmJywgJ2R4ZiddLFxuICAgIFsnYXBwbGljYXRpb24vZWNtYXNjcmlwdCcsIFsnanMnLCAnZXMnXV0sXG4gICAgWydhcHBsaWNhdGlvbi9lbW1hK3htbCcsICdlbW1hJ10sXG4gICAgWydhcHBsaWNhdGlvbi9lbnZveScsICdldnknXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2VwdWIremlwJywgJ2VwdWInXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2V4Y2VsJywgWyd4bHMnLCAneGwnLCAneGxhJywgJ3hsYicsICd4bGMnLCAneGxkJywgJ3hsaycsICd4bGwnLCAneGxtJywgJ3hsdCcsICd4bHYnLCAneGx3J11dLFxuICAgIFsnYXBwbGljYXRpb24vZXhpJywgJ2V4aSddLFxuICAgIFsnYXBwbGljYXRpb24vZm9udC10ZHBmcicsICdwZnInXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2ZyYWN0YWxzJywgJ2ZpZiddLFxuICAgIFsnYXBwbGljYXRpb24vZnJlZWxvYWRlcicsICdmcmwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2Z1dHVyZXNwbGFzaCcsICdzcGwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2dudXRhcicsICd0Z3onXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2dyb3Vwd2lzZScsICd2ZXcnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2hscCcsICdobHAnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2h0YScsICdodGEnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2h5cGVyc3R1ZGlvJywgJ3N0ayddLFxuICAgIFsnYXBwbGljYXRpb24vaS1kZWFzJywgJ3VudiddLFxuICAgIFsnYXBwbGljYXRpb24vaWdlcycsIFsnaWdlcycsICdpZ3MnXV0sXG4gICAgWydhcHBsaWNhdGlvbi9pbmYnLCAnaW5mJ10sXG4gICAgWydhcHBsaWNhdGlvbi9pbnRlcm5ldC1wcm9wZXJ0eS1zdHJlYW0nLCAnYWN4J10sXG4gICAgWydhcHBsaWNhdGlvbi9pcGZpeCcsICdpcGZpeCddLFxuICAgIFsnYXBwbGljYXRpb24vamF2YScsICdjbGFzcyddLFxuICAgIFsnYXBwbGljYXRpb24vamF2YS1hcmNoaXZlJywgJ2phciddLFxuICAgIFsnYXBwbGljYXRpb24vamF2YS1ieXRlLWNvZGUnLCAnY2xhc3MnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2phdmEtc2VyaWFsaXplZC1vYmplY3QnLCAnc2VyJ10sXG4gICAgWydhcHBsaWNhdGlvbi9qYXZhLXZtJywgJ2NsYXNzJ10sXG4gICAgWydhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JywgJ2pzJ10sXG4gICAgWydhcHBsaWNhdGlvbi9qc29uJywgJ2pzb24nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2xoYScsICdsaGEnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL2x6eCcsICdsengnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL21hYy1iaW5hcnknLCAnYmluJ10sXG4gICAgWydhcHBsaWNhdGlvbi9tYWMtYmluaGV4JywgJ2hxeCddLFxuICAgIFsnYXBwbGljYXRpb24vbWFjLWJpbmhleDQwJywgJ2hxeCddLFxuICAgIFsnYXBwbGljYXRpb24vbWFjLWNvbXBhY3Rwcm8nLCAnY3B0J10sXG4gICAgWydhcHBsaWNhdGlvbi9tYWNiaW5hcnknLCAnYmluJ10sXG4gICAgWydhcHBsaWNhdGlvbi9tYWRzK3htbCcsICdtYWRzJ10sXG4gICAgWydhcHBsaWNhdGlvbi9tYXJjJywgJ21yYyddLFxuICAgIFsnYXBwbGljYXRpb24vbWFyY3htbCt4bWwnLCAnbXJjeCddLFxuICAgIFsnYXBwbGljYXRpb24vbWF0aGVtYXRpY2EnLCAnbWEnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL21hdGhtbCt4bWwnLCAnbWF0aG1sJ10sXG4gICAgWydhcHBsaWNhdGlvbi9tYmVkbGV0JywgJ21iZCddLFxuICAgIFsnYXBwbGljYXRpb24vbWJveCcsICdtYm94J10sXG4gICAgWydhcHBsaWNhdGlvbi9tY2FkJywgJ21jZCddLFxuICAgIFsnYXBwbGljYXRpb24vbWVkaWFzZXJ2ZXJjb250cm9sK3htbCcsICdtc2NtbCddLFxuICAgIFsnYXBwbGljYXRpb24vbWV0YWxpbms0K3htbCcsICdtZXRhNCddLFxuICAgIFsnYXBwbGljYXRpb24vbWV0cyt4bWwnLCAnbWV0cyddLFxuICAgIFsnYXBwbGljYXRpb24vbWltZScsICdhcHMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL21vZHMreG1sJywgJ21vZHMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL21wMjEnLCAnbTIxJ10sXG4gICAgWydhcHBsaWNhdGlvbi9tcDQnLCAnbXA0J10sXG4gICAgWydhcHBsaWNhdGlvbi9tc3Bvd2VycG9pbnQnLCBbJ3BwdCcsICdwb3QnLCAncHBzJywgJ3BweiddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL21zd29yZCcsIFsnZG9jJywgJ2RvdCcsICd3NncnLCAnd2l6JywgJ3dvcmQnXV0sXG4gICAgWydhcHBsaWNhdGlvbi9tc3dyaXRlJywgJ3dyaSddLFxuICAgIFsnYXBwbGljYXRpb24vbXhmJywgJ214ZiddLFxuICAgIFsnYXBwbGljYXRpb24vbmV0bWMnLCAnbWNwJ10sXG4gICAgWydhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLCBbJyonXV0sXG4gICAgWydhcHBsaWNhdGlvbi9vZGEnLCAnb2RhJ10sXG4gICAgWydhcHBsaWNhdGlvbi9vZWJwcy1wYWNrYWdlK3htbCcsICdvcGYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL29nZycsICdvZ3gnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL29sZXNjcmlwdCcsICdheHMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL29uZW5vdGUnLCAnb25ldG9jJ10sXG4gICAgWydhcHBsaWNhdGlvbi9wYXRjaC1vcHMtZXJyb3IreG1sJywgJ3hlciddLFxuICAgIFsnYXBwbGljYXRpb24vcGRmJywgJ3BkZiddLFxuICAgIFsnYXBwbGljYXRpb24vcGdwLWVuY3J5cHRlZCcsICdhc2MnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3BncC1zaWduYXR1cmUnLCAncGdwJ10sXG4gICAgWydhcHBsaWNhdGlvbi9waWNzLXJ1bGVzJywgJ3ByZiddLFxuICAgIFsnYXBwbGljYXRpb24vcGtjcy0xMicsICdwMTInXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3BrY3MtY3JsJywgJ2NybCddLFxuICAgIFsnYXBwbGljYXRpb24vcGtjczEwJywgJ3AxMCddLFxuICAgIFsnYXBwbGljYXRpb24vcGtjczctbWltZScsIFsncDdjJywgJ3A3bSddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3BrY3M3LXNpZ25hdHVyZScsICdwN3MnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3BrY3M4JywgJ3A4J10sXG4gICAgWydhcHBsaWNhdGlvbi9wa2l4LWF0dHItY2VydCcsICdhYyddLFxuICAgIFsnYXBwbGljYXRpb24vcGtpeC1jZXJ0JywgWydjZXInLCAnY3J0J11dLFxuICAgIFsnYXBwbGljYXRpb24vcGtpeC1jcmwnLCAnY3JsJ10sXG4gICAgWydhcHBsaWNhdGlvbi9wa2l4LXBraXBhdGgnLCAncGtpcGF0aCddLFxuICAgIFsnYXBwbGljYXRpb24vcGtpeGNtcCcsICdwa2knXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3BsYWluJywgJ3RleHQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3Bscyt4bWwnLCAncGxzJ10sXG4gICAgWydhcHBsaWNhdGlvbi9wb3N0c2NyaXB0JywgWydwcycsICdhaScsICdlcHMnXV0sXG4gICAgWydhcHBsaWNhdGlvbi9wb3dlcnBvaW50JywgJ3BwdCddLFxuICAgIFsnYXBwbGljYXRpb24vcHJvX2VuZycsIFsncGFydCcsICdwcnQnXV0sXG4gICAgWydhcHBsaWNhdGlvbi9wcnMuY3d3JywgJ2N3dyddLFxuICAgIFsnYXBwbGljYXRpb24vcHNrYyt4bWwnLCAncHNrY3htbCddLFxuICAgIFsnYXBwbGljYXRpb24vcmRmK3htbCcsICdyZGYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3JlZ2luZm8reG1sJywgJ3JpZiddLFxuICAgIFsnYXBwbGljYXRpb24vcmVsYXgtbmctY29tcGFjdC1zeW50YXgnLCAncm5jJ10sXG4gICAgWydhcHBsaWNhdGlvbi9yZXNvdXJjZS1saXN0cyt4bWwnLCAncmwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3Jlc291cmNlLWxpc3RzLWRpZmYreG1sJywgJ3JsZCddLFxuICAgIFsnYXBwbGljYXRpb24vcmluZ2luZy10b25lcycsICdybmcnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3Jscy1zZXJ2aWNlcyt4bWwnLCAncnMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3JzZCt4bWwnLCAncnNkJ10sXG4gICAgWydhcHBsaWNhdGlvbi9yc3MreG1sJywgJ3htbCddLFxuICAgIFsnYXBwbGljYXRpb24vcnRmJywgWydydGYnLCAncnR4J11dLFxuICAgIFsnYXBwbGljYXRpb24vc2JtbCt4bWwnLCAnc2JtbCddLFxuICAgIFsnYXBwbGljYXRpb24vc2N2cC1jdi1yZXF1ZXN0JywgJ3NjcSddLFxuICAgIFsnYXBwbGljYXRpb24vc2N2cC1jdi1yZXNwb25zZScsICdzY3MnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3NjdnAtdnAtcmVxdWVzdCcsICdzcHEnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3NjdnAtdnAtcmVzcG9uc2UnLCAnc3BwJ10sXG4gICAgWydhcHBsaWNhdGlvbi9zZHAnLCAnc2RwJ10sXG4gICAgWydhcHBsaWNhdGlvbi9zZWEnLCAnc2VhJ10sXG4gICAgWydhcHBsaWNhdGlvbi9zZXQnLCAnc2V0J10sXG4gICAgWydhcHBsaWNhdGlvbi9zZXQtcGF5bWVudC1pbml0aWF0aW9uJywgJ3NldHBheSddLFxuICAgIFsnYXBwbGljYXRpb24vc2V0LXJlZ2lzdHJhdGlvbi1pbml0aWF0aW9uJywgJ3NldHJlZyddLFxuICAgIFsnYXBwbGljYXRpb24vc2hmK3htbCcsICdzaGYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3NsYScsICdzdGwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3NtaWwnLCBbJ3NtaScsICdzbWlsJ11dLFxuICAgIFsnYXBwbGljYXRpb24vc21pbCt4bWwnLCAnc21pJ10sXG4gICAgWydhcHBsaWNhdGlvbi9zb2xpZHMnLCAnc29sJ10sXG4gICAgWydhcHBsaWNhdGlvbi9zb3VuZGVyJywgJ3NkciddLFxuICAgIFsnYXBwbGljYXRpb24vc3BhcnFsLXF1ZXJ5JywgJ3JxJ10sXG4gICAgWydhcHBsaWNhdGlvbi9zcGFycWwtcmVzdWx0cyt4bWwnLCAnc3J4J10sXG4gICAgWydhcHBsaWNhdGlvbi9zcmdzJywgJ2dyYW0nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3NyZ3MreG1sJywgJ2dyeG1sJ10sXG4gICAgWydhcHBsaWNhdGlvbi9zcnUreG1sJywgJ3NydSddLFxuICAgIFsnYXBwbGljYXRpb24vc3NtbCt4bWwnLCAnc3NtbCddLFxuICAgIFsnYXBwbGljYXRpb24vc3RlcCcsIFsnc3RlcCcsICdzdHAnXV0sXG4gICAgWydhcHBsaWNhdGlvbi9zdHJlYW1pbmdtZWRpYScsICdzc20nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3RlaSt4bWwnLCAndGVpJ10sXG4gICAgWydhcHBsaWNhdGlvbi90aHJhdWQreG1sJywgJ3RmaSddLFxuICAgIFsnYXBwbGljYXRpb24vdGltZXN0YW1wZWQtZGF0YScsICd0c2QnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3Rvb2xib29rJywgJ3RiayddLFxuICAgIFsnYXBwbGljYXRpb24vdmRhJywgJ3ZkYSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLjNncHAucGljLWJ3LWxhcmdlJywgJ3BsYiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLjNncHAucGljLWJ3LXNtYWxsJywgJ3BzYiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLjNncHAucGljLWJ3LXZhcicsICdwdmInXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC4zZ3BwMi50Y2FwJywgJ3RjYXAnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC4zbS5wb3N0LWl0LW5vdGVzJywgJ3B3biddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmFjY3BhYy5zaW1wbHkuYXNvJywgJ2FzbyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmFjY3BhYy5zaW1wbHkuaW1wJywgJ2ltcCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmFjdWNvYm9sJywgJ2FjdSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmFjdWNvcnAnLCAnYXRjJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuYWRvYmUuYWlyLWFwcGxpY2F0aW9uLWluc3RhbGxlci1wYWNrYWdlK3ppcCcsICdhaXInXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5hZG9iZS5meHAnLCAnZnhwJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuYWRvYmUueGRwK3htbCcsICd4ZHAnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5hZG9iZS54ZmRmJywgJ3hmZGYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5haGVhZC5zcGFjZScsICdhaGVhZCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmFpcnppcC5maWxlc2VjdXJlLmF6ZicsICdhemYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5haXJ6aXAuZmlsZXNlY3VyZS5henMnLCAnYXpzJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuYW1hem9uLmVib29rJywgJ2F6dyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmFtZXJpY2FuZHluYW1pY3MuYWNjJywgJ2FjYyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmFtaWdhLmFtaScsICdhbWknXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5hbmRyb2lkLnBhY2thZ2UtYXJjaGl2ZScsICdhcGsnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5hbnNlci13ZWItY2VydGlmaWNhdGUtaXNzdWUtaW5pdGlhdGlvbicsICdjaWknXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5hbnNlci13ZWItZnVuZHMtdHJhbnNmZXItaW5pdGlhdGlvbicsICdmdGknXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5hbnRpeC5nYW1lLWNvbXBvbmVudCcsICdhdHgnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5pbnN0YWxsZXIreG1sJywgJ21wa2cnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVndXJsJywgJ20zdTgnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5hcmlzdGFuZXR3b3Jrcy5zd2knLCAnc3dpJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuYXVkaW9ncmFwaCcsICdhZXAnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5ibHVlaWNlLm11bHRpcGFzcycsICdtcG0nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5ibWknLCAnYm1pJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuYnVzaW5lc3NvYmplY3RzJywgJ3JlcCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmNoZW1kcmF3K3htbCcsICdjZHhtbCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmNoaXBudXRzLmthcmFva2UtbW1kJywgJ21tZCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmNpbmRlcmVsbGEnLCAnY2R5J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuY2xheW1vcmUnLCAnY2xhJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuY2xvYW50by5ycDknLCAncnA5J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuY2xvbmsuYzRncm91cCcsICdjNGcnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5jbHVldHJ1c3QuY2FydG9tb2JpbGUtY29uZmlnJywgJ2MxMWFtYyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmNsdWV0cnVzdC5jYXJ0b21vYmlsZS1jb25maWctcGtnJywgJ2MxMWFteiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmNvbW1vbnNwYWNlJywgJ2NzcCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmNvbnRhY3QuY21zZycsICdjZGJjbXNnJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuY29zbW9jYWxsZXInLCAnY21jJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlcicsICdjbGt4J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlci5rZXlib2FyZCcsICdjbGtrJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlci5wYWxldHRlJywgJ2Nsa3AnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLnRlbXBsYXRlJywgJ2Nsa3QnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLndvcmRiYW5rJywgJ2Nsa3cnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5jcml0aWNhbHRvb2xzLndicyt4bWwnLCAnd2JzJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuY3RjLXBvc21sJywgJ3BtbCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmN1cHMtcHBkJywgJ3BwZCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmN1cmwuY2FyJywgJ2NhciddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmN1cmwucGN1cmwnLCAncGN1cmwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5kYXRhLXZpc2lvbi5yZHonLCAncmR6J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZGVub3ZvLmZjc2VsYXlvdXQtbGluaycsICdmZV9sYXVuY2gnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5kbmEnLCAnZG5hJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZG9sYnkubWxwJywgJ21scCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmRwZ3JhcGgnLCAnZHBnJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZHJlYW1mYWN0b3J5JywgJ2RmYWMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5kdmIuYWl0JywgJ2FpdCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmR2Yi5zZXJ2aWNlJywgJ3N2YyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmR5bmFnZW8nLCAnZ2VvJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZWNvd2luLmNoYXJ0JywgJ21hZyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmVubGl2ZW4nLCAnbm1sJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZXBzb24uZXNmJywgJ2VzZiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmVwc29uLm1zZicsICdtc2YnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5lcHNvbi5xdWlja2FuaW1lJywgJ3FhbSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmVwc29uLnNhbHQnLCAnc2x0J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZXBzb24uc3NmJywgJ3NzZiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmVzemlnbm8zK3htbCcsICdlczMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5lenBpeC1hbGJ1bScsICdlejInXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5lenBpeC1wYWNrYWdlJywgJ2V6MyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmZkZicsICdmZGYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5mZHNuLnNlZWQnLCAnc2VlZCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmZsb2dyYXBoaXQnLCAnZ3BoJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZmx1eHRpbWUuY2xpcCcsICdmdGMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5mcmFtZW1ha2VyJywgJ2ZtJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZnJvZ2Fucy5mbmMnLCAnZm5jJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZnJvZ2Fucy5sdGYnLCAnbHRmJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZnNjLndlYmxhdW5jaCcsICdmc2MnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzJywgJ29hcyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXMyJywgJ29hMiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXMzJywgJ29hMyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXNncCcsICdmZzUnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzcHJzJywgJ2JoMiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmZ1aml4ZXJveC5kZGQnLCAnZGRkJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZnVqaXhlcm94LmRvY3V3b3JrcycsICd4ZHcnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guZG9jdXdvcmtzLmJpbmRlcicsICd4YmQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5mdXp6eXNoZWV0JywgJ2Z6cyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmdlbm9tYXRpeC50dXhlZG8nLCAndHhkJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZ2VvZ2VicmEuZmlsZScsICdnZ2InXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5nZW9nZWJyYS50b29sJywgJ2dndCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmdlb21ldHJ5LWV4cGxvcmVyJywgJ2dleCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmdlb25leHQnLCAnZ3h0J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZ2VvcGxhbicsICdnMncnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5nZW9zcGFjZScsICdnM3cnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5nbXgnLCAnZ214J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttbCt4bWwnLCAna21sJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmtteicsICdrbXonXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5ncmFmZXEnLCAnZ3FmJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWFjY291bnQnLCAnZ2FjJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWhlbHAnLCAnZ2hmJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWlkZW50aXR5LW1lc3NhZ2UnLCAnZ2ltJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWluamVjdG9yJywgJ2dydiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmdyb292ZS10b29sLW1lc3NhZ2UnLCAnZ3RtJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLXRvb2wtdGVtcGxhdGUnLCAndHBsJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLXZjYXJkJywgJ3ZjZyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmhhbCt4bWwnLCAnaGFsJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuaGFuZGhlbGQtZW50ZXJ0YWlubWVudCt4bWwnLCAnem1tJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuaGJjaScsICdoYmNpJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuaGhlLmxlc3Nvbi1wbGF5ZXInLCAnbGVzJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuaHAtaHBnbCcsIFsnaGdsJywgJ2hwZycsICdocGdsJ11dLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmhwLWhwaWQnLCAnaHBpZCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmhwLWhwcycsICdocHMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5ocC1qbHl0JywgJ2psdCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmhwLXBjbCcsICdwY2wnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5ocC1wY2x4bCcsICdwY2x4bCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmh5ZHJvc3RhdGl4LnNvZi1kYXRhJywgJ3NmZC1oZHN0eCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmh6bi0zZC1jcm9zc3dvcmQnLCAneDNkJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuaWJtLm1pbmlwYXknLCAnbXB5J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuaWJtLm1vZGNhcCcsICdhZnAnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5pYm0ucmlnaHRzLW1hbmFnZW1lbnQnLCAnaXJtJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuaWJtLnNlY3VyZS1jb250YWluZXInLCAnc2MnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5pY2Nwcm9maWxlJywgJ2ljYyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmlnbG9hZGVyJywgJ2lnbCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmltbWVydmlzaW9uLWl2cCcsICdpdnAnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5pbW1lcnZpc2lvbi1pdnUnLCAnaXZ1J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuaW5zb3JzLmlnbScsICdpZ20nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5pbnRlcmNvbi5mb3JtbmV0JywgJ3hwdyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmludGVyZ2VvJywgJ2kyZyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmludHUucWJvJywgJ3FibyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmludHUucWZ4JywgJ3FmeCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmlwdW5wbHVnZ2VkLnJjcHJvZmlsZScsICdyY3Byb2ZpbGUnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5pcmVwb3NpdG9yeS5wYWNrYWdlK3htbCcsICdpcnAnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5pcy14cHInLCAneHByJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuaXNhYy5mY3MnLCAnZmNzJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuamFtJywgJ2phbSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmpjcC5qYXZhbWUubWlkbGV0LXJtcycsICdybXMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5qaXNwJywgJ2ppc3AnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5qb29zdC5qb2RhLWFyY2hpdmUnLCAnam9kYSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmthaG9vdHonLCAna3R6J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQua2RlLmthcmJvbicsICdrYXJib24nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua2NoYXJ0JywgJ2NocnQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua2Zvcm11bGEnLCAna2ZvJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQua2RlLmtpdmlvJywgJ2ZsdyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmtkZS5rb250b3VyJywgJ2tvbiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmtkZS5rcHJlc2VudGVyJywgJ2twciddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmtkZS5rc3ByZWFkJywgJ2tzcCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmtkZS5rd29yZCcsICdrd2QnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5rZW5hbWVhYXBwJywgJ2h0a2UnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5raWRzcGlyYXRpb24nLCAna2lhJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQua2luYXInLCAna25lJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQua29hbicsICdza3AnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5rb2Rhay1kZXNjcmlwdG9yJywgJ3NzZSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmxhcy5sYXMreG1sJywgJ2xhc3htbCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmxsYW1hZ3JhcGhpY3MubGlmZS1iYWxhbmNlLmRlc2t0b3AnLCAnbGJkJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubGxhbWFncmFwaGljcy5saWZlLWJhbGFuY2UuZXhjaGFuZ2UreG1sJywgJ2xiZSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmxvdHVzLTEtMi0zJywgJzEyMyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmxvdHVzLWFwcHJvYWNoJywgJ2FwciddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmxvdHVzLWZyZWVsYW5jZScsICdwcmUnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy1ub3RlcycsICduc2YnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy1vcmdhbml6ZXInLCAnb3JnJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubG90dXMtc2NyZWVuY2FtJywgJ3NjbSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLmxvdHVzLXdvcmRwcm8nLCAnbHdwJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubWFjcG9ydHMucG9ydHBrZycsICdwb3J0cGtnJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubWNkJywgJ21jZCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1lZGNhbGNkYXRhJywgJ21jMSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1lZGlhc3RhdGlvbi5jZGtleScsICdjZGtleSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1mZXInLCAnbXdmJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubWZtcCcsICdtZm0nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5taWNyb2dyYWZ4LmZsbycsICdmbG8nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5taWNyb2dyYWZ4LmlneCcsICdpZ3gnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5taWYnLCAnbWlmJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubW9iaXVzLmRhZicsICdkYWYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMuZGlzJywgJ2RpcyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1vYml1cy5tYmsnLCAnbWJrJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubW9iaXVzLm1xeScsICdtcXknXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMubXNsJywgJ21zbCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1vYml1cy5wbGMnLCAncGxjJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubW9iaXVzLnR4ZicsICd0eGYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tb3BodW4uYXBwbGljYXRpb24nLCAnbXBuJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubW9waHVuLmNlcnRpZmljYXRlJywgJ21wYyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1vemlsbGEueHVsK3htbCcsICd4dWwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1hcnRnYWxyeScsICdjaWwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1jYWItY29tcHJlc3NlZCcsICdjYWInXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsIFsneGxzJywgJ3hsYScsICd4bGMnLCAneGxtJywgJ3hsdCcsICd4bHcnLCAneGxiJywgJ3hsbCddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5hZGRpbi5tYWNyb2VuYWJsZWQuMTInLCAneGxhbSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnNoZWV0LmJpbmFyeS5tYWNyb2VuYWJsZWQuMTInLCAneGxzYiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnNoZWV0Lm1hY3JvZW5hYmxlZC4xMicsICd4bHNtJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyJywgJ3hsdG0nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0JywgJ2VvdCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1zLWh0bWxoZWxwJywgJ2NobSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1zLWltcycsICdpbXMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1scm0nLCAnbHJtJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubXMtb2ZmaWNldGhlbWUnLCAndGhteCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1zLW91dGxvb2snLCAnbXNnJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubXMtcGtpLmNlcnRzdG9yZScsICdzc3QnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wa2kucGtvJywgJ3BrbyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1zLXBraS5zZWNjYXQnLCAnY2F0J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubXMtcGtpLnN0bCcsICdzdGwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wa2ljZXJ0c3RvcmUnLCAnc3N0J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubXMtcGtpc2VjY2F0JywgJ2NhdCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1zLXBraXN0bCcsICdzdGwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50JywgWydwcHQnLCAncG90JywgJ3BwcycsICdwcGEnLCAncHd6J11dLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQuYWRkaW4ubWFjcm9lbmFibGVkLjEyJywgJ3BwYW0nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnByZXNlbnRhdGlvbi5tYWNyb2VuYWJsZWQuMTInLCAncHB0bSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQuc2xpZGUubWFjcm9lbmFibGVkLjEyJywgJ3NsZG0nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnNsaWRlc2hvdy5tYWNyb2VuYWJsZWQuMTInLCAncHBzbSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyJywgJ3BvdG0nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wcm9qZWN0JywgJ21wcCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm1zLXdvcmQuZG9jdW1lbnQubWFjcm9lbmFibGVkLjEyJywgJ2RvY20nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy13b3JkLnRlbXBsYXRlLm1hY3JvZW5hYmxlZC4xMicsICdkb3RtJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubXMtd29ya3MnLCBbJ3drcycsICd3Y20nLCAnd2RiJywgJ3dwcyddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy13cGwnLCAnd3BsJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubXMteHBzZG9jdW1lbnQnLCAneHBzJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubXNlcScsICdtc2VxJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubXVzaWNpYW4nLCAnbXVzJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubXV2ZWUuc3R5bGUnLCAnbXN0eSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm5ldXJvbGFuZ3VhZ2Uubmx1JywgJ25sdSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm5vYmxlbmV0LWRpcmVjdG9yeScsICdubmQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5ub2JsZW5ldC1zZWFsZXInLCAnbm5zJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubm9ibGVuZXQtd2ViJywgJ25udyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm5va2lhLmNvbmZpZ3VyYXRpb24tbWVzc2FnZScsICduY20nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5uLWdhZ2UuZGF0YScsICduZ2RhdCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm5va2lhLm4tZ2FnZS5zeW1iaWFuLmluc3RhbGwnLCAnbi1nYWdlJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubm9raWEucmFkaW8tcHJlc2V0JywgJ3Jwc3QnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5yYWRpby1wcmVzZXRzJywgJ3Jwc3MnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5yaW5naW5nLXRvbmUnLCAncm5nJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQubm92YWRpZ20uZWRtJywgJ2VkbSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm5vdmFkaWdtLmVkeCcsICdlZHgnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5ub3ZhZGlnbS5leHQnLCAnZXh0J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmNoYXJ0JywgJ29kYyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5jaGFydC10ZW1wbGF0ZScsICdvdGMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZGF0YWJhc2UnLCAnb2RiJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmZvcm11bGEnLCAnb2RmJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmZvcm11bGEtdGVtcGxhdGUnLCAnb2RmdCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5ncmFwaGljcycsICdvZGcnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZ3JhcGhpY3MtdGVtcGxhdGUnLCAnb3RnJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmltYWdlJywgJ29kaSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5pbWFnZS10ZW1wbGF0ZScsICdvdGknXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uJywgJ29kcCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5wcmVzZW50YXRpb24tdGVtcGxhdGUnLCAnb3RwJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnNwcmVhZHNoZWV0JywgJ29kcyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldC10ZW1wbGF0ZScsICdvdHMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dCcsICdvZHQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dC1tYXN0ZXInLCAnb2RtJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQtdGVtcGxhdGUnLCAnb3R0J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQtd2ViJywgJ290aCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm9scGMtc3VnYXInLCAneG8nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vbWEuZGQyK3htbCcsICdkZDInXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vcGVub2ZmaWNlb3JnLmV4dGVuc2lvbicsICdveHQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzZW50YXRpb24nLCAncHB0eCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlJywgJ3NsZHgnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZXNob3cnLCAncHBzeCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnRlbXBsYXRlJywgJ3BvdHgnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0JywgJ3hsc3gnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnRlbXBsYXRlJywgJ3hsdHgnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50JywgJ2RvY3gnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnRlbXBsYXRlJywgJ2RvdHgnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5vc2dlby5tYXBndWlkZS5wYWNrYWdlJywgJ21ncCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLm9zZ2kuZHAnLCAnZHAnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5wYWxtJywgJ3BkYiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnBhd2FhZmlsZScsICdwYXcnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5wZy5mb3JtYXQnLCAnc3RyJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQucGcub3Nhc2xpJywgJ2VpNiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnBpY3NlbCcsICdlZmlmJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQucG1pLndpZGdldCcsICd3ZyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnBvY2tldGxlYXJuJywgJ3BsZiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnBvd2VyYnVpbGRlcjYnLCAncGJkJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQucHJldmlld3N5c3RlbXMuYm94JywgJ2JveCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnByb3RldXMubWFnYXppbmUnLCAnbWd6J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQucHVibGlzaGFyZS1kZWx0YS10cmVlJywgJ3FwcyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnB2aS5wdGlkMScsICdwdGlkJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQucXVhcmsucXVhcmt4cHJlc3MnLCAncXhkJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQucmVhbHZuYy5iZWQnLCAnYmVkJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQucmVjb3JkYXJlLm11c2ljeG1sJywgJ214bCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnJlY29yZGFyZS5tdXNpY3htbCt4bWwnLCAnbXVzaWN4bWwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5yaWcuY3J5cHRvbm90ZScsICdjcnlwdG9ub3RlJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQucmltLmNvZCcsICdjb2QnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5ybi1yZWFsbWVkaWEnLCAncm0nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5ybi1yZWFscGxheWVyJywgJ3JueCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnJvdXRlNjYubGluazY2K3htbCcsICdsaW5rNjYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5zYWlsaW5ndHJhY2tlci50cmFjaycsICdzdCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnNlZW1haWwnLCAnc2VlJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc2VtYScsICdzZW1hJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc2VtZCcsICdzZW1kJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc2VtZicsICdzZW1mJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc2hhbmEuaW5mb3JtZWQuZm9ybWRhdGEnLCAnaWZtJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc2hhbmEuaW5mb3JtZWQuZm9ybXRlbXBsYXRlJywgJ2l0cCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLmludGVyY2hhbmdlJywgJ2lpZiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLnBhY2thZ2UnLCAnaXBrJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc2ltdGVjaC1taW5kbWFwcGVyJywgJ3R3ZCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnNtYWYnLCAnbW1mJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc21hcnQudGVhY2hlcicsICd0ZWFjaGVyJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc29sZW50LnNka20reG1sJywgJ3Nka20nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5zcG90ZmlyZS5keHAnLCAnZHhwJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc3BvdGZpcmUuc2ZzJywgJ3NmcyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi5jYWxjJywgJ3NkYyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi5kcmF3JywgJ3NkYSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi5pbXByZXNzJywgJ3NkZCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi5tYXRoJywgJ3NtZiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi53cml0ZXInLCAnc2R3J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLndyaXRlci1nbG9iYWwnLCAnc2dsJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc3RlcG1hbmlhLnN0ZXBjaGFydCcsICdzbSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnN1bi54bWwuY2FsYycsICdzeGMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmNhbGMudGVtcGxhdGUnLCAnc3RjJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5kcmF3JywgJ3N4ZCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnN1bi54bWwuZHJhdy50ZW1wbGF0ZScsICdzdGQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmltcHJlc3MnLCAnc3hpJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5pbXByZXNzLnRlbXBsYXRlJywgJ3N0aSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnN1bi54bWwubWF0aCcsICdzeG0nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLndyaXRlcicsICdzeHcnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLndyaXRlci5nbG9iYWwnLCAnc3hnJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC53cml0ZXIudGVtcGxhdGUnLCAnc3R3J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc3VzLWNhbGVuZGFyJywgJ3N1cyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnN2ZCcsICdzdmQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5zeW1iaWFuLmluc3RhbGwnLCAnc2lzJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc3luY21sK3htbCcsICd4c20nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC5zeW5jbWwuZG0rd2J4bWwnLCAnYmRtJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtK3htbCcsICd4ZG0nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC50YW8uaW50ZW50LW1vZHVsZS1hcmNoaXZlJywgJ3RhbyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnRtb2JpbGUtbGl2ZXR2JywgJ3RtbyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnRyaWQudHB0JywgJ3RwdCddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnRyaXNjYXBlLm14cycsICdteHMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC50cnVlYXBwJywgJ3RyYSddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnVmZGwnLCAndWZkJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQudWlxLnRoZW1lJywgJ3V0eiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnVtYWppbicsICd1bWonXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC51bml0eScsICd1bml0eXdlYiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnVvbWwreG1sJywgJ3VvbWwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC52Y3gnLCAndmN4J10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQudmlzaW8nLCAndnNkJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQudmlzaW9uYXJ5JywgJ3ZpcyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnZzZicsICd2c2YnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC53YXAud2J4bWwnLCAnd2J4bWwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC53YXAud21sYycsICd3bWxjJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQud2FwLndtbHNjcmlwdGMnLCAnd21sc2MnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC53ZWJ0dXJibycsICd3dGInXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC53b2xmcmFtLnBsYXllcicsICduYnAnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC53b3JkcGVyZmVjdCcsICd3cGQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC53cWQnLCAnd3FkJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQud3Quc3RmJywgJ3N0ZiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnhhcmEnLCBbJ3dlYicsICd4YXInXV0sXG4gICAgWydhcHBsaWNhdGlvbi92bmQueGZkbCcsICd4ZmRsJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQueWFtYWhhLmh2LWRpYycsICdodmQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC55YW1haGEuaHYtc2NyaXB0JywgJ2h2cyddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5odi12b2ljZScsICdodnAnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC55YW1haGEub3BlbnNjb3JlZm9ybWF0JywgJ29zZiddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5vcGVuc2NvcmVmb3JtYXQub3NmcHZnK3htbCcsICdvc2ZwdmcnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC55YW1haGEuc21hZi1hdWRpbycsICdzYWYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZuZC55YW1haGEuc21hZi1waHJhc2UnLCAnc3BmJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQueWVsbG93cml2ZXItY3VzdG9tLW1lbnUnLCAnY21wJ10sXG4gICAgWydhcHBsaWNhdGlvbi92bmQuenVsJywgJ3ppciddLFxuICAgIFsnYXBwbGljYXRpb24vdm5kLnp6YXp6LmRlY2sreG1sJywgJ3pheiddLFxuICAgIFsnYXBwbGljYXRpb24vdm9jYWx0ZWMtbWVkaWEtZGVzYycsICd2bWQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ZvY2FsdGVjLW1lZGlhLWZpbGUnLCAndm1mJ10sXG4gICAgWydhcHBsaWNhdGlvbi92b2ljZXhtbCt4bWwnLCAndnhtbCddLFxuICAgIFsnYXBwbGljYXRpb24vd2lkZ2V0JywgJ3dndCddLFxuICAgIFsnYXBwbGljYXRpb24vd2luaGxwJywgJ2hscCddLFxuICAgIFsnYXBwbGljYXRpb24vd29yZHBlcmZlY3QnLCBbJ3dwJywgJ3dwNScsICd3cDYnLCAnd3BkJ11dLFxuICAgIFsnYXBwbGljYXRpb24vd29yZHBlcmZlY3Q2LjAnLCBbJ3c2MCcsICd3cDUnXV0sXG4gICAgWydhcHBsaWNhdGlvbi93b3JkcGVyZmVjdDYuMScsICd3NjEnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3dzZGwreG1sJywgJ3dzZGwnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3dzcG9saWN5K3htbCcsICd3c3BvbGljeSddLFxuICAgIFsnYXBwbGljYXRpb24veC0xMjMnLCAnd2sxJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LTd6LWNvbXByZXNzZWQnLCAnN3onXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtYWJpd29yZCcsICdhYncnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtYWNlLWNvbXByZXNzZWQnLCAnYWNlJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWFpbScsICdhaW0nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtYXV0aG9yd2FyZS1iaW4nLCAnYWFiJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWF1dGhvcndhcmUtbWFwJywgJ2FhbSddLFxuICAgIFsnYXBwbGljYXRpb24veC1hdXRob3J3YXJlLXNlZycsICdhYXMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtYmNwaW8nLCAnYmNwaW8nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtYmluYXJ5JywgJ2JpbiddLFxuICAgIFsnYXBwbGljYXRpb24veC1iaW5oZXg0MCcsICdocXgnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtYml0dG9ycmVudCcsICd0b3JyZW50J10sXG4gICAgWydhcHBsaWNhdGlvbi94LWJzaCcsIFsnYnNoJywgJ3NoJywgJ3NoYXInXV0sXG4gICAgWydhcHBsaWNhdGlvbi94LWJ5dGVjb2RlLmVsaXNwJywgJ2VsYyddLFxuICAgIFsnYXBwbGljYXRpb24veC1ieXRlY29kZS5weXRob24nLCAncHljJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWJ6aXAnLCAnYnonXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtYnppcDInLCBbJ2JveicsICdiejInXV0sXG4gICAgWydhcHBsaWNhdGlvbi94LWNkZicsICdjZGYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtY2RsaW5rJywgJ3ZjZCddLFxuICAgIFsnYXBwbGljYXRpb24veC1jaGF0JywgWydjaGEnLCAnY2hhdCddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtY2hlc3MtcGduJywgJ3BnbiddLFxuICAgIFsnYXBwbGljYXRpb24veC1jbXUtcmFzdGVyJywgJ3JhcyddLFxuICAgIFsnYXBwbGljYXRpb24veC1jb2NvYScsICdjY28nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtY29tcGFjdHBybycsICdjcHQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtY29tcHJlc3MnLCAneiddLFxuICAgIFsnYXBwbGljYXRpb24veC1jb21wcmVzc2VkJywgWyd0Z3onLCAnZ3onLCAneicsICd6aXAnXV0sXG4gICAgWydhcHBsaWNhdGlvbi94LWNvbmZlcmVuY2UnLCAnbnNjJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWNwaW8nLCAnY3BpbyddLFxuICAgIFsnYXBwbGljYXRpb24veC1jcHQnLCAnY3B0J10sXG4gICAgWydhcHBsaWNhdGlvbi94LWNzaCcsICdjc2gnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtZGViaWFuLXBhY2thZ2UnLCAnZGViJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWRlZXB2JywgJ2RlZXB2J10sXG4gICAgWydhcHBsaWNhdGlvbi94LWRpcmVjdG9yJywgWydkaXInLCAnZGNyJywgJ2R4ciddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtZG9vbScsICd3YWQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtZHRibmN4K3htbCcsICduY3gnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtZHRib29rK3htbCcsICdkdGInXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtZHRicmVzb3VyY2UreG1sJywgJ3JlcyddLFxuICAgIFsnYXBwbGljYXRpb24veC1kdmknLCAnZHZpJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWVsYycsICdlbGMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtZW52b3knLCBbJ2VudicsICdldnknXV0sXG4gICAgWydhcHBsaWNhdGlvbi94LWVzcmVoYmVyJywgJ2VzJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWV4Y2VsJywgWyd4bHMnLCAneGxhJywgJ3hsYicsICd4bGMnLCAneGxkJywgJ3hsaycsICd4bGwnLCAneGxtJywgJ3hsdCcsICd4bHYnLCAneGx3J11dLFxuICAgIFsnYXBwbGljYXRpb24veC1mb250LWJkZicsICdiZGYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtZm9udC1naG9zdHNjcmlwdCcsICdnc2YnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtZm9udC1saW51eC1wc2YnLCAncHNmJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWZvbnQtb3RmJywgJ290ZiddLFxuICAgIFsnYXBwbGljYXRpb24veC1mb250LXBjZicsICdwY2YnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtZm9udC1zbmYnLCAnc25mJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWZvbnQtdHRmJywgJ3R0ZiddLFxuICAgIFsnYXBwbGljYXRpb24veC1mb250LXR5cGUxJywgJ3BmYSddLFxuICAgIFsnYXBwbGljYXRpb24veC1mb250LXdvZmYnLCAnd29mZiddLFxuICAgIFsnYXBwbGljYXRpb24veC1mcmFtZScsICdtaWYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtZnJlZWxhbmNlJywgJ3ByZSddLFxuICAgIFsnYXBwbGljYXRpb24veC1mdXR1cmVzcGxhc2gnLCAnc3BsJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWdudW1lcmljJywgJ2dudW1lcmljJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWdzcCcsICdnc3AnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtZ3NzJywgJ2dzcyddLFxuICAgIFsnYXBwbGljYXRpb24veC1ndGFyJywgJ2d0YXInXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtZ3ppcCcsIFsnZ3onLCAnZ3ppcCddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtaGRmJywgJ2hkZiddLFxuICAgIFsnYXBwbGljYXRpb24veC1oZWxwZmlsZScsIFsnaGVscCcsICdobHAnXV0sXG4gICAgWydhcHBsaWNhdGlvbi94LWh0dHBkLWltYXAnLCAnaW1hcCddLFxuICAgIFsnYXBwbGljYXRpb24veC1pbWEnLCAnaW1hJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWludGVybmV0LXNpZ251cCcsIFsnaW5zJywgJ2lzcCddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtaW50ZXJuZXR0LXNpZ251cCcsICdpbnMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtaW52ZW50b3InLCAnaXYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtaXAyJywgJ2lwJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWlwaG9uZScsICdpaWknXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtamF2YS1jbGFzcycsICdjbGFzcyddLFxuICAgIFsnYXBwbGljYXRpb24veC1qYXZhLWNvbW1lcmNlJywgJ2pjbSddLFxuICAgIFsnYXBwbGljYXRpb24veC1qYXZhLWpubHAtZmlsZScsICdqbmxwJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWphdmFzY3JpcHQnLCAnanMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gta29hbicsIFsnc2tkJywgJ3NrbScsICdza3AnLCAnc2t0J11dLFxuICAgIFsnYXBwbGljYXRpb24veC1rc2gnLCAna3NoJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWxhdGV4JywgWydsYXRleCcsICdsdHgnXV0sXG4gICAgWydhcHBsaWNhdGlvbi94LWxoYScsICdsaGEnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbGlzcCcsICdsc3AnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbGl2ZXNjcmVlbicsICdpdnknXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbG90dXMnLCAnd3ExJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWxvdHVzc2NyZWVuY2FtJywgJ3NjbSddLFxuICAgIFsnYXBwbGljYXRpb24veC1semgnLCAnbHpoJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LWx6eCcsICdsengnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbWFjLWJpbmhleDQwJywgJ2hxeCddLFxuICAgIFsnYXBwbGljYXRpb24veC1tYWNiaW5hcnknLCAnYmluJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LW1hZ2ljLWNhcC1wYWNrYWdlLTEuMCcsICdtYyQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbWF0aGNhZCcsICdtY2QnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbWVtZScsICdtbSddLFxuICAgIFsnYXBwbGljYXRpb24veC1taWRpJywgWydtaWQnLCAnbWlkaSddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbWlmJywgJ21pZiddLFxuICAgIFsnYXBwbGljYXRpb24veC1taXgtdHJhbnNmZXInLCAnbml4J10sXG4gICAgWydhcHBsaWNhdGlvbi94LW1vYmlwb2NrZXQtZWJvb2snLCAncHJjJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LW1wbGF5ZXIyJywgJ2FzeCddLFxuICAgIFsnYXBwbGljYXRpb24veC1tcy1hcHBsaWNhdGlvbicsICdhcHBsaWNhdGlvbiddLFxuICAgIFsnYXBwbGljYXRpb24veC1tcy13bWQnLCAnd21kJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LW1zLXdteicsICd3bXonXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbXMteGJhcCcsICd4YmFwJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LW1zYWNjZXNzJywgJ21kYiddLFxuICAgIFsnYXBwbGljYXRpb24veC1tc2JpbmRlcicsICdvYmQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbXNjYXJkZmlsZScsICdjcmQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbXNjbGlwJywgJ2NscCddLFxuICAgIFsnYXBwbGljYXRpb24veC1tc2Rvd25sb2FkJywgWydleGUnLCAnZGxsJ11dLFxuICAgIFsnYXBwbGljYXRpb24veC1tc2V4Y2VsJywgWyd4bHMnLCAneGxhJywgJ3hsdyddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbXNtZWRpYXZpZXcnLCBbJ212YicsICdtMTMnLCAnbTE0J11dLFxuICAgIFsnYXBwbGljYXRpb24veC1tc21ldGFmaWxlJywgJ3dtZiddLFxuICAgIFsnYXBwbGljYXRpb24veC1tc21vbmV5JywgJ21ueSddLFxuICAgIFsnYXBwbGljYXRpb24veC1tc3Bvd2VycG9pbnQnLCAncHB0J10sXG4gICAgWydhcHBsaWNhdGlvbi94LW1zcHVibGlzaGVyJywgJ3B1YiddLFxuICAgIFsnYXBwbGljYXRpb24veC1tc3NjaGVkdWxlJywgJ3NjZCddLFxuICAgIFsnYXBwbGljYXRpb24veC1tc3Rlcm1pbmFsJywgJ3RybSddLFxuICAgIFsnYXBwbGljYXRpb24veC1tc3dyaXRlJywgJ3dyaSddLFxuICAgIFsnYXBwbGljYXRpb24veC1uYXZpLWFuaW1hdGlvbicsICdhbmknXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbmF2aWRvYycsICdudmQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbmF2aW1hcCcsICdtYXAnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbmF2aXN0eWxlJywgJ3N0bCddLFxuICAgIFsnYXBwbGljYXRpb24veC1uZXRjZGYnLCBbJ2NkZicsICduYyddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtbmV3dG9uLWNvbXBhdGlibGUtcGtnJywgJ3BrZyddLFxuICAgIFsnYXBwbGljYXRpb24veC1ub2tpYS05MDAwLWNvbW11bmljYXRvci1hZGQtb24tc29mdHdhcmUnLCAnYW9zJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LW9tYycsICdvbWMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtb21jZGF0YW1ha2VyJywgJ29tY2QnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtb21jcmVnZXJhdG9yJywgJ29tY3InXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtcGFnZW1ha2VyJywgWydwbTQnLCAncG01J11dLFxuICAgIFsnYXBwbGljYXRpb24veC1wY2wnLCAncGNsJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LXBlcmZtb24nLCBbJ3BtYScsICdwbWMnLCAncG1sJywgJ3BtcicsICdwbXcnXV0sXG4gICAgWydhcHBsaWNhdGlvbi94LXBpeGNsc2NyaXB0JywgJ3BseCddLFxuICAgIFsnYXBwbGljYXRpb24veC1wa2NzMTAnLCAncDEwJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LXBrY3MxMicsIFsncDEyJywgJ3BmeCddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtcGtjczctY2VydGlmaWNhdGVzJywgWydwN2InLCAnc3BjJ11dLFxuICAgIFsnYXBwbGljYXRpb24veC1wa2NzNy1jZXJ0cmVxcmVzcCcsICdwN3InXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtcGtjczctbWltZScsIFsncDdtJywgJ3A3YyddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtcGtjczctc2lnbmF0dXJlJywgWydwN3MnLCAncDdhJ11dLFxuICAgIFsnYXBwbGljYXRpb24veC1wb2ludHBsdXMnLCAnY3NzJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LXBvcnRhYmxlLWFueW1hcCcsICdwbm0nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtcHJvamVjdCcsIFsnbXBjJywgJ21wdCcsICdtcHYnLCAnbXB4J11dLFxuICAgIFsnYXBwbGljYXRpb24veC1xcHJvJywgJ3diMSddLFxuICAgIFsnYXBwbGljYXRpb24veC1yYXItY29tcHJlc3NlZCcsICdyYXInXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtcnRmJywgJ3J0ZiddLFxuICAgIFsnYXBwbGljYXRpb24veC1zZHAnLCAnc2RwJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LXNlYScsICdzZWEnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtc2VlbG9nbycsICdzbCddLFxuICAgIFsnYXBwbGljYXRpb24veC1zaCcsICdzaCddLFxuICAgIFsnYXBwbGljYXRpb24veC1zaGFyJywgWydzaGFyJywgJ3NoJ11dLFxuICAgIFsnYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnLCAnc3dmJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LXNpbHZlcmxpZ2h0LWFwcCcsICd4YXAnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtc2l0JywgJ3NpdCddLFxuICAgIFsnYXBwbGljYXRpb24veC1zcHJpdGUnLCBbJ3NwcicsICdzcHJpdGUnXV0sXG4gICAgWydhcHBsaWNhdGlvbi94LXN0dWZmaXQnLCAnc2l0J10sXG4gICAgWydhcHBsaWNhdGlvbi94LXN0dWZmaXR4JywgJ3NpdHgnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtc3Y0Y3BpbycsICdzdjRjcGlvJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LXN2NGNyYycsICdzdjRjcmMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtdGFyJywgJ3RhciddLFxuICAgIFsnYXBwbGljYXRpb24veC10Ym9vaycsIFsnc2JrJywgJ3RiayddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtdGNsJywgJ3RjbCddLFxuICAgIFsnYXBwbGljYXRpb24veC10ZXgnLCAndGV4J10sXG4gICAgWydhcHBsaWNhdGlvbi94LXRleC10Zm0nLCAndGZtJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LXRleGluZm8nLCBbJ3RleGknLCAndGV4aW5mbyddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtdHJvZmYnLCBbJ3JvZmYnLCAndCcsICd0ciddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtdHJvZmYtbWFuJywgJ21hbiddLFxuICAgIFsnYXBwbGljYXRpb24veC10cm9mZi1tZScsICdtZSddLFxuICAgIFsnYXBwbGljYXRpb24veC10cm9mZi1tcycsICdtcyddLFxuICAgIFsnYXBwbGljYXRpb24veC10cm9mZi1tc3ZpZGVvJywgJ2F2aSddLFxuICAgIFsnYXBwbGljYXRpb24veC11c3RhcicsICd1c3RhciddLFxuICAgIFsnYXBwbGljYXRpb24veC12aXNpbycsIFsndnNkJywgJ3ZzdCcsICd2c3cnXV0sXG4gICAgWydhcHBsaWNhdGlvbi94LXZuZC5hdWRpb2V4cGxvc2lvbi5tenonLCAnbXp6J10sXG4gICAgWydhcHBsaWNhdGlvbi94LXZuZC5scy14cGl4JywgJ3hwaXgnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtdnJtbCcsICd2cm1sJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LXdhaXMtc291cmNlJywgWydzcmMnLCAnd3NyYyddXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtd2luaGVscCcsICdobHAnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtd2ludGFsaycsICd3dGsnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3gtd29ybGQnLCBbJ3dybCcsICdzdnInXV0sXG4gICAgWydhcHBsaWNhdGlvbi94LXdwd2luJywgJ3dwZCddLFxuICAgIFsnYXBwbGljYXRpb24veC13cmknLCAnd3JpJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LXg1MDktY2EtY2VydCcsIFsnY2VyJywgJ2NydCcsICdkZXInXV0sXG4gICAgWydhcHBsaWNhdGlvbi94LXg1MDktdXNlci1jZXJ0JywgJ2NydCddLFxuICAgIFsnYXBwbGljYXRpb24veC14ZmlnJywgJ2ZpZyddLFxuICAgIFsnYXBwbGljYXRpb24veC14cGluc3RhbGwnLCAneHBpJ10sXG4gICAgWydhcHBsaWNhdGlvbi94LXppcC1jb21wcmVzc2VkJywgJ3ppcCddLFxuICAgIFsnYXBwbGljYXRpb24veGNhcC1kaWZmK3htbCcsICd4ZGYnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3hlbmMreG1sJywgJ3hlbmMnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcsICd4aHRtbCddLFxuICAgIFsnYXBwbGljYXRpb24veG1sJywgJ3htbCddLFxuICAgIFsnYXBwbGljYXRpb24veG1sLWR0ZCcsICdkdGQnXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3hvcCt4bWwnLCAneG9wJ10sXG4gICAgWydhcHBsaWNhdGlvbi94c2x0K3htbCcsICd4c2x0J10sXG4gICAgWydhcHBsaWNhdGlvbi94c3BmK3htbCcsICd4c3BmJ10sXG4gICAgWydhcHBsaWNhdGlvbi94dit4bWwnLCAnbXhtbCddLFxuICAgIFsnYXBwbGljYXRpb24veWFuZycsICd5YW5nJ10sXG4gICAgWydhcHBsaWNhdGlvbi95aW4reG1sJywgJ3lpbiddLFxuICAgIFsnYXBwbGljYXRpb24veW5kLm1zLXBraXBrbycsICdwa28nXSxcbiAgICBbJ2FwcGxpY2F0aW9uL3ppcCcsICd6aXAnXSxcbiAgICBbJ2F1ZGlvL2FkcGNtJywgJ2FkcCddLFxuICAgIFsnYXVkaW8vYWlmZicsIFsnYWlmZicsICdhaWYnLCAnYWlmYyddXSxcbiAgICBbJ2F1ZGlvL2Jhc2ljJywgWydzbmQnLCAnYXUnXV0sXG4gICAgWydhdWRpby9pdCcsICdpdCddLFxuICAgIFsnYXVkaW8vbWFrZScsIFsnZnVuaycsICdteScsICdwZnVuayddXSxcbiAgICBbJ2F1ZGlvL21ha2UubXkuZnVuaycsICdwZnVuayddLFxuICAgIFsnYXVkaW8vbWlkJywgWydtaWQnLCAncm1pJ11dLFxuICAgIFsnYXVkaW8vbWlkaScsIFsnbWlkaScsICdrYXInLCAnbWlkJ11dLFxuICAgIFsnYXVkaW8vbW9kJywgJ21vZCddLFxuICAgIFsnYXVkaW8vbXA0JywgJ21wNGEnXSxcbiAgICBbJ2F1ZGlvL21wZWcnLCBbJ21wZ2EnLCAnbXAzJywgJ20yYScsICdtcDInLCAnbXBhJywgJ21wZyddXSxcbiAgICBbJ2F1ZGlvL21wZWczJywgJ21wMyddLFxuICAgIFsnYXVkaW8vbnNwYXVkaW8nLCBbJ2xhJywgJ2xtYSddXSxcbiAgICBbJ2F1ZGlvL29nZycsICdvZ2EnXSxcbiAgICBbJ2F1ZGlvL3MzbScsICdzM20nXSxcbiAgICBbJ2F1ZGlvL3RzcC1hdWRpbycsICd0c2knXSxcbiAgICBbJ2F1ZGlvL3RzcGxheWVyJywgJ3RzcCddLFxuICAgIFsnYXVkaW8vdm5kLmRlY2UuYXVkaW8nLCAndXZhJ10sXG4gICAgWydhdWRpby92bmQuZGlnaXRhbC13aW5kcycsICdlb2wnXSxcbiAgICBbJ2F1ZGlvL3ZuZC5kcmEnLCAnZHJhJ10sXG4gICAgWydhdWRpby92bmQuZHRzJywgJ2R0cyddLFxuICAgIFsnYXVkaW8vdm5kLmR0cy5oZCcsICdkdHNoZCddLFxuICAgIFsnYXVkaW8vdm5kLmx1Y2VudC52b2ljZScsICdsdnAnXSxcbiAgICBbJ2F1ZGlvL3ZuZC5tcy1wbGF5cmVhZHkubWVkaWEucHlhJywgJ3B5YSddLFxuICAgIFsnYXVkaW8vdm5kLm51ZXJhLmVjZWxwNDgwMCcsICdlY2VscDQ4MDAnXSxcbiAgICBbJ2F1ZGlvL3ZuZC5udWVyYS5lY2VscDc0NzAnLCAnZWNlbHA3NDcwJ10sXG4gICAgWydhdWRpby92bmQubnVlcmEuZWNlbHA5NjAwJywgJ2VjZWxwOTYwMCddLFxuICAgIFsnYXVkaW8vdm5kLnFjZWxwJywgJ3FjcCddLFxuICAgIFsnYXVkaW8vdm5kLnJpcCcsICdyaXAnXSxcbiAgICBbJ2F1ZGlvL3ZvYycsICd2b2MnXSxcbiAgICBbJ2F1ZGlvL3ZveHdhcmUnLCAndm94J10sXG4gICAgWydhdWRpby93YXYnLCAnd2F2J10sXG4gICAgWydhdWRpby93ZWJtJywgJ3dlYmEnXSxcbiAgICBbJ2F1ZGlvL3gtYWFjJywgJ2FhYyddLFxuICAgIFsnYXVkaW8veC1hZHBjbScsICdzbmQnXSxcbiAgICBbJ2F1ZGlvL3gtYWlmZicsIFsnYWlmZicsICdhaWYnLCAnYWlmYyddXSxcbiAgICBbJ2F1ZGlvL3gtYXUnLCAnYXUnXSxcbiAgICBbJ2F1ZGlvL3gtZ3NtJywgWydnc2QnLCAnZ3NtJ11dLFxuICAgIFsnYXVkaW8veC1qYW0nLCAnamFtJ10sXG4gICAgWydhdWRpby94LWxpdmVhdWRpbycsICdsYW0nXSxcbiAgICBbJ2F1ZGlvL3gtbWlkJywgWydtaWQnLCAnbWlkaSddXSxcbiAgICBbJ2F1ZGlvL3gtbWlkaScsIFsnbWlkaScsICdtaWQnXV0sXG4gICAgWydhdWRpby94LW1vZCcsICdtb2QnXSxcbiAgICBbJ2F1ZGlvL3gtbXBlZycsICdtcDInXSxcbiAgICBbJ2F1ZGlvL3gtbXBlZy0zJywgJ21wMyddLFxuICAgIFsnYXVkaW8veC1tcGVndXJsJywgJ20zdSddLFxuICAgIFsnYXVkaW8veC1tcGVxdXJsJywgJ20zdSddLFxuICAgIFsnYXVkaW8veC1tcy13YXgnLCAnd2F4J10sXG4gICAgWydhdWRpby94LW1zLXdtYScsICd3bWEnXSxcbiAgICBbJ2F1ZGlvL3gtbnNwYXVkaW8nLCBbJ2xhJywgJ2xtYSddXSxcbiAgICBbJ2F1ZGlvL3gtcG4tcmVhbGF1ZGlvJywgWydyYScsICdyYW0nLCAncm0nLCAncm1tJywgJ3JtcCddXSxcbiAgICBbJ2F1ZGlvL3gtcG4tcmVhbGF1ZGlvLXBsdWdpbicsIFsncmEnLCAncm1wJywgJ3JwbSddXSxcbiAgICBbJ2F1ZGlvL3gtcHNpZCcsICdzaWQnXSxcbiAgICBbJ2F1ZGlvL3gtcmVhbGF1ZGlvJywgJ3JhJ10sXG4gICAgWydhdWRpby94LXR3aW52cScsICd2cWYnXSxcbiAgICBbJ2F1ZGlvL3gtdHdpbnZxLXBsdWdpbicsIFsndnFlJywgJ3ZxbCddXSxcbiAgICBbJ2F1ZGlvL3gtdm5kLmF1ZGlvZXhwbG9zaW9uLm1qdWljZW1lZGlhZmlsZScsICdtamYnXSxcbiAgICBbJ2F1ZGlvL3gtdm9jJywgJ3ZvYyddLFxuICAgIFsnYXVkaW8veC13YXYnLCAnd2F2J10sXG4gICAgWydhdWRpby94bScsICd4bSddLFxuICAgIFsnY2hlbWljYWwveC1jZHgnLCAnY2R4J10sXG4gICAgWydjaGVtaWNhbC94LWNpZicsICdjaWYnXSxcbiAgICBbJ2NoZW1pY2FsL3gtY21kZicsICdjbWRmJ10sXG4gICAgWydjaGVtaWNhbC94LWNtbCcsICdjbWwnXSxcbiAgICBbJ2NoZW1pY2FsL3gtY3NtbCcsICdjc21sJ10sXG4gICAgWydjaGVtaWNhbC94LXBkYicsIFsncGRiJywgJ3h5eiddXSxcbiAgICBbJ2NoZW1pY2FsL3gteHl6JywgJ3h5eiddLFxuICAgIFsnZHJhd2luZy94LWR3ZicsICdkd2YnXSxcbiAgICBbJ2ktd29ybGQvaS12cm1sJywgJ2l2ciddLFxuICAgIFsnaW1hZ2UvYm1wJywgWydibXAnLCAnYm0nXV0sXG4gICAgWydpbWFnZS9jZ20nLCAnY2dtJ10sXG4gICAgWydpbWFnZS9jaXMtY29kJywgJ2NvZCddLFxuICAgIFsnaW1hZ2UvY211LXJhc3RlcicsIFsncmFzJywgJ3Jhc3QnXV0sXG4gICAgWydpbWFnZS9maWYnLCAnZmlmJ10sXG4gICAgWydpbWFnZS9mbG9yaWFuJywgWydmbG8nLCAndHVyYm90J11dLFxuICAgIFsnaW1hZ2UvZzNmYXgnLCAnZzMnXSxcbiAgICBbJ2ltYWdlL2dpZicsICdnaWYnXSxcbiAgICBbJ2ltYWdlL2llZicsIFsnaWVmJywgJ2llZnMnXV0sXG4gICAgWydpbWFnZS9qcGVnJywgWydqcGVnJywgJ2pwZScsICdqcGcnLCAnamZpZicsICdqZmlmLXRibmwnXV0sXG4gICAgWydpbWFnZS9qdXR2aXNpb24nLCAnanV0J10sXG4gICAgWydpbWFnZS9rdHgnLCAna3R4J10sXG4gICAgWydpbWFnZS9uYXBscHMnLCBbJ25hcCcsICduYXBscHMnXV0sXG4gICAgWydpbWFnZS9waWN0JywgWydwaWMnLCAncGljdCddXSxcbiAgICBbJ2ltYWdlL3BpcGVnJywgJ2pmaWYnXSxcbiAgICBbJ2ltYWdlL3BqcGVnJywgWydqZmlmJywgJ2pwZScsICdqcGVnJywgJ2pwZyddXSxcbiAgICBbJ2ltYWdlL3BuZycsIFsncG5nJywgJ3gtcG5nJ11dLFxuICAgIFsnaW1hZ2UvcHJzLmJ0aWYnLCAnYnRpZiddLFxuICAgIFsnaW1hZ2Uvc3ZnK3htbCcsICdzdmcnXSxcbiAgICBbJ2ltYWdlL3RpZmYnLCBbJ3RpZicsICd0aWZmJ11dLFxuICAgIFsnaW1hZ2UvdmFzYScsICdtY2YnXSxcbiAgICBbJ2ltYWdlL3ZuZC5hZG9iZS5waG90b3Nob3AnLCAncHNkJ10sXG4gICAgWydpbWFnZS92bmQuZGVjZS5ncmFwaGljJywgJ3V2aSddLFxuICAgIFsnaW1hZ2Uvdm5kLmRqdnUnLCAnZGp2dSddLFxuICAgIFsnaW1hZ2Uvdm5kLmR2Yi5zdWJ0aXRsZScsICdzdWInXSxcbiAgICBbJ2ltYWdlL3ZuZC5kd2cnLCBbJ2R3ZycsICdkeGYnLCAnc3ZmJ11dLFxuICAgIFsnaW1hZ2Uvdm5kLmR4ZicsICdkeGYnXSxcbiAgICBbJ2ltYWdlL3ZuZC5mYXN0Ymlkc2hlZXQnLCAnZmJzJ10sXG4gICAgWydpbWFnZS92bmQuZnB4JywgJ2ZweCddLFxuICAgIFsnaW1hZ2Uvdm5kLmZzdCcsICdmc3QnXSxcbiAgICBbJ2ltYWdlL3ZuZC5mdWppeGVyb3guZWRtaWNzLW1tcicsICdtbXInXSxcbiAgICBbJ2ltYWdlL3ZuZC5mdWppeGVyb3guZWRtaWNzLXJsYycsICdybGMnXSxcbiAgICBbJ2ltYWdlL3ZuZC5tcy1tb2RpJywgJ21kaSddLFxuICAgIFsnaW1hZ2Uvdm5kLm5ldC1mcHgnLCBbJ2ZweCcsICducHgnXV0sXG4gICAgWydpbWFnZS92bmQucm4tcmVhbGZsYXNoJywgJ3JmJ10sXG4gICAgWydpbWFnZS92bmQucm4tcmVhbHBpeCcsICdycCddLFxuICAgIFsnaW1hZ2Uvdm5kLndhcC53Ym1wJywgJ3dibXAnXSxcbiAgICBbJ2ltYWdlL3ZuZC54aWZmJywgJ3hpZiddLFxuICAgIFsnaW1hZ2Uvd2VicCcsICd3ZWJwJ10sXG4gICAgWydpbWFnZS94LWNtdS1yYXN0ZXInLCAncmFzJ10sXG4gICAgWydpbWFnZS94LWNteCcsICdjbXgnXSxcbiAgICBbJ2ltYWdlL3gtZHdnJywgWydkd2cnLCAnZHhmJywgJ3N2ZiddXSxcbiAgICBbJ2ltYWdlL3gtZnJlZWhhbmQnLCAnZmgnXSxcbiAgICBbJ2ltYWdlL3gtaWNvbicsICdpY28nXSxcbiAgICBbJ2ltYWdlL3gtamcnLCAnYXJ0J10sXG4gICAgWydpbWFnZS94LWpwcycsICdqcHMnXSxcbiAgICBbJ2ltYWdlL3gtbmlmZicsIFsnbmlmZicsICduaWYnXV0sXG4gICAgWydpbWFnZS94LXBjeCcsICdwY3gnXSxcbiAgICBbJ2ltYWdlL3gtcGljdCcsIFsncGN0JywgJ3BpYyddXSxcbiAgICBbJ2ltYWdlL3gtcG9ydGFibGUtYW55bWFwJywgJ3BubSddLFxuICAgIFsnaW1hZ2UveC1wb3J0YWJsZS1iaXRtYXAnLCAncGJtJ10sXG4gICAgWydpbWFnZS94LXBvcnRhYmxlLWdyYXltYXAnLCAncGdtJ10sXG4gICAgWydpbWFnZS94LXBvcnRhYmxlLWdyZXltYXAnLCAncGdtJ10sXG4gICAgWydpbWFnZS94LXBvcnRhYmxlLXBpeG1hcCcsICdwcG0nXSxcbiAgICBbJ2ltYWdlL3gtcXVpY2t0aW1lJywgWydxaWYnLCAncXRpJywgJ3F0aWYnXV0sXG4gICAgWydpbWFnZS94LXJnYicsICdyZ2InXSxcbiAgICBbJ2ltYWdlL3gtdGlmZicsIFsndGlmJywgJ3RpZmYnXV0sXG4gICAgWydpbWFnZS94LXdpbmRvd3MtYm1wJywgJ2JtcCddLFxuICAgIFsnaW1hZ2UveC14Yml0bWFwJywgJ3hibSddLFxuICAgIFsnaW1hZ2UveC14Ym0nLCAneGJtJ10sXG4gICAgWydpbWFnZS94LXhwaXhtYXAnLCBbJ3hwbScsICdwbSddXSxcbiAgICBbJ2ltYWdlL3gteHdkJywgJ3h3ZCddLFxuICAgIFsnaW1hZ2UveC14d2luZG93ZHVtcCcsICd4d2QnXSxcbiAgICBbJ2ltYWdlL3hibScsICd4Ym0nXSxcbiAgICBbJ2ltYWdlL3hwbScsICd4cG0nXSxcbiAgICBbJ21lc3NhZ2UvcmZjODIyJywgWydlbWwnLCAnbWh0JywgJ21odG1sJywgJ253cycsICdtaW1lJ11dLFxuICAgIFsnbW9kZWwvaWdlcycsIFsnaWdlcycsICdpZ3MnXV0sXG4gICAgWydtb2RlbC9tZXNoJywgJ21zaCddLFxuICAgIFsnbW9kZWwvdm5kLmNvbGxhZGEreG1sJywgJ2RhZSddLFxuICAgIFsnbW9kZWwvdm5kLmR3ZicsICdkd2YnXSxcbiAgICBbJ21vZGVsL3ZuZC5nZGwnLCAnZ2RsJ10sXG4gICAgWydtb2RlbC92bmQuZ3R3JywgJ2d0dyddLFxuICAgIFsnbW9kZWwvdm5kLm10cycsICdtdHMnXSxcbiAgICBbJ21vZGVsL3ZuZC52dHUnLCAndnR1J10sXG4gICAgWydtb2RlbC92cm1sJywgWyd2cm1sJywgJ3dybCcsICd3cnonXV0sXG4gICAgWydtb2RlbC94LXBvdicsICdwb3YnXSxcbiAgICBbJ211bHRpcGFydC94LWd6aXAnLCAnZ3ppcCddLFxuICAgIFsnbXVsdGlwYXJ0L3gtdXN0YXInLCAndXN0YXInXSxcbiAgICBbJ211bHRpcGFydC94LXppcCcsICd6aXAnXSxcbiAgICBbJ211c2ljL2NyZXNjZW5kbycsIFsnbWlkJywgJ21pZGknXV0sXG4gICAgWydtdXNpYy94LWthcmFva2UnLCAna2FyJ10sXG4gICAgWydwYWxlb3Z1L3gtcHYnLCAncHZ1J10sXG4gICAgWyd0ZXh0L2FzcCcsICdhc3AnXSxcbiAgICBbJ3RleHQvY2FsZW5kYXInLCAnaWNzJ10sXG4gICAgWyd0ZXh0L2NzcycsICdjc3MnXSxcbiAgICBbJ3RleHQvY3N2JywgJ2NzdiddLFxuICAgIFsndGV4dC9lY21hc2NyaXB0JywgJ2pzJ10sXG4gICAgWyd0ZXh0L2gzMjMnLCAnMzIzJ10sXG4gICAgWyd0ZXh0L2h0bWwnLCBbJ2h0bWwnLCAnaHRtJywgJ3N0bScsICdhY2dpJywgJ2h0bWxzJywgJ2h0eCcsICdzaHRtbCddXSxcbiAgICBbJ3RleHQvaXVscycsICd1bHMnXSxcbiAgICBbJ3RleHQvamF2YXNjcmlwdCcsICdqcyddLFxuICAgIFsndGV4dC9tY2YnLCAnbWNmJ10sXG4gICAgWyd0ZXh0L24zJywgJ24zJ10sXG4gICAgWyd0ZXh0L3Bhc2NhbCcsICdwYXMnXSxcbiAgICBbXG4gICAgICAgICd0ZXh0L3BsYWluJyxcbiAgICAgICAgW1xuICAgICAgICAgICAgJ3R4dCcsXG4gICAgICAgICAgICAnYmFzJyxcbiAgICAgICAgICAgICdjJyxcbiAgICAgICAgICAgICdoJyxcbiAgICAgICAgICAgICdjKysnLFxuICAgICAgICAgICAgJ2NjJyxcbiAgICAgICAgICAgICdjb20nLFxuICAgICAgICAgICAgJ2NvbmYnLFxuICAgICAgICAgICAgJ2N4eCcsXG4gICAgICAgICAgICAnZGVmJyxcbiAgICAgICAgICAgICdmJyxcbiAgICAgICAgICAgICdmOTAnLFxuICAgICAgICAgICAgJ2ZvcicsXG4gICAgICAgICAgICAnZycsXG4gICAgICAgICAgICAnaGgnLFxuICAgICAgICAgICAgJ2lkYycsXG4gICAgICAgICAgICAnamF2JyxcbiAgICAgICAgICAgICdqYXZhJyxcbiAgICAgICAgICAgICdsaXN0JyxcbiAgICAgICAgICAgICdsb2cnLFxuICAgICAgICAgICAgJ2xzdCcsXG4gICAgICAgICAgICAnbScsXG4gICAgICAgICAgICAnbWFyJyxcbiAgICAgICAgICAgICdwbCcsXG4gICAgICAgICAgICAnc2RtbCcsXG4gICAgICAgICAgICAndGV4dCdcbiAgICAgICAgXVxuICAgIF0sXG4gICAgWyd0ZXh0L3BsYWluLWJhcycsICdwYXInXSxcbiAgICBbJ3RleHQvcHJzLmxpbmVzLnRhZycsICdkc2MnXSxcbiAgICBbJ3RleHQvcmljaHRleHQnLCBbJ3J0eCcsICdydCcsICdydGYnXV0sXG4gICAgWyd0ZXh0L3NjcmlwbGV0JywgJ3dzYyddLFxuICAgIFsndGV4dC9zY3JpcHRsZXQnLCAnc2N0J10sXG4gICAgWyd0ZXh0L3NnbWwnLCBbJ3NnbScsICdzZ21sJ11dLFxuICAgIFsndGV4dC90YWItc2VwYXJhdGVkLXZhbHVlcycsICd0c3YnXSxcbiAgICBbJ3RleHQvdHJvZmYnLCAndCddLFxuICAgIFsndGV4dC90dXJ0bGUnLCAndHRsJ10sXG4gICAgWyd0ZXh0L3VyaS1saXN0JywgWyd1bmknLCAndW5pcycsICd1cmknLCAndXJpcyddXSxcbiAgICBbJ3RleHQvdm5kLmFiYycsICdhYmMnXSxcbiAgICBbJ3RleHQvdm5kLmN1cmwnLCAnY3VybCddLFxuICAgIFsndGV4dC92bmQuY3VybC5kY3VybCcsICdkY3VybCddLFxuICAgIFsndGV4dC92bmQuY3VybC5tY3VybCcsICdtY3VybCddLFxuICAgIFsndGV4dC92bmQuY3VybC5zY3VybCcsICdzY3VybCddLFxuICAgIFsndGV4dC92bmQuZmx5JywgJ2ZseSddLFxuICAgIFsndGV4dC92bmQuZm1pLmZsZXhzdG9yJywgJ2ZseCddLFxuICAgIFsndGV4dC92bmQuZ3JhcGh2aXonLCAnZ3YnXSxcbiAgICBbJ3RleHQvdm5kLmluM2QuM2RtbCcsICczZG1sJ10sXG4gICAgWyd0ZXh0L3ZuZC5pbjNkLnNwb3QnLCAnc3BvdCddLFxuICAgIFsndGV4dC92bmQucm4tcmVhbHRleHQnLCAncnQnXSxcbiAgICBbJ3RleHQvdm5kLnN1bi5qMm1lLmFwcC1kZXNjcmlwdG9yJywgJ2phZCddLFxuICAgIFsndGV4dC92bmQud2FwLndtbCcsICd3bWwnXSxcbiAgICBbJ3RleHQvdm5kLndhcC53bWxzY3JpcHQnLCAnd21scyddLFxuICAgIFsndGV4dC93ZWJ2aWV3aHRtbCcsICdodHQnXSxcbiAgICBbJ3RleHQveC1hc20nLCBbJ2FzbScsICdzJ11dLFxuICAgIFsndGV4dC94LWF1ZGlvc29mdC1pbnRyYScsICdhaXAnXSxcbiAgICBbJ3RleHQveC1jJywgWydjJywgJ2NjJywgJ2NwcCddXSxcbiAgICBbJ3RleHQveC1jb21wb25lbnQnLCAnaHRjJ10sXG4gICAgWyd0ZXh0L3gtZm9ydHJhbicsIFsnZm9yJywgJ2YnLCAnZjc3JywgJ2Y5MCddXSxcbiAgICBbJ3RleHQveC1oJywgWydoJywgJ2hoJ11dLFxuICAgIFsndGV4dC94LWphdmEtc291cmNlJywgWydqYXZhJywgJ2phdiddXSxcbiAgICBbJ3RleHQveC1qYXZhLXNvdXJjZSxqYXZhJywgJ2phdmEnXSxcbiAgICBbJ3RleHQveC1sYS1hc2YnLCAnbHN4J10sXG4gICAgWyd0ZXh0L3gtbScsICdtJ10sXG4gICAgWyd0ZXh0L3gtcGFzY2FsJywgJ3AnXSxcbiAgICBbJ3RleHQveC1zY3JpcHQnLCAnaGxiJ10sXG4gICAgWyd0ZXh0L3gtc2NyaXB0LmNzaCcsICdjc2gnXSxcbiAgICBbJ3RleHQveC1zY3JpcHQuZWxpc3AnLCAnZWwnXSxcbiAgICBbJ3RleHQveC1zY3JpcHQuZ3VpbGUnLCAnc2NtJ10sXG4gICAgWyd0ZXh0L3gtc2NyaXB0LmtzaCcsICdrc2gnXSxcbiAgICBbJ3RleHQveC1zY3JpcHQubGlzcCcsICdsc3AnXSxcbiAgICBbJ3RleHQveC1zY3JpcHQucGVybCcsICdwbCddLFxuICAgIFsndGV4dC94LXNjcmlwdC5wZXJsLW1vZHVsZScsICdwbSddLFxuICAgIFsndGV4dC94LXNjcmlwdC5waHl0b24nLCAncHknXSxcbiAgICBbJ3RleHQveC1zY3JpcHQucmV4eCcsICdyZXh4J10sXG4gICAgWyd0ZXh0L3gtc2NyaXB0LnNjaGVtZScsICdzY20nXSxcbiAgICBbJ3RleHQveC1zY3JpcHQuc2gnLCAnc2gnXSxcbiAgICBbJ3RleHQveC1zY3JpcHQudGNsJywgJ3RjbCddLFxuICAgIFsndGV4dC94LXNjcmlwdC50Y3NoJywgJ3Rjc2gnXSxcbiAgICBbJ3RleHQveC1zY3JpcHQuenNoJywgJ3pzaCddLFxuICAgIFsndGV4dC94LXNlcnZlci1wYXJzZWQtaHRtbCcsIFsnc2h0bWwnLCAnc3NpJ11dLFxuICAgIFsndGV4dC94LXNldGV4dCcsICdldHgnXSxcbiAgICBbJ3RleHQveC1zZ21sJywgWydzZ20nLCAnc2dtbCddXSxcbiAgICBbJ3RleHQveC1zcGVlY2gnLCBbJ3NwYycsICd0YWxrJ11dLFxuICAgIFsndGV4dC94LXVpbCcsICd1aWwnXSxcbiAgICBbJ3RleHQveC11dWVuY29kZScsIFsndXUnLCAndXVlJ11dLFxuICAgIFsndGV4dC94LXZjYWxlbmRhcicsICd2Y3MnXSxcbiAgICBbJ3RleHQveC12Y2FyZCcsICd2Y2YnXSxcbiAgICBbJ3RleHQveG1sJywgJ3htbCddLFxuICAgIFsndmlkZW8vM2dwcCcsICczZ3AnXSxcbiAgICBbJ3ZpZGVvLzNncHAyJywgJzNnMiddLFxuICAgIFsndmlkZW8vYW5pbWFmbGV4JywgJ2FmbCddLFxuICAgIFsndmlkZW8vYXZpJywgJ2F2aSddLFxuICAgIFsndmlkZW8vYXZzLXZpZGVvJywgJ2F2cyddLFxuICAgIFsndmlkZW8vZGwnLCAnZGwnXSxcbiAgICBbJ3ZpZGVvL2ZsaScsICdmbGknXSxcbiAgICBbJ3ZpZGVvL2dsJywgJ2dsJ10sXG4gICAgWyd2aWRlby9oMjYxJywgJ2gyNjEnXSxcbiAgICBbJ3ZpZGVvL2gyNjMnLCAnaDI2MyddLFxuICAgIFsndmlkZW8vaDI2NCcsICdoMjY0J10sXG4gICAgWyd2aWRlby9qcGVnJywgJ2pwZ3YnXSxcbiAgICBbJ3ZpZGVvL2pwbScsICdqcG0nXSxcbiAgICBbJ3ZpZGVvL21qMicsICdtajInXSxcbiAgICBbJ3ZpZGVvL21wNCcsICdtcDQnXSxcbiAgICBbJ3ZpZGVvL21wZWcnLCBbJ21wZWcnLCAnbXAyJywgJ21wYScsICdtcGUnLCAnbXBnJywgJ21wdjInLCAnbTF2JywgJ20ydicsICdtcDMnXV0sXG4gICAgWyd2aWRlby9tc3ZpZGVvJywgJ2F2aSddLFxuICAgIFsndmlkZW8vb2dnJywgJ29ndiddLFxuICAgIFsndmlkZW8vcXVpY2t0aW1lJywgWydtb3YnLCAncXQnLCAnbW9vdiddXSxcbiAgICBbJ3ZpZGVvL3ZkbycsICd2ZG8nXSxcbiAgICBbJ3ZpZGVvL3Zpdm8nLCBbJ3ZpdicsICd2aXZvJ11dLFxuICAgIFsndmlkZW8vdm5kLmRlY2UuaGQnLCAndXZoJ10sXG4gICAgWyd2aWRlby92bmQuZGVjZS5tb2JpbGUnLCAndXZtJ10sXG4gICAgWyd2aWRlby92bmQuZGVjZS5wZCcsICd1dnAnXSxcbiAgICBbJ3ZpZGVvL3ZuZC5kZWNlLnNkJywgJ3V2cyddLFxuICAgIFsndmlkZW8vdm5kLmRlY2UudmlkZW8nLCAndXZ2J10sXG4gICAgWyd2aWRlby92bmQuZnZ0JywgJ2Z2dCddLFxuICAgIFsndmlkZW8vdm5kLm1wZWd1cmwnLCAnbXh1J10sXG4gICAgWyd2aWRlby92bmQubXMtcGxheXJlYWR5Lm1lZGlhLnB5dicsICdweXYnXSxcbiAgICBbJ3ZpZGVvL3ZuZC5ybi1yZWFsdmlkZW8nLCAncnYnXSxcbiAgICBbJ3ZpZGVvL3ZuZC51dnZ1Lm1wNCcsICd1dnUnXSxcbiAgICBbJ3ZpZGVvL3ZuZC52aXZvJywgWyd2aXYnLCAndml2byddXSxcbiAgICBbJ3ZpZGVvL3Zvc2FpYycsICd2b3MnXSxcbiAgICBbJ3ZpZGVvL3dlYm0nLCAnd2VibSddLFxuICAgIFsndmlkZW8veC1hbXQtZGVtb3J1bicsICd4ZHInXSxcbiAgICBbJ3ZpZGVvL3gtYW10LXNob3dydW4nLCAneHNyJ10sXG4gICAgWyd2aWRlby94LWF0b21pYzNkLWZlYXR1cmUnLCAnZm1mJ10sXG4gICAgWyd2aWRlby94LWRsJywgJ2RsJ10sXG4gICAgWyd2aWRlby94LWR2JywgWydkaWYnLCAnZHYnXV0sXG4gICAgWyd2aWRlby94LWY0dicsICdmNHYnXSxcbiAgICBbJ3ZpZGVvL3gtZmxpJywgJ2ZsaSddLFxuICAgIFsndmlkZW8veC1mbHYnLCAnZmx2J10sXG4gICAgWyd2aWRlby94LWdsJywgJ2dsJ10sXG4gICAgWyd2aWRlby94LWlzdmlkZW8nLCAnaXN1J10sXG4gICAgWyd2aWRlby94LWxhLWFzZicsIFsnbHNmJywgJ2xzeCddXSxcbiAgICBbJ3ZpZGVvL3gtbTR2JywgJ200diddLFxuICAgIFsndmlkZW8veC1tb3Rpb24tanBlZycsICdtanBnJ10sXG4gICAgWyd2aWRlby94LW1wZWcnLCBbJ21wMycsICdtcDInXV0sXG4gICAgWyd2aWRlby94LW1wZXEyYScsICdtcDInXSxcbiAgICBbJ3ZpZGVvL3gtbXMtYXNmJywgWydhc2YnLCAnYXNyJywgJ2FzeCddXSxcbiAgICBbJ3ZpZGVvL3gtbXMtYXNmLXBsdWdpbicsICdhc3gnXSxcbiAgICBbJ3ZpZGVvL3gtbXMtd20nLCAnd20nXSxcbiAgICBbJ3ZpZGVvL3gtbXMtd212JywgJ3dtdiddLFxuICAgIFsndmlkZW8veC1tcy13bXgnLCAnd214J10sXG4gICAgWyd2aWRlby94LW1zLXd2eCcsICd3dngnXSxcbiAgICBbJ3ZpZGVvL3gtbXN2aWRlbycsICdhdmknXSxcbiAgICBbJ3ZpZGVvL3gtcXRjJywgJ3F0YyddLFxuICAgIFsndmlkZW8veC1zY20nLCAnc2NtJ10sXG4gICAgWyd2aWRlby94LXNnaS1tb3ZpZScsIFsnbW92aWUnLCAnbXYnXV0sXG4gICAgWyd3aW5kb3dzL21ldGFmaWxlJywgJ3dtZiddLFxuICAgIFsnd3d3L21pbWUnLCAnbWltZSddLFxuICAgIFsneC1jb25mZXJlbmNlL3gtY29vbHRhbGsnLCAnaWNlJ10sXG4gICAgWyd4LW11c2ljL3gtbWlkaScsIFsnbWlkJywgJ21pZGknXV0sXG4gICAgWyd4LXdvcmxkL3gtM2RtZicsIFsnM2RtJywgJzNkbWYnLCAncWQzJywgJ3FkM2QnXV0sXG4gICAgWyd4LXdvcmxkL3gtc3ZyJywgJ3N2ciddLFxuICAgIFsneC13b3JsZC94LXZybWwnLCBbJ2ZscicsICd2cm1sJywgJ3dybCcsICd3cnonLCAneGFmJywgJ3hvZiddXSxcbiAgICBbJ3gtd29ybGQveC12cnQnLCAndnJ0J10sXG4gICAgWyd4Z2wvZHJhd2luZycsICd4Z3onXSxcbiAgICBbJ3hnbC9tb3ZpZScsICd4bXonXVxuXSk7XG5jb25zdCBleHRlbnNpb25zID0gbmV3IE1hcChbXG4gICAgWycxMjMnLCAnYXBwbGljYXRpb24vdm5kLmxvdHVzLTEtMi0zJ10sXG4gICAgWyczMjMnLCAndGV4dC9oMzIzJ10sXG4gICAgWycqJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSddLFxuICAgIFsnM2RtJywgJ3gtd29ybGQveC0zZG1mJ10sXG4gICAgWyczZG1mJywgJ3gtd29ybGQveC0zZG1mJ10sXG4gICAgWyczZG1sJywgJ3RleHQvdm5kLmluM2QuM2RtbCddLFxuICAgIFsnM2cyJywgJ3ZpZGVvLzNncHAyJ10sXG4gICAgWyczZ3AnLCAndmlkZW8vM2dwcCddLFxuICAgIFsnN3onLCAnYXBwbGljYXRpb24veC03ei1jb21wcmVzc2VkJ10sXG4gICAgWydhJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSddLFxuICAgIFsnYWFiJywgJ2FwcGxpY2F0aW9uL3gtYXV0aG9yd2FyZS1iaW4nXSxcbiAgICBbJ2FhYycsICdhdWRpby94LWFhYyddLFxuICAgIFsnYWFtJywgJ2FwcGxpY2F0aW9uL3gtYXV0aG9yd2FyZS1tYXAnXSxcbiAgICBbJ2FhcycsICdhcHBsaWNhdGlvbi94LWF1dGhvcndhcmUtc2VnJ10sXG4gICAgWydhYmMnLCAndGV4dC92bmQuYWJjJ10sXG4gICAgWydhYncnLCAnYXBwbGljYXRpb24veC1hYml3b3JkJ10sXG4gICAgWydhYycsICdhcHBsaWNhdGlvbi9wa2l4LWF0dHItY2VydCddLFxuICAgIFsnYWNjJywgJ2FwcGxpY2F0aW9uL3ZuZC5hbWVyaWNhbmR5bmFtaWNzLmFjYyddLFxuICAgIFsnYWNlJywgJ2FwcGxpY2F0aW9uL3gtYWNlLWNvbXByZXNzZWQnXSxcbiAgICBbJ2FjZ2knLCAndGV4dC9odG1sJ10sXG4gICAgWydhY3UnLCAnYXBwbGljYXRpb24vdm5kLmFjdWNvYm9sJ10sXG4gICAgWydhY3gnLCAnYXBwbGljYXRpb24vaW50ZXJuZXQtcHJvcGVydHktc3RyZWFtJ10sXG4gICAgWydhZHAnLCAnYXVkaW8vYWRwY20nXSxcbiAgICBbJ2FlcCcsICdhcHBsaWNhdGlvbi92bmQuYXVkaW9ncmFwaCddLFxuICAgIFsnYWZsJywgJ3ZpZGVvL2FuaW1hZmxleCddLFxuICAgIFsnYWZwJywgJ2FwcGxpY2F0aW9uL3ZuZC5pYm0ubW9kY2FwJ10sXG4gICAgWydhaGVhZCcsICdhcHBsaWNhdGlvbi92bmQuYWhlYWQuc3BhY2UnXSxcbiAgICBbJ2FpJywgJ2FwcGxpY2F0aW9uL3Bvc3RzY3JpcHQnXSxcbiAgICBbJ2FpZicsIFsnYXVkaW8vYWlmZicsICdhdWRpby94LWFpZmYnXV0sXG4gICAgWydhaWZjJywgWydhdWRpby9haWZmJywgJ2F1ZGlvL3gtYWlmZiddXSxcbiAgICBbJ2FpZmYnLCBbJ2F1ZGlvL2FpZmYnLCAnYXVkaW8veC1haWZmJ11dLFxuICAgIFsnYWltJywgJ2FwcGxpY2F0aW9uL3gtYWltJ10sXG4gICAgWydhaXAnLCAndGV4dC94LWF1ZGlvc29mdC1pbnRyYSddLFxuICAgIFsnYWlyJywgJ2FwcGxpY2F0aW9uL3ZuZC5hZG9iZS5haXItYXBwbGljYXRpb24taW5zdGFsbGVyLXBhY2thZ2UremlwJ10sXG4gICAgWydhaXQnLCAnYXBwbGljYXRpb24vdm5kLmR2Yi5haXQnXSxcbiAgICBbJ2FtaScsICdhcHBsaWNhdGlvbi92bmQuYW1pZ2EuYW1pJ10sXG4gICAgWydhbmknLCAnYXBwbGljYXRpb24veC1uYXZpLWFuaW1hdGlvbiddLFxuICAgIFsnYW9zJywgJ2FwcGxpY2F0aW9uL3gtbm9raWEtOTAwMC1jb21tdW5pY2F0b3ItYWRkLW9uLXNvZnR3YXJlJ10sXG4gICAgWydhcGsnLCAnYXBwbGljYXRpb24vdm5kLmFuZHJvaWQucGFja2FnZS1hcmNoaXZlJ10sXG4gICAgWydhcHBsaWNhdGlvbicsICdhcHBsaWNhdGlvbi94LW1zLWFwcGxpY2F0aW9uJ10sXG4gICAgWydhcHInLCAnYXBwbGljYXRpb24vdm5kLmxvdHVzLWFwcHJvYWNoJ10sXG4gICAgWydhcHMnLCAnYXBwbGljYXRpb24vbWltZSddLFxuICAgIFsnYXJjJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSddLFxuICAgIFsnYXJqJywgWydhcHBsaWNhdGlvbi9hcmonLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ11dLFxuICAgIFsnYXJ0JywgJ2ltYWdlL3gtamcnXSxcbiAgICBbJ2FzZicsICd2aWRlby94LW1zLWFzZiddLFxuICAgIFsnYXNtJywgJ3RleHQveC1hc20nXSxcbiAgICBbJ2FzbycsICdhcHBsaWNhdGlvbi92bmQuYWNjcGFjLnNpbXBseS5hc28nXSxcbiAgICBbJ2FzcCcsICd0ZXh0L2FzcCddLFxuICAgIFsnYXNyJywgJ3ZpZGVvL3gtbXMtYXNmJ10sXG4gICAgWydhc3gnLCBbJ3ZpZGVvL3gtbXMtYXNmJywgJ2FwcGxpY2F0aW9uL3gtbXBsYXllcjInLCAndmlkZW8veC1tcy1hc2YtcGx1Z2luJ11dLFxuICAgIFsnYXRjJywgJ2FwcGxpY2F0aW9uL3ZuZC5hY3Vjb3JwJ10sXG4gICAgWydhdG9tY2F0JywgJ2FwcGxpY2F0aW9uL2F0b21jYXQreG1sJ10sXG4gICAgWydhdG9tc3ZjJywgJ2FwcGxpY2F0aW9uL2F0b21zdmMreG1sJ10sXG4gICAgWydhdHgnLCAnYXBwbGljYXRpb24vdm5kLmFudGl4LmdhbWUtY29tcG9uZW50J10sXG4gICAgWydhdScsIFsnYXVkaW8vYmFzaWMnLCAnYXVkaW8veC1hdSddXSxcbiAgICBbJ2F2aScsIFsndmlkZW8vYXZpJywgJ3ZpZGVvL21zdmlkZW8nLCAnYXBwbGljYXRpb24veC10cm9mZi1tc3ZpZGVvJywgJ3ZpZGVvL3gtbXN2aWRlbyddXSxcbiAgICBbJ2F2cycsICd2aWRlby9hdnMtdmlkZW8nXSxcbiAgICBbJ2F3JywgJ2FwcGxpY2F0aW9uL2FwcGxpeHdhcmUnXSxcbiAgICBbJ2F4cycsICdhcHBsaWNhdGlvbi9vbGVzY3JpcHQnXSxcbiAgICBbJ2F6ZicsICdhcHBsaWNhdGlvbi92bmQuYWlyemlwLmZpbGVzZWN1cmUuYXpmJ10sXG4gICAgWydhenMnLCAnYXBwbGljYXRpb24vdm5kLmFpcnppcC5maWxlc2VjdXJlLmF6cyddLFxuICAgIFsnYXp3JywgJ2FwcGxpY2F0aW9uL3ZuZC5hbWF6b24uZWJvb2snXSxcbiAgICBbJ2JhcycsICd0ZXh0L3BsYWluJ10sXG4gICAgWydiY3BpbycsICdhcHBsaWNhdGlvbi94LWJjcGlvJ10sXG4gICAgWydiZGYnLCAnYXBwbGljYXRpb24veC1mb250LWJkZiddLFxuICAgIFsnYmRtJywgJ2FwcGxpY2F0aW9uL3ZuZC5zeW5jbWwuZG0rd2J4bWwnXSxcbiAgICBbJ2JlZCcsICdhcHBsaWNhdGlvbi92bmQucmVhbHZuYy5iZWQnXSxcbiAgICBbJ2JoMicsICdhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5c3BycyddLFxuICAgIFsnYmluJywgWydhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLCAnYXBwbGljYXRpb24vbWFjLWJpbmFyeScsICdhcHBsaWNhdGlvbi9tYWNiaW5hcnknLCAnYXBwbGljYXRpb24veC1tYWNiaW5hcnknLCAnYXBwbGljYXRpb24veC1iaW5hcnknXV0sXG4gICAgWydibScsICdpbWFnZS9ibXAnXSxcbiAgICBbJ2JtaScsICdhcHBsaWNhdGlvbi92bmQuYm1pJ10sXG4gICAgWydibXAnLCBbJ2ltYWdlL2JtcCcsICdpbWFnZS94LXdpbmRvd3MtYm1wJ11dLFxuICAgIFsnYm9vJywgJ2FwcGxpY2F0aW9uL2Jvb2snXSxcbiAgICBbJ2Jvb2snLCAnYXBwbGljYXRpb24vYm9vayddLFxuICAgIFsnYm94JywgJ2FwcGxpY2F0aW9uL3ZuZC5wcmV2aWV3c3lzdGVtcy5ib3gnXSxcbiAgICBbJ2JveicsICdhcHBsaWNhdGlvbi94LWJ6aXAyJ10sXG4gICAgWydic2gnLCAnYXBwbGljYXRpb24veC1ic2gnXSxcbiAgICBbJ2J0aWYnLCAnaW1hZ2UvcHJzLmJ0aWYnXSxcbiAgICBbJ2J6JywgJ2FwcGxpY2F0aW9uL3gtYnppcCddLFxuICAgIFsnYnoyJywgJ2FwcGxpY2F0aW9uL3gtYnppcDInXSxcbiAgICBbJ2MnLCBbJ3RleHQvcGxhaW4nLCAndGV4dC94LWMnXV0sXG4gICAgWydjKysnLCAndGV4dC9wbGFpbiddLFxuICAgIFsnYzExYW1jJywgJ2FwcGxpY2F0aW9uL3ZuZC5jbHVldHJ1c3QuY2FydG9tb2JpbGUtY29uZmlnJ10sXG4gICAgWydjMTFhbXonLCAnYXBwbGljYXRpb24vdm5kLmNsdWV0cnVzdC5jYXJ0b21vYmlsZS1jb25maWctcGtnJ10sXG4gICAgWydjNGcnLCAnYXBwbGljYXRpb24vdm5kLmNsb25rLmM0Z3JvdXAnXSxcbiAgICBbJ2NhYicsICdhcHBsaWNhdGlvbi92bmQubXMtY2FiLWNvbXByZXNzZWQnXSxcbiAgICBbJ2NhcicsICdhcHBsaWNhdGlvbi92bmQuY3VybC5jYXInXSxcbiAgICBbJ2NhdCcsIFsnYXBwbGljYXRpb24vdm5kLm1zLXBraXNlY2NhdCcsICdhcHBsaWNhdGlvbi92bmQubXMtcGtpLnNlY2NhdCddXSxcbiAgICBbJ2NjJywgWyd0ZXh0L3BsYWluJywgJ3RleHQveC1jJ11dLFxuICAgIFsnY2NhZCcsICdhcHBsaWNhdGlvbi9jbGFyaXNjYWQnXSxcbiAgICBbJ2NjbycsICdhcHBsaWNhdGlvbi94LWNvY29hJ10sXG4gICAgWydjY3htbCcsICdhcHBsaWNhdGlvbi9jY3htbCt4bWwsJ10sXG4gICAgWydjZGJjbXNnJywgJ2FwcGxpY2F0aW9uL3ZuZC5jb250YWN0LmNtc2cnXSxcbiAgICBbJ2NkZicsIFsnYXBwbGljYXRpb24vY2RmJywgJ2FwcGxpY2F0aW9uL3gtY2RmJywgJ2FwcGxpY2F0aW9uL3gtbmV0Y2RmJ11dLFxuICAgIFsnY2RrZXknLCAnYXBwbGljYXRpb24vdm5kLm1lZGlhc3RhdGlvbi5jZGtleSddLFxuICAgIFsnY2RtaWEnLCAnYXBwbGljYXRpb24vY2RtaS1jYXBhYmlsaXR5J10sXG4gICAgWydjZG1pYycsICdhcHBsaWNhdGlvbi9jZG1pLWNvbnRhaW5lciddLFxuICAgIFsnY2RtaWQnLCAnYXBwbGljYXRpb24vY2RtaS1kb21haW4nXSxcbiAgICBbJ2NkbWlvJywgJ2FwcGxpY2F0aW9uL2NkbWktb2JqZWN0J10sXG4gICAgWydjZG1pcScsICdhcHBsaWNhdGlvbi9jZG1pLXF1ZXVlJ10sXG4gICAgWydjZHgnLCAnY2hlbWljYWwveC1jZHgnXSxcbiAgICBbJ2NkeG1sJywgJ2FwcGxpY2F0aW9uL3ZuZC5jaGVtZHJhdyt4bWwnXSxcbiAgICBbJ2NkeScsICdhcHBsaWNhdGlvbi92bmQuY2luZGVyZWxsYSddLFxuICAgIFsnY2VyJywgWydhcHBsaWNhdGlvbi9wa2l4LWNlcnQnLCAnYXBwbGljYXRpb24veC14NTA5LWNhLWNlcnQnXV0sXG4gICAgWydjZ20nLCAnaW1hZ2UvY2dtJ10sXG4gICAgWydjaGEnLCAnYXBwbGljYXRpb24veC1jaGF0J10sXG4gICAgWydjaGF0JywgJ2FwcGxpY2F0aW9uL3gtY2hhdCddLFxuICAgIFsnY2htJywgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1odG1saGVscCddLFxuICAgIFsnY2hydCcsICdhcHBsaWNhdGlvbi92bmQua2RlLmtjaGFydCddLFxuICAgIFsnY2lmJywgJ2NoZW1pY2FsL3gtY2lmJ10sXG4gICAgWydjaWknLCAnYXBwbGljYXRpb24vdm5kLmFuc2VyLXdlYi1jZXJ0aWZpY2F0ZS1pc3N1ZS1pbml0aWF0aW9uJ10sXG4gICAgWydjaWwnLCAnYXBwbGljYXRpb24vdm5kLm1zLWFydGdhbHJ5J10sXG4gICAgWydjbGEnLCAnYXBwbGljYXRpb24vdm5kLmNsYXltb3JlJ10sXG4gICAgWydjbGFzcycsIFsnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJywgJ2FwcGxpY2F0aW9uL2phdmEnLCAnYXBwbGljYXRpb24vamF2YS1ieXRlLWNvZGUnLCAnYXBwbGljYXRpb24vamF2YS12bScsICdhcHBsaWNhdGlvbi94LWphdmEtY2xhc3MnXV0sXG4gICAgWydjbGtrJywgJ2FwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLmtleWJvYXJkJ10sXG4gICAgWydjbGtwJywgJ2FwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLnBhbGV0dGUnXSxcbiAgICBbJ2Nsa3QnLCAnYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXIudGVtcGxhdGUnXSxcbiAgICBbJ2Nsa3cnLCAnYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXIud29yZGJhbmsnXSxcbiAgICBbJ2Nsa3gnLCAnYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXInXSxcbiAgICBbJ2NscCcsICdhcHBsaWNhdGlvbi94LW1zY2xpcCddLFxuICAgIFsnY21jJywgJ2FwcGxpY2F0aW9uL3ZuZC5jb3Ntb2NhbGxlciddLFxuICAgIFsnY21kZicsICdjaGVtaWNhbC94LWNtZGYnXSxcbiAgICBbJ2NtbCcsICdjaGVtaWNhbC94LWNtbCddLFxuICAgIFsnY21wJywgJ2FwcGxpY2F0aW9uL3ZuZC55ZWxsb3dyaXZlci1jdXN0b20tbWVudSddLFxuICAgIFsnY214JywgJ2ltYWdlL3gtY214J10sXG4gICAgWydjb2QnLCBbJ2ltYWdlL2Npcy1jb2QnLCAnYXBwbGljYXRpb24vdm5kLnJpbS5jb2QnXV0sXG4gICAgWydjb20nLCBbJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsICd0ZXh0L3BsYWluJ11dLFxuICAgIFsnY29uZicsICd0ZXh0L3BsYWluJ10sXG4gICAgWydjcGlvJywgJ2FwcGxpY2F0aW9uL3gtY3BpbyddLFxuICAgIFsnY3BwJywgJ3RleHQveC1jJ10sXG4gICAgWydjcHQnLCBbJ2FwcGxpY2F0aW9uL21hYy1jb21wYWN0cHJvJywgJ2FwcGxpY2F0aW9uL3gtY29tcGFjdHBybycsICdhcHBsaWNhdGlvbi94LWNwdCddXSxcbiAgICBbJ2NyZCcsICdhcHBsaWNhdGlvbi94LW1zY2FyZGZpbGUnXSxcbiAgICBbJ2NybCcsIFsnYXBwbGljYXRpb24vcGtpeC1jcmwnLCAnYXBwbGljYXRpb24vcGtjcy1jcmwnXV0sXG4gICAgWydjcnQnLCBbJ2FwcGxpY2F0aW9uL3BraXgtY2VydCcsICdhcHBsaWNhdGlvbi94LXg1MDktdXNlci1jZXJ0JywgJ2FwcGxpY2F0aW9uL3gteDUwOS1jYS1jZXJ0J11dLFxuICAgIFsnY3J5cHRvbm90ZScsICdhcHBsaWNhdGlvbi92bmQucmlnLmNyeXB0b25vdGUnXSxcbiAgICBbJ2NzaCcsIFsndGV4dC94LXNjcmlwdC5jc2gnLCAnYXBwbGljYXRpb24veC1jc2gnXV0sXG4gICAgWydjc21sJywgJ2NoZW1pY2FsL3gtY3NtbCddLFxuICAgIFsnY3NwJywgJ2FwcGxpY2F0aW9uL3ZuZC5jb21tb25zcGFjZSddLFxuICAgIFsnY3NzJywgWyd0ZXh0L2NzcycsICdhcHBsaWNhdGlvbi94LXBvaW50cGx1cyddXSxcbiAgICBbJ2NzdicsICd0ZXh0L2NzdiddLFxuICAgIFsnY3UnLCAnYXBwbGljYXRpb24vY3Utc2VlbWUnXSxcbiAgICBbJ2N1cmwnLCAndGV4dC92bmQuY3VybCddLFxuICAgIFsnY3d3JywgJ2FwcGxpY2F0aW9uL3Bycy5jd3cnXSxcbiAgICBbJ2N4eCcsICd0ZXh0L3BsYWluJ10sXG4gICAgWydkYWUnLCAnbW9kZWwvdm5kLmNvbGxhZGEreG1sJ10sXG4gICAgWydkYWYnLCAnYXBwbGljYXRpb24vdm5kLm1vYml1cy5kYWYnXSxcbiAgICBbJ2Rhdm1vdW50JywgJ2FwcGxpY2F0aW9uL2Rhdm1vdW50K3htbCddLFxuICAgIFsnZGNyJywgJ2FwcGxpY2F0aW9uL3gtZGlyZWN0b3InXSxcbiAgICBbJ2RjdXJsJywgJ3RleHQvdm5kLmN1cmwuZGN1cmwnXSxcbiAgICBbJ2RkMicsICdhcHBsaWNhdGlvbi92bmQub21hLmRkMit4bWwnXSxcbiAgICBbJ2RkZCcsICdhcHBsaWNhdGlvbi92bmQuZnVqaXhlcm94LmRkZCddLFxuICAgIFsnZGViJywgJ2FwcGxpY2F0aW9uL3gtZGViaWFuLXBhY2thZ2UnXSxcbiAgICBbJ2RlZXB2JywgJ2FwcGxpY2F0aW9uL3gtZGVlcHYnXSxcbiAgICBbJ2RlZicsICd0ZXh0L3BsYWluJ10sXG4gICAgWydkZXInLCAnYXBwbGljYXRpb24veC14NTA5LWNhLWNlcnQnXSxcbiAgICBbJ2RmYWMnLCAnYXBwbGljYXRpb24vdm5kLmRyZWFtZmFjdG9yeSddLFxuICAgIFsnZGlmJywgJ3ZpZGVvL3gtZHYnXSxcbiAgICBbJ2RpcicsICdhcHBsaWNhdGlvbi94LWRpcmVjdG9yJ10sXG4gICAgWydkaXMnLCAnYXBwbGljYXRpb24vdm5kLm1vYml1cy5kaXMnXSxcbiAgICBbJ2RqdnUnLCAnaW1hZ2Uvdm5kLmRqdnUnXSxcbiAgICBbJ2RsJywgWyd2aWRlby9kbCcsICd2aWRlby94LWRsJ11dLFxuICAgIFsnZGxsJywgJ2FwcGxpY2F0aW9uL3gtbXNkb3dubG9hZCddLFxuICAgIFsnZG1zJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSddLFxuICAgIFsnZG5hJywgJ2FwcGxpY2F0aW9uL3ZuZC5kbmEnXSxcbiAgICBbJ2RvYycsICdhcHBsaWNhdGlvbi9tc3dvcmQnXSxcbiAgICBbJ2RvY20nLCAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmQuZG9jdW1lbnQubWFjcm9lbmFibGVkLjEyJ10sXG4gICAgWydkb2N4JywgJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50J10sXG4gICAgWydkb3QnLCAnYXBwbGljYXRpb24vbXN3b3JkJ10sXG4gICAgWydkb3RtJywgJ2FwcGxpY2F0aW9uL3ZuZC5tcy13b3JkLnRlbXBsYXRlLm1hY3JvZW5hYmxlZC4xMiddLFxuICAgIFsnZG90eCcsICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC50ZW1wbGF0ZSddLFxuICAgIFsnZHAnLCBbJ2FwcGxpY2F0aW9uL2NvbW1vbmdyb3VuZCcsICdhcHBsaWNhdGlvbi92bmQub3NnaS5kcCddXSxcbiAgICBbJ2RwZycsICdhcHBsaWNhdGlvbi92bmQuZHBncmFwaCddLFxuICAgIFsnZHJhJywgJ2F1ZGlvL3ZuZC5kcmEnXSxcbiAgICBbJ2RydycsICdhcHBsaWNhdGlvbi9kcmFmdGluZyddLFxuICAgIFsnZHNjJywgJ3RleHQvcHJzLmxpbmVzLnRhZyddLFxuICAgIFsnZHNzYycsICdhcHBsaWNhdGlvbi9kc3NjK2RlciddLFxuICAgIFsnZHRiJywgJ2FwcGxpY2F0aW9uL3gtZHRib29rK3htbCddLFxuICAgIFsnZHRkJywgJ2FwcGxpY2F0aW9uL3htbC1kdGQnXSxcbiAgICBbJ2R0cycsICdhdWRpby92bmQuZHRzJ10sXG4gICAgWydkdHNoZCcsICdhdWRpby92bmQuZHRzLmhkJ10sXG4gICAgWydkdW1wJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSddLFxuICAgIFsnZHYnLCAndmlkZW8veC1kdiddLFxuICAgIFsnZHZpJywgJ2FwcGxpY2F0aW9uL3gtZHZpJ10sXG4gICAgWydkd2YnLCBbJ21vZGVsL3ZuZC5kd2YnLCAnZHJhd2luZy94LWR3ZiddXSxcbiAgICBbJ2R3ZycsIFsnYXBwbGljYXRpb24vYWNhZCcsICdpbWFnZS92bmQuZHdnJywgJ2ltYWdlL3gtZHdnJ11dLFxuICAgIFsnZHhmJywgWydhcHBsaWNhdGlvbi9keGYnLCAnaW1hZ2Uvdm5kLmR3ZycsICdpbWFnZS92bmQuZHhmJywgJ2ltYWdlL3gtZHdnJ11dLFxuICAgIFsnZHhwJywgJ2FwcGxpY2F0aW9uL3ZuZC5zcG90ZmlyZS5keHAnXSxcbiAgICBbJ2R4cicsICdhcHBsaWNhdGlvbi94LWRpcmVjdG9yJ10sXG4gICAgWydlY2VscDQ4MDAnLCAnYXVkaW8vdm5kLm51ZXJhLmVjZWxwNDgwMCddLFxuICAgIFsnZWNlbHA3NDcwJywgJ2F1ZGlvL3ZuZC5udWVyYS5lY2VscDc0NzAnXSxcbiAgICBbJ2VjZWxwOTYwMCcsICdhdWRpby92bmQubnVlcmEuZWNlbHA5NjAwJ10sXG4gICAgWydlZG0nLCAnYXBwbGljYXRpb24vdm5kLm5vdmFkaWdtLmVkbSddLFxuICAgIFsnZWR4JywgJ2FwcGxpY2F0aW9uL3ZuZC5ub3ZhZGlnbS5lZHgnXSxcbiAgICBbJ2VmaWYnLCAnYXBwbGljYXRpb24vdm5kLnBpY3NlbCddLFxuICAgIFsnZWk2JywgJ2FwcGxpY2F0aW9uL3ZuZC5wZy5vc2FzbGknXSxcbiAgICBbJ2VsJywgJ3RleHQveC1zY3JpcHQuZWxpc3AnXSxcbiAgICBbJ2VsYycsIFsnYXBwbGljYXRpb24veC1lbGMnLCAnYXBwbGljYXRpb24veC1ieXRlY29kZS5lbGlzcCddXSxcbiAgICBbJ2VtbCcsICdtZXNzYWdlL3JmYzgyMiddLFxuICAgIFsnZW1tYScsICdhcHBsaWNhdGlvbi9lbW1hK3htbCddLFxuICAgIFsnZW52JywgJ2FwcGxpY2F0aW9uL3gtZW52b3knXSxcbiAgICBbJ2VvbCcsICdhdWRpby92bmQuZGlnaXRhbC13aW5kcyddLFxuICAgIFsnZW90JywgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0J10sXG4gICAgWydlcHMnLCAnYXBwbGljYXRpb24vcG9zdHNjcmlwdCddLFxuICAgIFsnZXB1YicsICdhcHBsaWNhdGlvbi9lcHViK3ppcCddLFxuICAgIFsnZXMnLCBbJ2FwcGxpY2F0aW9uL2VjbWFzY3JpcHQnLCAnYXBwbGljYXRpb24veC1lc3JlaGJlciddXSxcbiAgICBbJ2VzMycsICdhcHBsaWNhdGlvbi92bmQuZXN6aWdubzMreG1sJ10sXG4gICAgWydlc2YnLCAnYXBwbGljYXRpb24vdm5kLmVwc29uLmVzZiddLFxuICAgIFsnZXR4JywgJ3RleHQveC1zZXRleHQnXSxcbiAgICBbJ2V2eScsIFsnYXBwbGljYXRpb24vZW52b3knLCAnYXBwbGljYXRpb24veC1lbnZveSddXSxcbiAgICBbJ2V4ZScsIFsnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJywgJ2FwcGxpY2F0aW9uL3gtbXNkb3dubG9hZCddXSxcbiAgICBbJ2V4aScsICdhcHBsaWNhdGlvbi9leGknXSxcbiAgICBbJ2V4dCcsICdhcHBsaWNhdGlvbi92bmQubm92YWRpZ20uZXh0J10sXG4gICAgWydlejInLCAnYXBwbGljYXRpb24vdm5kLmV6cGl4LWFsYnVtJ10sXG4gICAgWydlejMnLCAnYXBwbGljYXRpb24vdm5kLmV6cGl4LXBhY2thZ2UnXSxcbiAgICBbJ2YnLCBbJ3RleHQvcGxhaW4nLCAndGV4dC94LWZvcnRyYW4nXV0sXG4gICAgWydmNHYnLCAndmlkZW8veC1mNHYnXSxcbiAgICBbJ2Y3NycsICd0ZXh0L3gtZm9ydHJhbiddLFxuICAgIFsnZjkwJywgWyd0ZXh0L3BsYWluJywgJ3RleHQveC1mb3J0cmFuJ11dLFxuICAgIFsnZmJzJywgJ2ltYWdlL3ZuZC5mYXN0Ymlkc2hlZXQnXSxcbiAgICBbJ2ZjcycsICdhcHBsaWNhdGlvbi92bmQuaXNhYy5mY3MnXSxcbiAgICBbJ2ZkZicsICdhcHBsaWNhdGlvbi92bmQuZmRmJ10sXG4gICAgWydmZV9sYXVuY2gnLCAnYXBwbGljYXRpb24vdm5kLmRlbm92by5mY3NlbGF5b3V0LWxpbmsnXSxcbiAgICBbJ2ZnNScsICdhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5c2dwJ10sXG4gICAgWydmaCcsICdpbWFnZS94LWZyZWVoYW5kJ10sXG4gICAgWydmaWYnLCBbJ2FwcGxpY2F0aW9uL2ZyYWN0YWxzJywgJ2ltYWdlL2ZpZiddXSxcbiAgICBbJ2ZpZycsICdhcHBsaWNhdGlvbi94LXhmaWcnXSxcbiAgICBbJ2ZsaScsIFsndmlkZW8vZmxpJywgJ3ZpZGVvL3gtZmxpJ11dLFxuICAgIFsnZmxvJywgWydpbWFnZS9mbG9yaWFuJywgJ2FwcGxpY2F0aW9uL3ZuZC5taWNyb2dyYWZ4LmZsbyddXSxcbiAgICBbJ2ZscicsICd4LXdvcmxkL3gtdnJtbCddLFxuICAgIFsnZmx2JywgJ3ZpZGVvL3gtZmx2J10sXG4gICAgWydmbHcnLCAnYXBwbGljYXRpb24vdm5kLmtkZS5raXZpbyddLFxuICAgIFsnZmx4JywgJ3RleHQvdm5kLmZtaS5mbGV4c3RvciddLFxuICAgIFsnZmx5JywgJ3RleHQvdm5kLmZseSddLFxuICAgIFsnZm0nLCAnYXBwbGljYXRpb24vdm5kLmZyYW1lbWFrZXInXSxcbiAgICBbJ2ZtZicsICd2aWRlby94LWF0b21pYzNkLWZlYXR1cmUnXSxcbiAgICBbJ2ZuYycsICdhcHBsaWNhdGlvbi92bmQuZnJvZ2Fucy5mbmMnXSxcbiAgICBbJ2ZvcicsIFsndGV4dC9wbGFpbicsICd0ZXh0L3gtZm9ydHJhbiddXSxcbiAgICBbJ2ZweCcsIFsnaW1hZ2Uvdm5kLmZweCcsICdpbWFnZS92bmQubmV0LWZweCddXSxcbiAgICBbJ2ZybCcsICdhcHBsaWNhdGlvbi9mcmVlbG9hZGVyJ10sXG4gICAgWydmc2MnLCAnYXBwbGljYXRpb24vdm5kLmZzYy53ZWJsYXVuY2gnXSxcbiAgICBbJ2ZzdCcsICdpbWFnZS92bmQuZnN0J10sXG4gICAgWydmdGMnLCAnYXBwbGljYXRpb24vdm5kLmZsdXh0aW1lLmNsaXAnXSxcbiAgICBbJ2Z0aScsICdhcHBsaWNhdGlvbi92bmQuYW5zZXItd2ViLWZ1bmRzLXRyYW5zZmVyLWluaXRpYXRpb24nXSxcbiAgICBbJ2Z1bmsnLCAnYXVkaW8vbWFrZSddLFxuICAgIFsnZnZ0JywgJ3ZpZGVvL3ZuZC5mdnQnXSxcbiAgICBbJ2Z4cCcsICdhcHBsaWNhdGlvbi92bmQuYWRvYmUuZnhwJ10sXG4gICAgWydmenMnLCAnYXBwbGljYXRpb24vdm5kLmZ1enp5c2hlZXQnXSxcbiAgICBbJ2cnLCAndGV4dC9wbGFpbiddLFxuICAgIFsnZzJ3JywgJ2FwcGxpY2F0aW9uL3ZuZC5nZW9wbGFuJ10sXG4gICAgWydnMycsICdpbWFnZS9nM2ZheCddLFxuICAgIFsnZzN3JywgJ2FwcGxpY2F0aW9uL3ZuZC5nZW9zcGFjZSddLFxuICAgIFsnZ2FjJywgJ2FwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtYWNjb3VudCddLFxuICAgIFsnZ2RsJywgJ21vZGVsL3ZuZC5nZGwnXSxcbiAgICBbJ2dlbycsICdhcHBsaWNhdGlvbi92bmQuZHluYWdlbyddLFxuICAgIFsnZ2V4JywgJ2FwcGxpY2F0aW9uL3ZuZC5nZW9tZXRyeS1leHBsb3JlciddLFxuICAgIFsnZ2diJywgJ2FwcGxpY2F0aW9uL3ZuZC5nZW9nZWJyYS5maWxlJ10sXG4gICAgWydnZ3QnLCAnYXBwbGljYXRpb24vdm5kLmdlb2dlYnJhLnRvb2wnXSxcbiAgICBbJ2doZicsICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWhlbHAnXSxcbiAgICBbJ2dpZicsICdpbWFnZS9naWYnXSxcbiAgICBbJ2dpbScsICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWlkZW50aXR5LW1lc3NhZ2UnXSxcbiAgICBbJ2dsJywgWyd2aWRlby9nbCcsICd2aWRlby94LWdsJ11dLFxuICAgIFsnZ214JywgJ2FwcGxpY2F0aW9uL3ZuZC5nbXgnXSxcbiAgICBbJ2dudW1lcmljJywgJ2FwcGxpY2F0aW9uL3gtZ251bWVyaWMnXSxcbiAgICBbJ2dwaCcsICdhcHBsaWNhdGlvbi92bmQuZmxvZ3JhcGhpdCddLFxuICAgIFsnZ3FmJywgJ2FwcGxpY2F0aW9uL3ZuZC5ncmFmZXEnXSxcbiAgICBbJ2dyYW0nLCAnYXBwbGljYXRpb24vc3JncyddLFxuICAgIFsnZ3J2JywgJ2FwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtaW5qZWN0b3InXSxcbiAgICBbJ2dyeG1sJywgJ2FwcGxpY2F0aW9uL3NyZ3MreG1sJ10sXG4gICAgWydnc2QnLCAnYXVkaW8veC1nc20nXSxcbiAgICBbJ2dzZicsICdhcHBsaWNhdGlvbi94LWZvbnQtZ2hvc3RzY3JpcHQnXSxcbiAgICBbJ2dzbScsICdhdWRpby94LWdzbSddLFxuICAgIFsnZ3NwJywgJ2FwcGxpY2F0aW9uL3gtZ3NwJ10sXG4gICAgWydnc3MnLCAnYXBwbGljYXRpb24veC1nc3MnXSxcbiAgICBbJ2d0YXInLCAnYXBwbGljYXRpb24veC1ndGFyJ10sXG4gICAgWydndG0nLCAnYXBwbGljYXRpb24vdm5kLmdyb292ZS10b29sLW1lc3NhZ2UnXSxcbiAgICBbJ2d0dycsICdtb2RlbC92bmQuZ3R3J10sXG4gICAgWydndicsICd0ZXh0L3ZuZC5ncmFwaHZpeiddLFxuICAgIFsnZ3h0JywgJ2FwcGxpY2F0aW9uL3ZuZC5nZW9uZXh0J10sXG4gICAgWydneicsIFsnYXBwbGljYXRpb24veC1nemlwJywgJ2FwcGxpY2F0aW9uL3gtY29tcHJlc3NlZCddXSxcbiAgICBbJ2d6aXAnLCBbJ211bHRpcGFydC94LWd6aXAnLCAnYXBwbGljYXRpb24veC1nemlwJ11dLFxuICAgIFsnaCcsIFsndGV4dC9wbGFpbicsICd0ZXh0L3gtaCddXSxcbiAgICBbJ2gyNjEnLCAndmlkZW8vaDI2MSddLFxuICAgIFsnaDI2MycsICd2aWRlby9oMjYzJ10sXG4gICAgWydoMjY0JywgJ3ZpZGVvL2gyNjQnXSxcbiAgICBbJ2hhbCcsICdhcHBsaWNhdGlvbi92bmQuaGFsK3htbCddLFxuICAgIFsnaGJjaScsICdhcHBsaWNhdGlvbi92bmQuaGJjaSddLFxuICAgIFsnaGRmJywgJ2FwcGxpY2F0aW9uL3gtaGRmJ10sXG4gICAgWydoZWxwJywgJ2FwcGxpY2F0aW9uL3gtaGVscGZpbGUnXSxcbiAgICBbJ2hnbCcsICdhcHBsaWNhdGlvbi92bmQuaHAtaHBnbCddLFxuICAgIFsnaGgnLCBbJ3RleHQvcGxhaW4nLCAndGV4dC94LWgnXV0sXG4gICAgWydobGInLCAndGV4dC94LXNjcmlwdCddLFxuICAgIFsnaGxwJywgWydhcHBsaWNhdGlvbi93aW5obHAnLCAnYXBwbGljYXRpb24vaGxwJywgJ2FwcGxpY2F0aW9uL3gtaGVscGZpbGUnLCAnYXBwbGljYXRpb24veC13aW5oZWxwJ11dLFxuICAgIFsnaHBnJywgJ2FwcGxpY2F0aW9uL3ZuZC5ocC1ocGdsJ10sXG4gICAgWydocGdsJywgJ2FwcGxpY2F0aW9uL3ZuZC5ocC1ocGdsJ10sXG4gICAgWydocGlkJywgJ2FwcGxpY2F0aW9uL3ZuZC5ocC1ocGlkJ10sXG4gICAgWydocHMnLCAnYXBwbGljYXRpb24vdm5kLmhwLWhwcyddLFxuICAgIFtcbiAgICAgICAgJ2hxeCcsXG4gICAgICAgIFtcbiAgICAgICAgICAgICdhcHBsaWNhdGlvbi9tYWMtYmluaGV4NDAnLFxuICAgICAgICAgICAgJ2FwcGxpY2F0aW9uL2JpbmhleCcsXG4gICAgICAgICAgICAnYXBwbGljYXRpb24vYmluaGV4NCcsXG4gICAgICAgICAgICAnYXBwbGljYXRpb24vbWFjLWJpbmhleCcsXG4gICAgICAgICAgICAnYXBwbGljYXRpb24veC1iaW5oZXg0MCcsXG4gICAgICAgICAgICAnYXBwbGljYXRpb24veC1tYWMtYmluaGV4NDAnXG4gICAgICAgIF1cbiAgICBdLFxuICAgIFsnaHRhJywgJ2FwcGxpY2F0aW9uL2h0YSddLFxuICAgIFsnaHRjJywgJ3RleHQveC1jb21wb25lbnQnXSxcbiAgICBbJ2h0a2UnLCAnYXBwbGljYXRpb24vdm5kLmtlbmFtZWFhcHAnXSxcbiAgICBbJ2h0bScsICd0ZXh0L2h0bWwnXSxcbiAgICBbJ2h0bWwnLCAndGV4dC9odG1sJ10sXG4gICAgWydodG1scycsICd0ZXh0L2h0bWwnXSxcbiAgICBbJ2h0dCcsICd0ZXh0L3dlYnZpZXdodG1sJ10sXG4gICAgWydodHgnLCAndGV4dC9odG1sJ10sXG4gICAgWydodmQnLCAnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5odi1kaWMnXSxcbiAgICBbJ2h2cCcsICdhcHBsaWNhdGlvbi92bmQueWFtYWhhLmh2LXZvaWNlJ10sXG4gICAgWydodnMnLCAnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5odi1zY3JpcHQnXSxcbiAgICBbJ2kyZycsICdhcHBsaWNhdGlvbi92bmQuaW50ZXJnZW8nXSxcbiAgICBbJ2ljYycsICdhcHBsaWNhdGlvbi92bmQuaWNjcHJvZmlsZSddLFxuICAgIFsnaWNlJywgJ3gtY29uZmVyZW5jZS94LWNvb2x0YWxrJ10sXG4gICAgWydpY28nLCAnaW1hZ2UveC1pY29uJ10sXG4gICAgWydpY3MnLCAndGV4dC9jYWxlbmRhciddLFxuICAgIFsnaWRjJywgJ3RleHQvcGxhaW4nXSxcbiAgICBbJ2llZicsICdpbWFnZS9pZWYnXSxcbiAgICBbJ2llZnMnLCAnaW1hZ2UvaWVmJ10sXG4gICAgWydpZm0nLCAnYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLmZvcm1kYXRhJ10sXG4gICAgWydpZ2VzJywgWydhcHBsaWNhdGlvbi9pZ2VzJywgJ21vZGVsL2lnZXMnXV0sXG4gICAgWydpZ2wnLCAnYXBwbGljYXRpb24vdm5kLmlnbG9hZGVyJ10sXG4gICAgWydpZ20nLCAnYXBwbGljYXRpb24vdm5kLmluc29ycy5pZ20nXSxcbiAgICBbJ2lncycsIFsnYXBwbGljYXRpb24vaWdlcycsICdtb2RlbC9pZ2VzJ11dLFxuICAgIFsnaWd4JywgJ2FwcGxpY2F0aW9uL3ZuZC5taWNyb2dyYWZ4LmlneCddLFxuICAgIFsnaWlmJywgJ2FwcGxpY2F0aW9uL3ZuZC5zaGFuYS5pbmZvcm1lZC5pbnRlcmNoYW5nZSddLFxuICAgIFsnaWlpJywgJ2FwcGxpY2F0aW9uL3gtaXBob25lJ10sXG4gICAgWydpbWEnLCAnYXBwbGljYXRpb24veC1pbWEnXSxcbiAgICBbJ2ltYXAnLCAnYXBwbGljYXRpb24veC1odHRwZC1pbWFwJ10sXG4gICAgWydpbXAnLCAnYXBwbGljYXRpb24vdm5kLmFjY3BhYy5zaW1wbHkuaW1wJ10sXG4gICAgWydpbXMnLCAnYXBwbGljYXRpb24vdm5kLm1zLWltcyddLFxuICAgIFsnaW5mJywgJ2FwcGxpY2F0aW9uL2luZiddLFxuICAgIFsnaW5zJywgWydhcHBsaWNhdGlvbi94LWludGVybmV0LXNpZ251cCcsICdhcHBsaWNhdGlvbi94LWludGVybmV0dC1zaWdudXAnXV0sXG4gICAgWydpcCcsICdhcHBsaWNhdGlvbi94LWlwMiddLFxuICAgIFsnaXBmaXgnLCAnYXBwbGljYXRpb24vaXBmaXgnXSxcbiAgICBbJ2lwaycsICdhcHBsaWNhdGlvbi92bmQuc2hhbmEuaW5mb3JtZWQucGFja2FnZSddLFxuICAgIFsnaXJtJywgJ2FwcGxpY2F0aW9uL3ZuZC5pYm0ucmlnaHRzLW1hbmFnZW1lbnQnXSxcbiAgICBbJ2lycCcsICdhcHBsaWNhdGlvbi92bmQuaXJlcG9zaXRvcnkucGFja2FnZSt4bWwnXSxcbiAgICBbJ2lzcCcsICdhcHBsaWNhdGlvbi94LWludGVybmV0LXNpZ251cCddLFxuICAgIFsnaXN1JywgJ3ZpZGVvL3gtaXN2aWRlbyddLFxuICAgIFsnaXQnLCAnYXVkaW8vaXQnXSxcbiAgICBbJ2l0cCcsICdhcHBsaWNhdGlvbi92bmQuc2hhbmEuaW5mb3JtZWQuZm9ybXRlbXBsYXRlJ10sXG4gICAgWydpdicsICdhcHBsaWNhdGlvbi94LWludmVudG9yJ10sXG4gICAgWydpdnAnLCAnYXBwbGljYXRpb24vdm5kLmltbWVydmlzaW9uLWl2cCddLFxuICAgIFsnaXZyJywgJ2ktd29ybGQvaS12cm1sJ10sXG4gICAgWydpdnUnLCAnYXBwbGljYXRpb24vdm5kLmltbWVydmlzaW9uLWl2dSddLFxuICAgIFsnaXZ5JywgJ2FwcGxpY2F0aW9uL3gtbGl2ZXNjcmVlbiddLFxuICAgIFsnamFkJywgJ3RleHQvdm5kLnN1bi5qMm1lLmFwcC1kZXNjcmlwdG9yJ10sXG4gICAgWydqYW0nLCBbJ2FwcGxpY2F0aW9uL3ZuZC5qYW0nLCAnYXVkaW8veC1qYW0nXV0sXG4gICAgWydqYXInLCAnYXBwbGljYXRpb24vamF2YS1hcmNoaXZlJ10sXG4gICAgWydqYXYnLCBbJ3RleHQvcGxhaW4nLCAndGV4dC94LWphdmEtc291cmNlJ11dLFxuICAgIFsnamF2YScsIFsndGV4dC9wbGFpbicsICd0ZXh0L3gtamF2YS1zb3VyY2UsamF2YScsICd0ZXh0L3gtamF2YS1zb3VyY2UnXV0sXG4gICAgWydqY20nLCAnYXBwbGljYXRpb24veC1qYXZhLWNvbW1lcmNlJ10sXG4gICAgWydqZmlmJywgWydpbWFnZS9waXBlZycsICdpbWFnZS9qcGVnJywgJ2ltYWdlL3BqcGVnJ11dLFxuICAgIFsnamZpZi10Ym5sJywgJ2ltYWdlL2pwZWcnXSxcbiAgICBbJ2ppc3AnLCAnYXBwbGljYXRpb24vdm5kLmppc3AnXSxcbiAgICBbJ2psdCcsICdhcHBsaWNhdGlvbi92bmQuaHAtamx5dCddLFxuICAgIFsnam5scCcsICdhcHBsaWNhdGlvbi94LWphdmEtam5scC1maWxlJ10sXG4gICAgWydqb2RhJywgJ2FwcGxpY2F0aW9uL3ZuZC5qb29zdC5qb2RhLWFyY2hpdmUnXSxcbiAgICBbJ2pwZScsIFsnaW1hZ2UvanBlZycsICdpbWFnZS9wanBlZyddXSxcbiAgICBbJ2pwZWcnLCBbJ2ltYWdlL2pwZWcnLCAnaW1hZ2UvcGpwZWcnXV0sXG4gICAgWydqcGcnLCBbJ2ltYWdlL2pwZWcnLCAnaW1hZ2UvcGpwZWcnXV0sXG4gICAgWydqcGd2JywgJ3ZpZGVvL2pwZWcnXSxcbiAgICBbJ2pwbScsICd2aWRlby9qcG0nXSxcbiAgICBbJ2pwcycsICdpbWFnZS94LWpwcyddLFxuICAgIFsnanMnLCBbJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLCAnYXBwbGljYXRpb24vZWNtYXNjcmlwdCcsICd0ZXh0L2phdmFzY3JpcHQnLCAndGV4dC9lY21hc2NyaXB0JywgJ2FwcGxpY2F0aW9uL3gtamF2YXNjcmlwdCddXSxcbiAgICBbJ2pzb24nLCAnYXBwbGljYXRpb24vanNvbiddLFxuICAgIFsnanV0JywgJ2ltYWdlL2p1dHZpc2lvbiddLFxuICAgIFsna2FyJywgWydhdWRpby9taWRpJywgJ211c2ljL3gta2FyYW9rZSddXSxcbiAgICBbJ2thcmJvbicsICdhcHBsaWNhdGlvbi92bmQua2RlLmthcmJvbiddLFxuICAgIFsna2ZvJywgJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua2Zvcm11bGEnXSxcbiAgICBbJ2tpYScsICdhcHBsaWNhdGlvbi92bmQua2lkc3BpcmF0aW9uJ10sXG4gICAgWydrbWwnLCAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbWwreG1sJ10sXG4gICAgWydrbXonLCAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbXonXSxcbiAgICBbJ2tuZScsICdhcHBsaWNhdGlvbi92bmQua2luYXInXSxcbiAgICBbJ2tvbicsICdhcHBsaWNhdGlvbi92bmQua2RlLmtvbnRvdXInXSxcbiAgICBbJ2twcicsICdhcHBsaWNhdGlvbi92bmQua2RlLmtwcmVzZW50ZXInXSxcbiAgICBbJ2tzaCcsIFsnYXBwbGljYXRpb24veC1rc2gnLCAndGV4dC94LXNjcmlwdC5rc2gnXV0sXG4gICAgWydrc3AnLCAnYXBwbGljYXRpb24vdm5kLmtkZS5rc3ByZWFkJ10sXG4gICAgWydrdHgnLCAnaW1hZ2Uva3R4J10sXG4gICAgWydrdHonLCAnYXBwbGljYXRpb24vdm5kLmthaG9vdHonXSxcbiAgICBbJ2t3ZCcsICdhcHBsaWNhdGlvbi92bmQua2RlLmt3b3JkJ10sXG4gICAgWydsYScsIFsnYXVkaW8vbnNwYXVkaW8nLCAnYXVkaW8veC1uc3BhdWRpbyddXSxcbiAgICBbJ2xhbScsICdhdWRpby94LWxpdmVhdWRpbyddLFxuICAgIFsnbGFzeG1sJywgJ2FwcGxpY2F0aW9uL3ZuZC5sYXMubGFzK3htbCddLFxuICAgIFsnbGF0ZXgnLCAnYXBwbGljYXRpb24veC1sYXRleCddLFxuICAgIFsnbGJkJywgJ2FwcGxpY2F0aW9uL3ZuZC5sbGFtYWdyYXBoaWNzLmxpZmUtYmFsYW5jZS5kZXNrdG9wJ10sXG4gICAgWydsYmUnLCAnYXBwbGljYXRpb24vdm5kLmxsYW1hZ3JhcGhpY3MubGlmZS1iYWxhbmNlLmV4Y2hhbmdlK3htbCddLFxuICAgIFsnbGVzJywgJ2FwcGxpY2F0aW9uL3ZuZC5oaGUubGVzc29uLXBsYXllciddLFxuICAgIFsnbGhhJywgWydhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLCAnYXBwbGljYXRpb24vbGhhJywgJ2FwcGxpY2F0aW9uL3gtbGhhJ11dLFxuICAgIFsnbGh4JywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSddLFxuICAgIFsnbGluazY2JywgJ2FwcGxpY2F0aW9uL3ZuZC5yb3V0ZTY2Lmxpbms2Nit4bWwnXSxcbiAgICBbJ2xpc3QnLCAndGV4dC9wbGFpbiddLFxuICAgIFsnbG1hJywgWydhdWRpby9uc3BhdWRpbycsICdhdWRpby94LW5zcGF1ZGlvJ11dLFxuICAgIFsnbG9nJywgJ3RleHQvcGxhaW4nXSxcbiAgICBbJ2xybScsICdhcHBsaWNhdGlvbi92bmQubXMtbHJtJ10sXG4gICAgWydsc2YnLCAndmlkZW8veC1sYS1hc2YnXSxcbiAgICBbJ2xzcCcsIFsnYXBwbGljYXRpb24veC1saXNwJywgJ3RleHQveC1zY3JpcHQubGlzcCddXSxcbiAgICBbJ2xzdCcsICd0ZXh0L3BsYWluJ10sXG4gICAgWydsc3gnLCBbJ3ZpZGVvL3gtbGEtYXNmJywgJ3RleHQveC1sYS1hc2YnXV0sXG4gICAgWydsdGYnLCAnYXBwbGljYXRpb24vdm5kLmZyb2dhbnMubHRmJ10sXG4gICAgWydsdHgnLCAnYXBwbGljYXRpb24veC1sYXRleCddLFxuICAgIFsnbHZwJywgJ2F1ZGlvL3ZuZC5sdWNlbnQudm9pY2UnXSxcbiAgICBbJ2x3cCcsICdhcHBsaWNhdGlvbi92bmQubG90dXMtd29yZHBybyddLFxuICAgIFsnbHpoJywgWydhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLCAnYXBwbGljYXRpb24veC1semgnXV0sXG4gICAgWydsengnLCBbJ2FwcGxpY2F0aW9uL2x6eCcsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLCAnYXBwbGljYXRpb24veC1sengnXV0sXG4gICAgWydtJywgWyd0ZXh0L3BsYWluJywgJ3RleHQveC1tJ11dLFxuICAgIFsnbTEzJywgJ2FwcGxpY2F0aW9uL3gtbXNtZWRpYXZpZXcnXSxcbiAgICBbJ20xNCcsICdhcHBsaWNhdGlvbi94LW1zbWVkaWF2aWV3J10sXG4gICAgWydtMXYnLCAndmlkZW8vbXBlZyddLFxuICAgIFsnbTIxJywgJ2FwcGxpY2F0aW9uL21wMjEnXSxcbiAgICBbJ20yYScsICdhdWRpby9tcGVnJ10sXG4gICAgWydtMnYnLCAndmlkZW8vbXBlZyddLFxuICAgIFsnbTN1JywgWydhdWRpby94LW1wZWd1cmwnLCAnYXVkaW8veC1tcGVxdXJsJ11dLFxuICAgIFsnbTN1OCcsICdhcHBsaWNhdGlvbi92bmQuYXBwbGUubXBlZ3VybCddLFxuICAgIFsnbTR2JywgJ3ZpZGVvL3gtbTR2J10sXG4gICAgWydtYScsICdhcHBsaWNhdGlvbi9tYXRoZW1hdGljYSddLFxuICAgIFsnbWFkcycsICdhcHBsaWNhdGlvbi9tYWRzK3htbCddLFxuICAgIFsnbWFnJywgJ2FwcGxpY2F0aW9uL3ZuZC5lY293aW4uY2hhcnQnXSxcbiAgICBbJ21hbicsICdhcHBsaWNhdGlvbi94LXRyb2ZmLW1hbiddLFxuICAgIFsnbWFwJywgJ2FwcGxpY2F0aW9uL3gtbmF2aW1hcCddLFxuICAgIFsnbWFyJywgJ3RleHQvcGxhaW4nXSxcbiAgICBbJ21hdGhtbCcsICdhcHBsaWNhdGlvbi9tYXRobWwreG1sJ10sXG4gICAgWydtYmQnLCAnYXBwbGljYXRpb24vbWJlZGxldCddLFxuICAgIFsnbWJrJywgJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMubWJrJ10sXG4gICAgWydtYm94JywgJ2FwcGxpY2F0aW9uL21ib3gnXSxcbiAgICBbJ21jJCcsICdhcHBsaWNhdGlvbi94LW1hZ2ljLWNhcC1wYWNrYWdlLTEuMCddLFxuICAgIFsnbWMxJywgJ2FwcGxpY2F0aW9uL3ZuZC5tZWRjYWxjZGF0YSddLFxuICAgIFsnbWNkJywgWydhcHBsaWNhdGlvbi9tY2FkJywgJ2FwcGxpY2F0aW9uL3ZuZC5tY2QnLCAnYXBwbGljYXRpb24veC1tYXRoY2FkJ11dLFxuICAgIFsnbWNmJywgWydpbWFnZS92YXNhJywgJ3RleHQvbWNmJ11dLFxuICAgIFsnbWNwJywgJ2FwcGxpY2F0aW9uL25ldG1jJ10sXG4gICAgWydtY3VybCcsICd0ZXh0L3ZuZC5jdXJsLm1jdXJsJ10sXG4gICAgWydtZGInLCAnYXBwbGljYXRpb24veC1tc2FjY2VzcyddLFxuICAgIFsnbWRpJywgJ2ltYWdlL3ZuZC5tcy1tb2RpJ10sXG4gICAgWydtZScsICdhcHBsaWNhdGlvbi94LXRyb2ZmLW1lJ10sXG4gICAgWydtZXRhNCcsICdhcHBsaWNhdGlvbi9tZXRhbGluazQreG1sJ10sXG4gICAgWydtZXRzJywgJ2FwcGxpY2F0aW9uL21ldHMreG1sJ10sXG4gICAgWydtZm0nLCAnYXBwbGljYXRpb24vdm5kLm1mbXAnXSxcbiAgICBbJ21ncCcsICdhcHBsaWNhdGlvbi92bmQub3NnZW8ubWFwZ3VpZGUucGFja2FnZSddLFxuICAgIFsnbWd6JywgJ2FwcGxpY2F0aW9uL3ZuZC5wcm90ZXVzLm1hZ2F6aW5lJ10sXG4gICAgWydtaHQnLCAnbWVzc2FnZS9yZmM4MjInXSxcbiAgICBbJ21odG1sJywgJ21lc3NhZ2UvcmZjODIyJ10sXG4gICAgWydtaWQnLCBbJ2F1ZGlvL21pZCcsICdhdWRpby9taWRpJywgJ211c2ljL2NyZXNjZW5kbycsICd4LW11c2ljL3gtbWlkaScsICdhdWRpby94LW1pZGknLCAnYXBwbGljYXRpb24veC1taWRpJywgJ2F1ZGlvL3gtbWlkJ11dLFxuICAgIFsnbWlkaScsIFsnYXVkaW8vbWlkaScsICdtdXNpYy9jcmVzY2VuZG8nLCAneC1tdXNpYy94LW1pZGknLCAnYXVkaW8veC1taWRpJywgJ2FwcGxpY2F0aW9uL3gtbWlkaScsICdhdWRpby94LW1pZCddXSxcbiAgICBbJ21pZicsIFsnYXBwbGljYXRpb24vdm5kLm1pZicsICdhcHBsaWNhdGlvbi94LW1pZicsICdhcHBsaWNhdGlvbi94LWZyYW1lJ11dLFxuICAgIFsnbWltZScsIFsnbWVzc2FnZS9yZmM4MjInLCAnd3d3L21pbWUnXV0sXG4gICAgWydtajInLCAndmlkZW8vbWoyJ10sXG4gICAgWydtamYnLCAnYXVkaW8veC12bmQuYXVkaW9leHBsb3Npb24ubWp1aWNlbWVkaWFmaWxlJ10sXG4gICAgWydtanBnJywgJ3ZpZGVvL3gtbW90aW9uLWpwZWcnXSxcbiAgICBbJ21scCcsICdhcHBsaWNhdGlvbi92bmQuZG9sYnkubWxwJ10sXG4gICAgWydtbScsIFsnYXBwbGljYXRpb24vYmFzZTY0JywgJ2FwcGxpY2F0aW9uL3gtbWVtZSddXSxcbiAgICBbJ21tZCcsICdhcHBsaWNhdGlvbi92bmQuY2hpcG51dHMua2FyYW9rZS1tbWQnXSxcbiAgICBbJ21tZScsICdhcHBsaWNhdGlvbi9iYXNlNjQnXSxcbiAgICBbJ21tZicsICdhcHBsaWNhdGlvbi92bmQuc21hZiddLFxuICAgIFsnbW1yJywgJ2ltYWdlL3ZuZC5mdWppeGVyb3guZWRtaWNzLW1tciddLFxuICAgIFsnbW55JywgJ2FwcGxpY2F0aW9uL3gtbXNtb25leSddLFxuICAgIFsnbW9kJywgWydhdWRpby9tb2QnLCAnYXVkaW8veC1tb2QnXV0sXG4gICAgWydtb2RzJywgJ2FwcGxpY2F0aW9uL21vZHMreG1sJ10sXG4gICAgWydtb292JywgJ3ZpZGVvL3F1aWNrdGltZSddLFxuICAgIFsnbW92JywgJ3ZpZGVvL3F1aWNrdGltZSddLFxuICAgIFsnbW92aWUnLCAndmlkZW8veC1zZ2ktbW92aWUnXSxcbiAgICBbJ21wMicsIFsndmlkZW8vbXBlZycsICdhdWRpby9tcGVnJywgJ3ZpZGVvL3gtbXBlZycsICdhdWRpby94LW1wZWcnLCAndmlkZW8veC1tcGVxMmEnXV0sXG4gICAgWydtcDMnLCBbJ2F1ZGlvL21wZWcnLCAnYXVkaW8vbXBlZzMnLCAndmlkZW8vbXBlZycsICdhdWRpby94LW1wZWctMycsICd2aWRlby94LW1wZWcnXV0sXG4gICAgWydtcDQnLCBbJ3ZpZGVvL21wNCcsICdhcHBsaWNhdGlvbi9tcDQnXV0sXG4gICAgWydtcDRhJywgJ2F1ZGlvL21wNCddLFxuICAgIFsnbXBhJywgWyd2aWRlby9tcGVnJywgJ2F1ZGlvL21wZWcnXV0sXG4gICAgWydtcGMnLCBbJ2FwcGxpY2F0aW9uL3ZuZC5tb3BodW4uY2VydGlmaWNhdGUnLCAnYXBwbGljYXRpb24veC1wcm9qZWN0J11dLFxuICAgIFsnbXBlJywgJ3ZpZGVvL21wZWcnXSxcbiAgICBbJ21wZWcnLCAndmlkZW8vbXBlZyddLFxuICAgIFsnbXBnJywgWyd2aWRlby9tcGVnJywgJ2F1ZGlvL21wZWcnXV0sXG4gICAgWydtcGdhJywgJ2F1ZGlvL21wZWcnXSxcbiAgICBbJ21wa2cnLCAnYXBwbGljYXRpb24vdm5kLmFwcGxlLmluc3RhbGxlcit4bWwnXSxcbiAgICBbJ21wbScsICdhcHBsaWNhdGlvbi92bmQuYmx1ZWljZS5tdWx0aXBhc3MnXSxcbiAgICBbJ21wbicsICdhcHBsaWNhdGlvbi92bmQubW9waHVuLmFwcGxpY2F0aW9uJ10sXG4gICAgWydtcHAnLCAnYXBwbGljYXRpb24vdm5kLm1zLXByb2plY3QnXSxcbiAgICBbJ21wdCcsICdhcHBsaWNhdGlvbi94LXByb2plY3QnXSxcbiAgICBbJ21wdicsICdhcHBsaWNhdGlvbi94LXByb2plY3QnXSxcbiAgICBbJ21wdjInLCAndmlkZW8vbXBlZyddLFxuICAgIFsnbXB4JywgJ2FwcGxpY2F0aW9uL3gtcHJvamVjdCddLFxuICAgIFsnbXB5JywgJ2FwcGxpY2F0aW9uL3ZuZC5pYm0ubWluaXBheSddLFxuICAgIFsnbXF5JywgJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMubXF5J10sXG4gICAgWydtcmMnLCAnYXBwbGljYXRpb24vbWFyYyddLFxuICAgIFsnbXJjeCcsICdhcHBsaWNhdGlvbi9tYXJjeG1sK3htbCddLFxuICAgIFsnbXMnLCAnYXBwbGljYXRpb24veC10cm9mZi1tcyddLFxuICAgIFsnbXNjbWwnLCAnYXBwbGljYXRpb24vbWVkaWFzZXJ2ZXJjb250cm9sK3htbCddLFxuICAgIFsnbXNlcScsICdhcHBsaWNhdGlvbi92bmQubXNlcSddLFxuICAgIFsnbXNmJywgJ2FwcGxpY2F0aW9uL3ZuZC5lcHNvbi5tc2YnXSxcbiAgICBbJ21zZycsICdhcHBsaWNhdGlvbi92bmQubXMtb3V0bG9vayddLFxuICAgIFsnbXNoJywgJ21vZGVsL21lc2gnXSxcbiAgICBbJ21zbCcsICdhcHBsaWNhdGlvbi92bmQubW9iaXVzLm1zbCddLFxuICAgIFsnbXN0eScsICdhcHBsaWNhdGlvbi92bmQubXV2ZWUuc3R5bGUnXSxcbiAgICBbJ210cycsICdtb2RlbC92bmQubXRzJ10sXG4gICAgWydtdXMnLCAnYXBwbGljYXRpb24vdm5kLm11c2ljaWFuJ10sXG4gICAgWydtdXNpY3htbCcsICdhcHBsaWNhdGlvbi92bmQucmVjb3JkYXJlLm11c2ljeG1sK3htbCddLFxuICAgIFsnbXYnLCAndmlkZW8veC1zZ2ktbW92aWUnXSxcbiAgICBbJ212YicsICdhcHBsaWNhdGlvbi94LW1zbWVkaWF2aWV3J10sXG4gICAgWydtd2YnLCAnYXBwbGljYXRpb24vdm5kLm1mZXInXSxcbiAgICBbJ214ZicsICdhcHBsaWNhdGlvbi9teGYnXSxcbiAgICBbJ214bCcsICdhcHBsaWNhdGlvbi92bmQucmVjb3JkYXJlLm11c2ljeG1sJ10sXG4gICAgWydteG1sJywgJ2FwcGxpY2F0aW9uL3h2K3htbCddLFxuICAgIFsnbXhzJywgJ2FwcGxpY2F0aW9uL3ZuZC50cmlzY2FwZS5teHMnXSxcbiAgICBbJ214dScsICd2aWRlby92bmQubXBlZ3VybCddLFxuICAgIFsnbXknLCAnYXVkaW8vbWFrZSddLFxuICAgIFsnbXp6JywgJ2FwcGxpY2F0aW9uL3gtdm5kLmF1ZGlvZXhwbG9zaW9uLm16eiddLFxuICAgIFsnbi1nYWdlJywgJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5uLWdhZ2Uuc3ltYmlhbi5pbnN0YWxsJ10sXG4gICAgWyduMycsICd0ZXh0L24zJ10sXG4gICAgWyduYXAnLCAnaW1hZ2UvbmFwbHBzJ10sXG4gICAgWyduYXBscHMnLCAnaW1hZ2UvbmFwbHBzJ10sXG4gICAgWyduYnAnLCAnYXBwbGljYXRpb24vdm5kLndvbGZyYW0ucGxheWVyJ10sXG4gICAgWyduYycsICdhcHBsaWNhdGlvbi94LW5ldGNkZiddLFxuICAgIFsnbmNtJywgJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5jb25maWd1cmF0aW9uLW1lc3NhZ2UnXSxcbiAgICBbJ25jeCcsICdhcHBsaWNhdGlvbi94LWR0Ym5jeCt4bWwnXSxcbiAgICBbJ25nZGF0JywgJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5uLWdhZ2UuZGF0YSddLFxuICAgIFsnbmlmJywgJ2ltYWdlL3gtbmlmZiddLFxuICAgIFsnbmlmZicsICdpbWFnZS94LW5pZmYnXSxcbiAgICBbJ25peCcsICdhcHBsaWNhdGlvbi94LW1peC10cmFuc2ZlciddLFxuICAgIFsnbmx1JywgJ2FwcGxpY2F0aW9uL3ZuZC5uZXVyb2xhbmd1YWdlLm5sdSddLFxuICAgIFsnbm1sJywgJ2FwcGxpY2F0aW9uL3ZuZC5lbmxpdmVuJ10sXG4gICAgWydubmQnLCAnYXBwbGljYXRpb24vdm5kLm5vYmxlbmV0LWRpcmVjdG9yeSddLFxuICAgIFsnbm5zJywgJ2FwcGxpY2F0aW9uL3ZuZC5ub2JsZW5ldC1zZWFsZXInXSxcbiAgICBbJ25udycsICdhcHBsaWNhdGlvbi92bmQubm9ibGVuZXQtd2ViJ10sXG4gICAgWyducHgnLCAnaW1hZ2Uvdm5kLm5ldC1mcHgnXSxcbiAgICBbJ25zYycsICdhcHBsaWNhdGlvbi94LWNvbmZlcmVuY2UnXSxcbiAgICBbJ25zZicsICdhcHBsaWNhdGlvbi92bmQubG90dXMtbm90ZXMnXSxcbiAgICBbJ252ZCcsICdhcHBsaWNhdGlvbi94LW5hdmlkb2MnXSxcbiAgICBbJ253cycsICdtZXNzYWdlL3JmYzgyMiddLFxuICAgIFsnbycsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXSxcbiAgICBbJ29hMicsICdhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5czInXSxcbiAgICBbJ29hMycsICdhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5czMnXSxcbiAgICBbJ29hcycsICdhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5cyddLFxuICAgIFsnb2JkJywgJ2FwcGxpY2F0aW9uL3gtbXNiaW5kZXInXSxcbiAgICBbJ29kYScsICdhcHBsaWNhdGlvbi9vZGEnXSxcbiAgICBbJ29kYicsICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmRhdGFiYXNlJ10sXG4gICAgWydvZGMnLCAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5jaGFydCddLFxuICAgIFsnb2RmJywgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZm9ybXVsYSddLFxuICAgIFsnb2RmdCcsICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmZvcm11bGEtdGVtcGxhdGUnXSxcbiAgICBbJ29kZycsICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmdyYXBoaWNzJ10sXG4gICAgWydvZGknLCAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5pbWFnZSddLFxuICAgIFsnb2RtJywgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dC1tYXN0ZXInXSxcbiAgICBbJ29kcCcsICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnByZXNlbnRhdGlvbiddLFxuICAgIFsnb2RzJywgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuc3ByZWFkc2hlZXQnXSxcbiAgICBbJ29kdCcsICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQnXSxcbiAgICBbJ29nYScsICdhdWRpby9vZ2cnXSxcbiAgICBbJ29ndicsICd2aWRlby9vZ2cnXSxcbiAgICBbJ29neCcsICdhcHBsaWNhdGlvbi9vZ2cnXSxcbiAgICBbJ29tYycsICdhcHBsaWNhdGlvbi94LW9tYyddLFxuICAgIFsnb21jZCcsICdhcHBsaWNhdGlvbi94LW9tY2RhdGFtYWtlciddLFxuICAgIFsnb21jcicsICdhcHBsaWNhdGlvbi94LW9tY3JlZ2VyYXRvciddLFxuICAgIFsnb25ldG9jJywgJ2FwcGxpY2F0aW9uL29uZW5vdGUnXSxcbiAgICBbJ29wZicsICdhcHBsaWNhdGlvbi9vZWJwcy1wYWNrYWdlK3htbCddLFxuICAgIFsnb3JnJywgJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy1vcmdhbml6ZXInXSxcbiAgICBbJ29zZicsICdhcHBsaWNhdGlvbi92bmQueWFtYWhhLm9wZW5zY29yZWZvcm1hdCddLFxuICAgIFsnb3NmcHZnJywgJ2FwcGxpY2F0aW9uL3ZuZC55YW1haGEub3BlbnNjb3JlZm9ybWF0Lm9zZnB2Zyt4bWwnXSxcbiAgICBbJ290YycsICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmNoYXJ0LXRlbXBsYXRlJ10sXG4gICAgWydvdGYnLCAnYXBwbGljYXRpb24veC1mb250LW90ZiddLFxuICAgIFsnb3RnJywgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZ3JhcGhpY3MtdGVtcGxhdGUnXSxcbiAgICBbJ290aCcsICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQtd2ViJ10sXG4gICAgWydvdGknLCAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5pbWFnZS10ZW1wbGF0ZSddLFxuICAgIFsnb3RwJywgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uLXRlbXBsYXRlJ10sXG4gICAgWydvdHMnLCAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldC10ZW1wbGF0ZSddLFxuICAgIFsnb3R0JywgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dC10ZW1wbGF0ZSddLFxuICAgIFsnb3h0JywgJ2FwcGxpY2F0aW9uL3ZuZC5vcGVub2ZmaWNlb3JnLmV4dGVuc2lvbiddLFxuICAgIFsncCcsICd0ZXh0L3gtcGFzY2FsJ10sXG4gICAgWydwMTAnLCBbJ2FwcGxpY2F0aW9uL3BrY3MxMCcsICdhcHBsaWNhdGlvbi94LXBrY3MxMCddXSxcbiAgICBbJ3AxMicsIFsnYXBwbGljYXRpb24vcGtjcy0xMicsICdhcHBsaWNhdGlvbi94LXBrY3MxMiddXSxcbiAgICBbJ3A3YScsICdhcHBsaWNhdGlvbi94LXBrY3M3LXNpZ25hdHVyZSddLFxuICAgIFsncDdiJywgJ2FwcGxpY2F0aW9uL3gtcGtjczctY2VydGlmaWNhdGVzJ10sXG4gICAgWydwN2MnLCBbJ2FwcGxpY2F0aW9uL3BrY3M3LW1pbWUnLCAnYXBwbGljYXRpb24veC1wa2NzNy1taW1lJ11dLFxuICAgIFsncDdtJywgWydhcHBsaWNhdGlvbi9wa2NzNy1taW1lJywgJ2FwcGxpY2F0aW9uL3gtcGtjczctbWltZSddXSxcbiAgICBbJ3A3cicsICdhcHBsaWNhdGlvbi94LXBrY3M3LWNlcnRyZXFyZXNwJ10sXG4gICAgWydwN3MnLCBbJ2FwcGxpY2F0aW9uL3BrY3M3LXNpZ25hdHVyZScsICdhcHBsaWNhdGlvbi94LXBrY3M3LXNpZ25hdHVyZSddXSxcbiAgICBbJ3A4JywgJ2FwcGxpY2F0aW9uL3BrY3M4J10sXG4gICAgWydwYXInLCAndGV4dC9wbGFpbi1iYXMnXSxcbiAgICBbJ3BhcnQnLCAnYXBwbGljYXRpb24vcHJvX2VuZyddLFxuICAgIFsncGFzJywgJ3RleHQvcGFzY2FsJ10sXG4gICAgWydwYXcnLCAnYXBwbGljYXRpb24vdm5kLnBhd2FhZmlsZSddLFxuICAgIFsncGJkJywgJ2FwcGxpY2F0aW9uL3ZuZC5wb3dlcmJ1aWxkZXI2J10sXG4gICAgWydwYm0nLCAnaW1hZ2UveC1wb3J0YWJsZS1iaXRtYXAnXSxcbiAgICBbJ3BjZicsICdhcHBsaWNhdGlvbi94LWZvbnQtcGNmJ10sXG4gICAgWydwY2wnLCBbJ2FwcGxpY2F0aW9uL3ZuZC5ocC1wY2wnLCAnYXBwbGljYXRpb24veC1wY2wnXV0sXG4gICAgWydwY2x4bCcsICdhcHBsaWNhdGlvbi92bmQuaHAtcGNseGwnXSxcbiAgICBbJ3BjdCcsICdpbWFnZS94LXBpY3QnXSxcbiAgICBbJ3BjdXJsJywgJ2FwcGxpY2F0aW9uL3ZuZC5jdXJsLnBjdXJsJ10sXG4gICAgWydwY3gnLCAnaW1hZ2UveC1wY3gnXSxcbiAgICBbJ3BkYicsIFsnYXBwbGljYXRpb24vdm5kLnBhbG0nLCAnY2hlbWljYWwveC1wZGInXV0sXG4gICAgWydwZGYnLCAnYXBwbGljYXRpb24vcGRmJ10sXG4gICAgWydwZmEnLCAnYXBwbGljYXRpb24veC1mb250LXR5cGUxJ10sXG4gICAgWydwZnInLCAnYXBwbGljYXRpb24vZm9udC10ZHBmciddLFxuICAgIFsncGZ1bmsnLCBbJ2F1ZGlvL21ha2UnLCAnYXVkaW8vbWFrZS5teS5mdW5rJ11dLFxuICAgIFsncGZ4JywgJ2FwcGxpY2F0aW9uL3gtcGtjczEyJ10sXG4gICAgWydwZ20nLCBbJ2ltYWdlL3gtcG9ydGFibGUtZ3JheW1hcCcsICdpbWFnZS94LXBvcnRhYmxlLWdyZXltYXAnXV0sXG4gICAgWydwZ24nLCAnYXBwbGljYXRpb24veC1jaGVzcy1wZ24nXSxcbiAgICBbJ3BncCcsICdhcHBsaWNhdGlvbi9wZ3Atc2lnbmF0dXJlJ10sXG4gICAgWydwaWMnLCBbJ2ltYWdlL3BpY3QnLCAnaW1hZ2UveC1waWN0J11dLFxuICAgIFsncGljdCcsICdpbWFnZS9waWN0J10sXG4gICAgWydwa2cnLCAnYXBwbGljYXRpb24veC1uZXd0b24tY29tcGF0aWJsZS1wa2cnXSxcbiAgICBbJ3BraScsICdhcHBsaWNhdGlvbi9wa2l4Y21wJ10sXG4gICAgWydwa2lwYXRoJywgJ2FwcGxpY2F0aW9uL3BraXgtcGtpcGF0aCddLFxuICAgIFsncGtvJywgWydhcHBsaWNhdGlvbi95bmQubXMtcGtpcGtvJywgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wa2kucGtvJ11dLFxuICAgIFsncGwnLCBbJ3RleHQvcGxhaW4nLCAndGV4dC94LXNjcmlwdC5wZXJsJ11dLFxuICAgIFsncGxiJywgJ2FwcGxpY2F0aW9uL3ZuZC4zZ3BwLnBpYy1idy1sYXJnZSddLFxuICAgIFsncGxjJywgJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMucGxjJ10sXG4gICAgWydwbGYnLCAnYXBwbGljYXRpb24vdm5kLnBvY2tldGxlYXJuJ10sXG4gICAgWydwbHMnLCAnYXBwbGljYXRpb24vcGxzK3htbCddLFxuICAgIFsncGx4JywgJ2FwcGxpY2F0aW9uL3gtcGl4Y2xzY3JpcHQnXSxcbiAgICBbJ3BtJywgWyd0ZXh0L3gtc2NyaXB0LnBlcmwtbW9kdWxlJywgJ2ltYWdlL3gteHBpeG1hcCddXSxcbiAgICBbJ3BtNCcsICdhcHBsaWNhdGlvbi94LXBhZ2VtYWtlciddLFxuICAgIFsncG01JywgJ2FwcGxpY2F0aW9uL3gtcGFnZW1ha2VyJ10sXG4gICAgWydwbWEnLCAnYXBwbGljYXRpb24veC1wZXJmbW9uJ10sXG4gICAgWydwbWMnLCAnYXBwbGljYXRpb24veC1wZXJmbW9uJ10sXG4gICAgWydwbWwnLCBbJ2FwcGxpY2F0aW9uL3ZuZC5jdGMtcG9zbWwnLCAnYXBwbGljYXRpb24veC1wZXJmbW9uJ11dLFxuICAgIFsncG1yJywgJ2FwcGxpY2F0aW9uL3gtcGVyZm1vbiddLFxuICAgIFsncG13JywgJ2FwcGxpY2F0aW9uL3gtcGVyZm1vbiddLFxuICAgIFsncG5nJywgJ2ltYWdlL3BuZyddLFxuICAgIFsncG5tJywgWydhcHBsaWNhdGlvbi94LXBvcnRhYmxlLWFueW1hcCcsICdpbWFnZS94LXBvcnRhYmxlLWFueW1hcCddXSxcbiAgICBbJ3BvcnRwa2cnLCAnYXBwbGljYXRpb24vdm5kLm1hY3BvcnRzLnBvcnRwa2cnXSxcbiAgICBbJ3BvdCcsIFsnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQnLCAnYXBwbGljYXRpb24vbXNwb3dlcnBvaW50J11dLFxuICAgIFsncG90bScsICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTInXSxcbiAgICBbJ3BvdHgnLCAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnRlbXBsYXRlJ10sXG4gICAgWydwb3YnLCAnbW9kZWwveC1wb3YnXSxcbiAgICBbJ3BwYScsICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludCddLFxuICAgIFsncHBhbScsICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5hZGRpbi5tYWNyb2VuYWJsZWQuMTInXSxcbiAgICBbJ3BwZCcsICdhcHBsaWNhdGlvbi92bmQuY3Vwcy1wcGQnXSxcbiAgICBbJ3BwbScsICdpbWFnZS94LXBvcnRhYmxlLXBpeG1hcCddLFxuICAgIFsncHBzJywgWydhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludCcsICdhcHBsaWNhdGlvbi9tc3Bvd2VycG9pbnQnXV0sXG4gICAgWydwcHNtJywgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnNsaWRlc2hvdy5tYWNyb2VuYWJsZWQuMTInXSxcbiAgICBbJ3Bwc3gnLCAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlc2hvdyddLFxuICAgIFsncHB0JywgWydhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludCcsICdhcHBsaWNhdGlvbi9tc3Bvd2VycG9pbnQnLCAnYXBwbGljYXRpb24vcG93ZXJwb2ludCcsICdhcHBsaWNhdGlvbi94LW1zcG93ZXJwb2ludCddXSxcbiAgICBbJ3BwdG0nLCAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQucHJlc2VudGF0aW9uLm1hY3JvZW5hYmxlZC4xMiddLFxuICAgIFsncHB0eCcsICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uJ10sXG4gICAgWydwcHonLCAnYXBwbGljYXRpb24vbXNwb3dlcnBvaW50J10sXG4gICAgWydwcmMnLCAnYXBwbGljYXRpb24veC1tb2JpcG9ja2V0LWVib29rJ10sXG4gICAgWydwcmUnLCBbJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy1mcmVlbGFuY2UnLCAnYXBwbGljYXRpb24veC1mcmVlbGFuY2UnXV0sXG4gICAgWydwcmYnLCAnYXBwbGljYXRpb24vcGljcy1ydWxlcyddLFxuICAgIFsncHJ0JywgJ2FwcGxpY2F0aW9uL3Byb19lbmcnXSxcbiAgICBbJ3BzJywgJ2FwcGxpY2F0aW9uL3Bvc3RzY3JpcHQnXSxcbiAgICBbJ3BzYicsICdhcHBsaWNhdGlvbi92bmQuM2dwcC5waWMtYnctc21hbGwnXSxcbiAgICBbJ3BzZCcsIFsnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJywgJ2ltYWdlL3ZuZC5hZG9iZS5waG90b3Nob3AnXV0sXG4gICAgWydwc2YnLCAnYXBwbGljYXRpb24veC1mb250LWxpbnV4LXBzZiddLFxuICAgIFsncHNrY3htbCcsICdhcHBsaWNhdGlvbi9wc2tjK3htbCddLFxuICAgIFsncHRpZCcsICdhcHBsaWNhdGlvbi92bmQucHZpLnB0aWQxJ10sXG4gICAgWydwdWInLCAnYXBwbGljYXRpb24veC1tc3B1Ymxpc2hlciddLFxuICAgIFsncHZiJywgJ2FwcGxpY2F0aW9uL3ZuZC4zZ3BwLnBpYy1idy12YXInXSxcbiAgICBbJ3B2dScsICdwYWxlb3Z1L3gtcHYnXSxcbiAgICBbJ3B3bicsICdhcHBsaWNhdGlvbi92bmQuM20ucG9zdC1pdC1ub3RlcyddLFxuICAgIFsncHd6JywgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50J10sXG4gICAgWydweScsICd0ZXh0L3gtc2NyaXB0LnBoeXRvbiddLFxuICAgIFsncHlhJywgJ2F1ZGlvL3ZuZC5tcy1wbGF5cmVhZHkubWVkaWEucHlhJ10sXG4gICAgWydweWMnLCAnYXBwbGljYXRpb24veC1ieXRlY29kZS5weXRob24nXSxcbiAgICBbJ3B5dicsICd2aWRlby92bmQubXMtcGxheXJlYWR5Lm1lZGlhLnB5diddLFxuICAgIFsncWFtJywgJ2FwcGxpY2F0aW9uL3ZuZC5lcHNvbi5xdWlja2FuaW1lJ10sXG4gICAgWydxYm8nLCAnYXBwbGljYXRpb24vdm5kLmludHUucWJvJ10sXG4gICAgWydxY3AnLCAnYXVkaW8vdm5kLnFjZWxwJ10sXG4gICAgWydxZDMnLCAneC13b3JsZC94LTNkbWYnXSxcbiAgICBbJ3FkM2QnLCAneC13b3JsZC94LTNkbWYnXSxcbiAgICBbJ3FmeCcsICdhcHBsaWNhdGlvbi92bmQuaW50dS5xZngnXSxcbiAgICBbJ3FpZicsICdpbWFnZS94LXF1aWNrdGltZSddLFxuICAgIFsncXBzJywgJ2FwcGxpY2F0aW9uL3ZuZC5wdWJsaXNoYXJlLWRlbHRhLXRyZWUnXSxcbiAgICBbJ3F0JywgJ3ZpZGVvL3F1aWNrdGltZSddLFxuICAgIFsncXRjJywgJ3ZpZGVvL3gtcXRjJ10sXG4gICAgWydxdGknLCAnaW1hZ2UveC1xdWlja3RpbWUnXSxcbiAgICBbJ3F0aWYnLCAnaW1hZ2UveC1xdWlja3RpbWUnXSxcbiAgICBbJ3F4ZCcsICdhcHBsaWNhdGlvbi92bmQucXVhcmsucXVhcmt4cHJlc3MnXSxcbiAgICBbJ3JhJywgWydhdWRpby94LXJlYWxhdWRpbycsICdhdWRpby94LXBuLXJlYWxhdWRpbycsICdhdWRpby94LXBuLXJlYWxhdWRpby1wbHVnaW4nXV0sXG4gICAgWydyYW0nLCAnYXVkaW8veC1wbi1yZWFsYXVkaW8nXSxcbiAgICBbJ3JhcicsICdhcHBsaWNhdGlvbi94LXJhci1jb21wcmVzc2VkJ10sXG4gICAgWydyYXMnLCBbJ2ltYWdlL2NtdS1yYXN0ZXInLCAnYXBwbGljYXRpb24veC1jbXUtcmFzdGVyJywgJ2ltYWdlL3gtY211LXJhc3RlciddXSxcbiAgICBbJ3Jhc3QnLCAnaW1hZ2UvY211LXJhc3RlciddLFxuICAgIFsncmNwcm9maWxlJywgJ2FwcGxpY2F0aW9uL3ZuZC5pcHVucGx1Z2dlZC5yY3Byb2ZpbGUnXSxcbiAgICBbJ3JkZicsICdhcHBsaWNhdGlvbi9yZGYreG1sJ10sXG4gICAgWydyZHonLCAnYXBwbGljYXRpb24vdm5kLmRhdGEtdmlzaW9uLnJkeiddLFxuICAgIFsncmVwJywgJ2FwcGxpY2F0aW9uL3ZuZC5idXNpbmVzc29iamVjdHMnXSxcbiAgICBbJ3JlcycsICdhcHBsaWNhdGlvbi94LWR0YnJlc291cmNlK3htbCddLFxuICAgIFsncmV4eCcsICd0ZXh0L3gtc2NyaXB0LnJleHgnXSxcbiAgICBbJ3JmJywgJ2ltYWdlL3ZuZC5ybi1yZWFsZmxhc2gnXSxcbiAgICBbJ3JnYicsICdpbWFnZS94LXJnYiddLFxuICAgIFsncmlmJywgJ2FwcGxpY2F0aW9uL3JlZ2luZm8reG1sJ10sXG4gICAgWydyaXAnLCAnYXVkaW8vdm5kLnJpcCddLFxuICAgIFsncmwnLCAnYXBwbGljYXRpb24vcmVzb3VyY2UtbGlzdHMreG1sJ10sXG4gICAgWydybGMnLCAnaW1hZ2Uvdm5kLmZ1aml4ZXJveC5lZG1pY3MtcmxjJ10sXG4gICAgWydybGQnLCAnYXBwbGljYXRpb24vcmVzb3VyY2UtbGlzdHMtZGlmZit4bWwnXSxcbiAgICBbJ3JtJywgWydhcHBsaWNhdGlvbi92bmQucm4tcmVhbG1lZGlhJywgJ2F1ZGlvL3gtcG4tcmVhbGF1ZGlvJ11dLFxuICAgIFsncm1pJywgJ2F1ZGlvL21pZCddLFxuICAgIFsncm1tJywgJ2F1ZGlvL3gtcG4tcmVhbGF1ZGlvJ10sXG4gICAgWydybXAnLCBbJ2F1ZGlvL3gtcG4tcmVhbGF1ZGlvLXBsdWdpbicsICdhdWRpby94LXBuLXJlYWxhdWRpbyddXSxcbiAgICBbJ3JtcycsICdhcHBsaWNhdGlvbi92bmQuamNwLmphdmFtZS5taWRsZXQtcm1zJ10sXG4gICAgWydybmMnLCAnYXBwbGljYXRpb24vcmVsYXgtbmctY29tcGFjdC1zeW50YXgnXSxcbiAgICBbJ3JuZycsIFsnYXBwbGljYXRpb24vcmluZ2luZy10b25lcycsICdhcHBsaWNhdGlvbi92bmQubm9raWEucmluZ2luZy10b25lJ11dLFxuICAgIFsncm54JywgJ2FwcGxpY2F0aW9uL3ZuZC5ybi1yZWFscGxheWVyJ10sXG4gICAgWydyb2ZmJywgJ2FwcGxpY2F0aW9uL3gtdHJvZmYnXSxcbiAgICBbJ3JwJywgJ2ltYWdlL3ZuZC5ybi1yZWFscGl4J10sXG4gICAgWydycDknLCAnYXBwbGljYXRpb24vdm5kLmNsb2FudG8ucnA5J10sXG4gICAgWydycG0nLCAnYXVkaW8veC1wbi1yZWFsYXVkaW8tcGx1Z2luJ10sXG4gICAgWydycHNzJywgJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5yYWRpby1wcmVzZXRzJ10sXG4gICAgWydycHN0JywgJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5yYWRpby1wcmVzZXQnXSxcbiAgICBbJ3JxJywgJ2FwcGxpY2F0aW9uL3NwYXJxbC1xdWVyeSddLFxuICAgIFsncnMnLCAnYXBwbGljYXRpb24vcmxzLXNlcnZpY2VzK3htbCddLFxuICAgIFsncnNkJywgJ2FwcGxpY2F0aW9uL3JzZCt4bWwnXSxcbiAgICBbJ3J0JywgWyd0ZXh0L3JpY2h0ZXh0JywgJ3RleHQvdm5kLnJuLXJlYWx0ZXh0J11dLFxuICAgIFsncnRmJywgWydhcHBsaWNhdGlvbi9ydGYnLCAndGV4dC9yaWNodGV4dCcsICdhcHBsaWNhdGlvbi94LXJ0ZiddXSxcbiAgICBbJ3J0eCcsIFsndGV4dC9yaWNodGV4dCcsICdhcHBsaWNhdGlvbi9ydGYnXV0sXG4gICAgWydydicsICd2aWRlby92bmQucm4tcmVhbHZpZGVvJ10sXG4gICAgWydzJywgJ3RleHQveC1hc20nXSxcbiAgICBbJ3MzbScsICdhdWRpby9zM20nXSxcbiAgICBbJ3NhZicsICdhcHBsaWNhdGlvbi92bmQueWFtYWhhLnNtYWYtYXVkaW8nXSxcbiAgICBbJ3NhdmVtZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXSxcbiAgICBbJ3NiaycsICdhcHBsaWNhdGlvbi94LXRib29rJ10sXG4gICAgWydzYm1sJywgJ2FwcGxpY2F0aW9uL3NibWwreG1sJ10sXG4gICAgWydzYycsICdhcHBsaWNhdGlvbi92bmQuaWJtLnNlY3VyZS1jb250YWluZXInXSxcbiAgICBbJ3NjZCcsICdhcHBsaWNhdGlvbi94LW1zc2NoZWR1bGUnXSxcbiAgICBbJ3NjbScsIFsnYXBwbGljYXRpb24vdm5kLmxvdHVzLXNjcmVlbmNhbScsICd2aWRlby94LXNjbScsICd0ZXh0L3gtc2NyaXB0Lmd1aWxlJywgJ2FwcGxpY2F0aW9uL3gtbG90dXNzY3JlZW5jYW0nLCAndGV4dC94LXNjcmlwdC5zY2hlbWUnXV0sXG4gICAgWydzY3EnLCAnYXBwbGljYXRpb24vc2N2cC1jdi1yZXF1ZXN0J10sXG4gICAgWydzY3MnLCAnYXBwbGljYXRpb24vc2N2cC1jdi1yZXNwb25zZSddLFxuICAgIFsnc2N0JywgJ3RleHQvc2NyaXB0bGV0J10sXG4gICAgWydzY3VybCcsICd0ZXh0L3ZuZC5jdXJsLnNjdXJsJ10sXG4gICAgWydzZGEnLCAnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi5kcmF3J10sXG4gICAgWydzZGMnLCAnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi5jYWxjJ10sXG4gICAgWydzZGQnLCAnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi5pbXByZXNzJ10sXG4gICAgWydzZGttJywgJ2FwcGxpY2F0aW9uL3ZuZC5zb2xlbnQuc2RrbSt4bWwnXSxcbiAgICBbJ3NkbWwnLCAndGV4dC9wbGFpbiddLFxuICAgIFsnc2RwJywgWydhcHBsaWNhdGlvbi9zZHAnLCAnYXBwbGljYXRpb24veC1zZHAnXV0sXG4gICAgWydzZHInLCAnYXBwbGljYXRpb24vc291bmRlciddLFxuICAgIFsnc2R3JywgJ2FwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24ud3JpdGVyJ10sXG4gICAgWydzZWEnLCBbJ2FwcGxpY2F0aW9uL3NlYScsICdhcHBsaWNhdGlvbi94LXNlYSddXSxcbiAgICBbJ3NlZScsICdhcHBsaWNhdGlvbi92bmQuc2VlbWFpbCddLFxuICAgIFsnc2VlZCcsICdhcHBsaWNhdGlvbi92bmQuZmRzbi5zZWVkJ10sXG4gICAgWydzZW1hJywgJ2FwcGxpY2F0aW9uL3ZuZC5zZW1hJ10sXG4gICAgWydzZW1kJywgJ2FwcGxpY2F0aW9uL3ZuZC5zZW1kJ10sXG4gICAgWydzZW1mJywgJ2FwcGxpY2F0aW9uL3ZuZC5zZW1mJ10sXG4gICAgWydzZXInLCAnYXBwbGljYXRpb24vamF2YS1zZXJpYWxpemVkLW9iamVjdCddLFxuICAgIFsnc2V0JywgJ2FwcGxpY2F0aW9uL3NldCddLFxuICAgIFsnc2V0cGF5JywgJ2FwcGxpY2F0aW9uL3NldC1wYXltZW50LWluaXRpYXRpb24nXSxcbiAgICBbJ3NldHJlZycsICdhcHBsaWNhdGlvbi9zZXQtcmVnaXN0cmF0aW9uLWluaXRpYXRpb24nXSxcbiAgICBbJ3NmZC1oZHN0eCcsICdhcHBsaWNhdGlvbi92bmQuaHlkcm9zdGF0aXguc29mLWRhdGEnXSxcbiAgICBbJ3NmcycsICdhcHBsaWNhdGlvbi92bmQuc3BvdGZpcmUuc2ZzJ10sXG4gICAgWydzZ2wnLCAnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi53cml0ZXItZ2xvYmFsJ10sXG4gICAgWydzZ20nLCBbJ3RleHQvc2dtbCcsICd0ZXh0L3gtc2dtbCddXSxcbiAgICBbJ3NnbWwnLCBbJ3RleHQvc2dtbCcsICd0ZXh0L3gtc2dtbCddXSxcbiAgICBbJ3NoJywgWydhcHBsaWNhdGlvbi94LXNoYXInLCAnYXBwbGljYXRpb24veC1ic2gnLCAnYXBwbGljYXRpb24veC1zaCcsICd0ZXh0L3gtc2NyaXB0LnNoJ11dLFxuICAgIFsnc2hhcicsIFsnYXBwbGljYXRpb24veC1ic2gnLCAnYXBwbGljYXRpb24veC1zaGFyJ11dLFxuICAgIFsnc2hmJywgJ2FwcGxpY2F0aW9uL3NoZit4bWwnXSxcbiAgICBbJ3NodG1sJywgWyd0ZXh0L2h0bWwnLCAndGV4dC94LXNlcnZlci1wYXJzZWQtaHRtbCddXSxcbiAgICBbJ3NpZCcsICdhdWRpby94LXBzaWQnXSxcbiAgICBbJ3NpcycsICdhcHBsaWNhdGlvbi92bmQuc3ltYmlhbi5pbnN0YWxsJ10sXG4gICAgWydzaXQnLCBbJ2FwcGxpY2F0aW9uL3gtc3R1ZmZpdCcsICdhcHBsaWNhdGlvbi94LXNpdCddXSxcbiAgICBbJ3NpdHgnLCAnYXBwbGljYXRpb24veC1zdHVmZml0eCddLFxuICAgIFsnc2tkJywgJ2FwcGxpY2F0aW9uL3gta29hbiddLFxuICAgIFsnc2ttJywgJ2FwcGxpY2F0aW9uL3gta29hbiddLFxuICAgIFsnc2twJywgWydhcHBsaWNhdGlvbi92bmQua29hbicsICdhcHBsaWNhdGlvbi94LWtvYW4nXV0sXG4gICAgWydza3QnLCAnYXBwbGljYXRpb24veC1rb2FuJ10sXG4gICAgWydzbCcsICdhcHBsaWNhdGlvbi94LXNlZWxvZ28nXSxcbiAgICBbJ3NsZG0nLCAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQuc2xpZGUubWFjcm9lbmFibGVkLjEyJ10sXG4gICAgWydzbGR4JywgJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZSddLFxuICAgIFsnc2x0JywgJ2FwcGxpY2F0aW9uL3ZuZC5lcHNvbi5zYWx0J10sXG4gICAgWydzbScsICdhcHBsaWNhdGlvbi92bmQuc3RlcG1hbmlhLnN0ZXBjaGFydCddLFxuICAgIFsnc21mJywgJ2FwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24ubWF0aCddLFxuICAgIFsnc21pJywgWydhcHBsaWNhdGlvbi9zbWlsJywgJ2FwcGxpY2F0aW9uL3NtaWwreG1sJ11dLFxuICAgIFsnc21pbCcsICdhcHBsaWNhdGlvbi9zbWlsJ10sXG4gICAgWydzbmQnLCBbJ2F1ZGlvL2Jhc2ljJywgJ2F1ZGlvL3gtYWRwY20nXV0sXG4gICAgWydzbmYnLCAnYXBwbGljYXRpb24veC1mb250LXNuZiddLFxuICAgIFsnc29sJywgJ2FwcGxpY2F0aW9uL3NvbGlkcyddLFxuICAgIFsnc3BjJywgWyd0ZXh0L3gtc3BlZWNoJywgJ2FwcGxpY2F0aW9uL3gtcGtjczctY2VydGlmaWNhdGVzJ11dLFxuICAgIFsnc3BmJywgJ2FwcGxpY2F0aW9uL3ZuZC55YW1haGEuc21hZi1waHJhc2UnXSxcbiAgICBbJ3NwbCcsIFsnYXBwbGljYXRpb24vZnV0dXJlc3BsYXNoJywgJ2FwcGxpY2F0aW9uL3gtZnV0dXJlc3BsYXNoJ11dLFxuICAgIFsnc3BvdCcsICd0ZXh0L3ZuZC5pbjNkLnNwb3QnXSxcbiAgICBbJ3NwcCcsICdhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlc3BvbnNlJ10sXG4gICAgWydzcHEnLCAnYXBwbGljYXRpb24vc2N2cC12cC1yZXF1ZXN0J10sXG4gICAgWydzcHInLCAnYXBwbGljYXRpb24veC1zcHJpdGUnXSxcbiAgICBbJ3Nwcml0ZScsICdhcHBsaWNhdGlvbi94LXNwcml0ZSddLFxuICAgIFsnc3JjJywgJ2FwcGxpY2F0aW9uL3gtd2Fpcy1zb3VyY2UnXSxcbiAgICBbJ3NydScsICdhcHBsaWNhdGlvbi9zcnUreG1sJ10sXG4gICAgWydzcngnLCAnYXBwbGljYXRpb24vc3BhcnFsLXJlc3VsdHMreG1sJ10sXG4gICAgWydzc2UnLCAnYXBwbGljYXRpb24vdm5kLmtvZGFrLWRlc2NyaXB0b3InXSxcbiAgICBbJ3NzZicsICdhcHBsaWNhdGlvbi92bmQuZXBzb24uc3NmJ10sXG4gICAgWydzc2knLCAndGV4dC94LXNlcnZlci1wYXJzZWQtaHRtbCddLFxuICAgIFsnc3NtJywgJ2FwcGxpY2F0aW9uL3N0cmVhbWluZ21lZGlhJ10sXG4gICAgWydzc21sJywgJ2FwcGxpY2F0aW9uL3NzbWwreG1sJ10sXG4gICAgWydzc3QnLCBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wa2ljZXJ0c3RvcmUnLCAnYXBwbGljYXRpb24vdm5kLm1zLXBraS5jZXJ0c3RvcmUnXV0sXG4gICAgWydzdCcsICdhcHBsaWNhdGlvbi92bmQuc2FpbGluZ3RyYWNrZXIudHJhY2snXSxcbiAgICBbJ3N0YycsICdhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5jYWxjLnRlbXBsYXRlJ10sXG4gICAgWydzdGQnLCAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwuZHJhdy50ZW1wbGF0ZSddLFxuICAgIFsnc3RlcCcsICdhcHBsaWNhdGlvbi9zdGVwJ10sXG4gICAgWydzdGYnLCAnYXBwbGljYXRpb24vdm5kLnd0LnN0ZiddLFxuICAgIFsnc3RpJywgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmltcHJlc3MudGVtcGxhdGUnXSxcbiAgICBbJ3N0aycsICdhcHBsaWNhdGlvbi9oeXBlcnN0dWRpbyddLFxuICAgIFsnc3RsJywgWydhcHBsaWNhdGlvbi92bmQubXMtcGtpc3RsJywgJ2FwcGxpY2F0aW9uL3NsYScsICdhcHBsaWNhdGlvbi92bmQubXMtcGtpLnN0bCcsICdhcHBsaWNhdGlvbi94LW5hdmlzdHlsZSddXSxcbiAgICBbJ3N0bScsICd0ZXh0L2h0bWwnXSxcbiAgICBbJ3N0cCcsICdhcHBsaWNhdGlvbi9zdGVwJ10sXG4gICAgWydzdHInLCAnYXBwbGljYXRpb24vdm5kLnBnLmZvcm1hdCddLFxuICAgIFsnc3R3JywgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLndyaXRlci50ZW1wbGF0ZSddLFxuICAgIFsnc3ViJywgJ2ltYWdlL3ZuZC5kdmIuc3VidGl0bGUnXSxcbiAgICBbJ3N1cycsICdhcHBsaWNhdGlvbi92bmQuc3VzLWNhbGVuZGFyJ10sXG4gICAgWydzdjRjcGlvJywgJ2FwcGxpY2F0aW9uL3gtc3Y0Y3BpbyddLFxuICAgIFsnc3Y0Y3JjJywgJ2FwcGxpY2F0aW9uL3gtc3Y0Y3JjJ10sXG4gICAgWydzdmMnLCAnYXBwbGljYXRpb24vdm5kLmR2Yi5zZXJ2aWNlJ10sXG4gICAgWydzdmQnLCAnYXBwbGljYXRpb24vdm5kLnN2ZCddLFxuICAgIFsnc3ZmJywgWydpbWFnZS92bmQuZHdnJywgJ2ltYWdlL3gtZHdnJ11dLFxuICAgIFsnc3ZnJywgJ2ltYWdlL3N2Zyt4bWwnXSxcbiAgICBbJ3N2cicsIFsneC13b3JsZC94LXN2cicsICdhcHBsaWNhdGlvbi94LXdvcmxkJ11dLFxuICAgIFsnc3dmJywgJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJ10sXG4gICAgWydzd2knLCAnYXBwbGljYXRpb24vdm5kLmFyaXN0YW5ldHdvcmtzLnN3aSddLFxuICAgIFsnc3hjJywgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmNhbGMnXSxcbiAgICBbJ3N4ZCcsICdhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5kcmF3J10sXG4gICAgWydzeGcnLCAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyLmdsb2JhbCddLFxuICAgIFsnc3hpJywgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmltcHJlc3MnXSxcbiAgICBbJ3N4bScsICdhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5tYXRoJ10sXG4gICAgWydzeHcnLCAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyJ10sXG4gICAgWyd0JywgWyd0ZXh0L3Ryb2ZmJywgJ2FwcGxpY2F0aW9uL3gtdHJvZmYnXV0sXG4gICAgWyd0YWxrJywgJ3RleHQveC1zcGVlY2gnXSxcbiAgICBbJ3RhbycsICdhcHBsaWNhdGlvbi92bmQudGFvLmludGVudC1tb2R1bGUtYXJjaGl2ZSddLFxuICAgIFsndGFyJywgJ2FwcGxpY2F0aW9uL3gtdGFyJ10sXG4gICAgWyd0YmsnLCBbJ2FwcGxpY2F0aW9uL3Rvb2xib29rJywgJ2FwcGxpY2F0aW9uL3gtdGJvb2snXV0sXG4gICAgWyd0Y2FwJywgJ2FwcGxpY2F0aW9uL3ZuZC4zZ3BwMi50Y2FwJ10sXG4gICAgWyd0Y2wnLCBbJ3RleHQveC1zY3JpcHQudGNsJywgJ2FwcGxpY2F0aW9uL3gtdGNsJ11dLFxuICAgIFsndGNzaCcsICd0ZXh0L3gtc2NyaXB0LnRjc2gnXSxcbiAgICBbJ3RlYWNoZXInLCAnYXBwbGljYXRpb24vdm5kLnNtYXJ0LnRlYWNoZXInXSxcbiAgICBbJ3RlaScsICdhcHBsaWNhdGlvbi90ZWkreG1sJ10sXG4gICAgWyd0ZXgnLCAnYXBwbGljYXRpb24veC10ZXgnXSxcbiAgICBbJ3RleGknLCAnYXBwbGljYXRpb24veC10ZXhpbmZvJ10sXG4gICAgWyd0ZXhpbmZvJywgJ2FwcGxpY2F0aW9uL3gtdGV4aW5mbyddLFxuICAgIFsndGV4dCcsIFsnYXBwbGljYXRpb24vcGxhaW4nLCAndGV4dC9wbGFpbiddXSxcbiAgICBbJ3RmaScsICdhcHBsaWNhdGlvbi90aHJhdWQreG1sJ10sXG4gICAgWyd0Zm0nLCAnYXBwbGljYXRpb24veC10ZXgtdGZtJ10sXG4gICAgWyd0Z3onLCBbJ2FwcGxpY2F0aW9uL2dudXRhcicsICdhcHBsaWNhdGlvbi94LWNvbXByZXNzZWQnXV0sXG4gICAgWyd0aG14JywgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1vZmZpY2V0aGVtZSddLFxuICAgIFsndGlmJywgWydpbWFnZS90aWZmJywgJ2ltYWdlL3gtdGlmZiddXSxcbiAgICBbJ3RpZmYnLCBbJ2ltYWdlL3RpZmYnLCAnaW1hZ2UveC10aWZmJ11dLFxuICAgIFsndG1vJywgJ2FwcGxpY2F0aW9uL3ZuZC50bW9iaWxlLWxpdmV0diddLFxuICAgIFsndG9ycmVudCcsICdhcHBsaWNhdGlvbi94LWJpdHRvcnJlbnQnXSxcbiAgICBbJ3RwbCcsICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLXRvb2wtdGVtcGxhdGUnXSxcbiAgICBbJ3RwdCcsICdhcHBsaWNhdGlvbi92bmQudHJpZC50cHQnXSxcbiAgICBbJ3RyJywgJ2FwcGxpY2F0aW9uL3gtdHJvZmYnXSxcbiAgICBbJ3RyYScsICdhcHBsaWNhdGlvbi92bmQudHJ1ZWFwcCddLFxuICAgIFsndHJtJywgJ2FwcGxpY2F0aW9uL3gtbXN0ZXJtaW5hbCddLFxuICAgIFsndHNkJywgJ2FwcGxpY2F0aW9uL3RpbWVzdGFtcGVkLWRhdGEnXSxcbiAgICBbJ3RzaScsICdhdWRpby90c3AtYXVkaW8nXSxcbiAgICBbJ3RzcCcsIFsnYXBwbGljYXRpb24vZHNwdHlwZScsICdhdWRpby90c3BsYXllciddXSxcbiAgICBbJ3RzdicsICd0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzJ10sXG4gICAgWyd0dGYnLCAnYXBwbGljYXRpb24veC1mb250LXR0ZiddLFxuICAgIFsndHRsJywgJ3RleHQvdHVydGxlJ10sXG4gICAgWyd0dXJib3QnLCAnaW1hZ2UvZmxvcmlhbiddLFxuICAgIFsndHdkJywgJ2FwcGxpY2F0aW9uL3ZuZC5zaW10ZWNoLW1pbmRtYXBwZXInXSxcbiAgICBbJ3R4ZCcsICdhcHBsaWNhdGlvbi92bmQuZ2Vub21hdGl4LnR1eGVkbyddLFxuICAgIFsndHhmJywgJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMudHhmJ10sXG4gICAgWyd0eHQnLCAndGV4dC9wbGFpbiddLFxuICAgIFsndWZkJywgJ2FwcGxpY2F0aW9uL3ZuZC51ZmRsJ10sXG4gICAgWyd1aWwnLCAndGV4dC94LXVpbCddLFxuICAgIFsndWxzJywgJ3RleHQvaXVscyddLFxuICAgIFsndW1qJywgJ2FwcGxpY2F0aW9uL3ZuZC51bWFqaW4nXSxcbiAgICBbJ3VuaScsICd0ZXh0L3VyaS1saXN0J10sXG4gICAgWyd1bmlzJywgJ3RleHQvdXJpLWxpc3QnXSxcbiAgICBbJ3VuaXR5d2ViJywgJ2FwcGxpY2F0aW9uL3ZuZC51bml0eSddLFxuICAgIFsndW52JywgJ2FwcGxpY2F0aW9uL2ktZGVhcyddLFxuICAgIFsndW9tbCcsICdhcHBsaWNhdGlvbi92bmQudW9tbCt4bWwnXSxcbiAgICBbJ3VyaScsICd0ZXh0L3VyaS1saXN0J10sXG4gICAgWyd1cmlzJywgJ3RleHQvdXJpLWxpc3QnXSxcbiAgICBbJ3VzdGFyJywgWydhcHBsaWNhdGlvbi94LXVzdGFyJywgJ211bHRpcGFydC94LXVzdGFyJ11dLFxuICAgIFsndXR6JywgJ2FwcGxpY2F0aW9uL3ZuZC51aXEudGhlbWUnXSxcbiAgICBbJ3V1JywgWydhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLCAndGV4dC94LXV1ZW5jb2RlJ11dLFxuICAgIFsndXVlJywgJ3RleHQveC11dWVuY29kZSddLFxuICAgIFsndXZhJywgJ2F1ZGlvL3ZuZC5kZWNlLmF1ZGlvJ10sXG4gICAgWyd1dmgnLCAndmlkZW8vdm5kLmRlY2UuaGQnXSxcbiAgICBbJ3V2aScsICdpbWFnZS92bmQuZGVjZS5ncmFwaGljJ10sXG4gICAgWyd1dm0nLCAndmlkZW8vdm5kLmRlY2UubW9iaWxlJ10sXG4gICAgWyd1dnAnLCAndmlkZW8vdm5kLmRlY2UucGQnXSxcbiAgICBbJ3V2cycsICd2aWRlby92bmQuZGVjZS5zZCddLFxuICAgIFsndXZ1JywgJ3ZpZGVvL3ZuZC51dnZ1Lm1wNCddLFxuICAgIFsndXZ2JywgJ3ZpZGVvL3ZuZC5kZWNlLnZpZGVvJ10sXG4gICAgWyd2Y2QnLCAnYXBwbGljYXRpb24veC1jZGxpbmsnXSxcbiAgICBbJ3ZjZicsICd0ZXh0L3gtdmNhcmQnXSxcbiAgICBbJ3ZjZycsICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLXZjYXJkJ10sXG4gICAgWyd2Y3MnLCAndGV4dC94LXZjYWxlbmRhciddLFxuICAgIFsndmN4JywgJ2FwcGxpY2F0aW9uL3ZuZC52Y3gnXSxcbiAgICBbJ3ZkYScsICdhcHBsaWNhdGlvbi92ZGEnXSxcbiAgICBbJ3ZkbycsICd2aWRlby92ZG8nXSxcbiAgICBbJ3ZldycsICdhcHBsaWNhdGlvbi9ncm91cHdpc2UnXSxcbiAgICBbJ3ZpcycsICdhcHBsaWNhdGlvbi92bmQudmlzaW9uYXJ5J10sXG4gICAgWyd2aXYnLCBbJ3ZpZGVvL3Zpdm8nLCAndmlkZW8vdm5kLnZpdm8nXV0sXG4gICAgWyd2aXZvJywgWyd2aWRlby92aXZvJywgJ3ZpZGVvL3ZuZC52aXZvJ11dLFxuICAgIFsndm1kJywgJ2FwcGxpY2F0aW9uL3ZvY2FsdGVjLW1lZGlhLWRlc2MnXSxcbiAgICBbJ3ZtZicsICdhcHBsaWNhdGlvbi92b2NhbHRlYy1tZWRpYS1maWxlJ10sXG4gICAgWyd2b2MnLCBbJ2F1ZGlvL3ZvYycsICdhdWRpby94LXZvYyddXSxcbiAgICBbJ3ZvcycsICd2aWRlby92b3NhaWMnXSxcbiAgICBbJ3ZveCcsICdhdWRpby92b3h3YXJlJ10sXG4gICAgWyd2cWUnLCAnYXVkaW8veC10d2ludnEtcGx1Z2luJ10sXG4gICAgWyd2cWYnLCAnYXVkaW8veC10d2ludnEnXSxcbiAgICBbJ3ZxbCcsICdhdWRpby94LXR3aW52cS1wbHVnaW4nXSxcbiAgICBbJ3ZybWwnLCBbJ21vZGVsL3ZybWwnLCAneC13b3JsZC94LXZybWwnLCAnYXBwbGljYXRpb24veC12cm1sJ11dLFxuICAgIFsndnJ0JywgJ3gtd29ybGQveC12cnQnXSxcbiAgICBbJ3ZzZCcsIFsnYXBwbGljYXRpb24vdm5kLnZpc2lvJywgJ2FwcGxpY2F0aW9uL3gtdmlzaW8nXV0sXG4gICAgWyd2c2YnLCAnYXBwbGljYXRpb24vdm5kLnZzZiddLFxuICAgIFsndnN0JywgJ2FwcGxpY2F0aW9uL3gtdmlzaW8nXSxcbiAgICBbJ3ZzdycsICdhcHBsaWNhdGlvbi94LXZpc2lvJ10sXG4gICAgWyd2dHUnLCAnbW9kZWwvdm5kLnZ0dSddLFxuICAgIFsndnhtbCcsICdhcHBsaWNhdGlvbi92b2ljZXhtbCt4bWwnXSxcbiAgICBbJ3c2MCcsICdhcHBsaWNhdGlvbi93b3JkcGVyZmVjdDYuMCddLFxuICAgIFsndzYxJywgJ2FwcGxpY2F0aW9uL3dvcmRwZXJmZWN0Ni4xJ10sXG4gICAgWyd3NncnLCAnYXBwbGljYXRpb24vbXN3b3JkJ10sXG4gICAgWyd3YWQnLCAnYXBwbGljYXRpb24veC1kb29tJ10sXG4gICAgWyd3YXYnLCBbJ2F1ZGlvL3dhdicsICdhdWRpby94LXdhdiddXSxcbiAgICBbJ3dheCcsICdhdWRpby94LW1zLXdheCddLFxuICAgIFsnd2IxJywgJ2FwcGxpY2F0aW9uL3gtcXBybyddLFxuICAgIFsnd2JtcCcsICdpbWFnZS92bmQud2FwLndibXAnXSxcbiAgICBbJ3dicycsICdhcHBsaWNhdGlvbi92bmQuY3JpdGljYWx0b29scy53YnMreG1sJ10sXG4gICAgWyd3YnhtbCcsICdhcHBsaWNhdGlvbi92bmQud2FwLndieG1sJ10sXG4gICAgWyd3Y20nLCAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmtzJ10sXG4gICAgWyd3ZGInLCAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmtzJ10sXG4gICAgWyd3ZWInLCAnYXBwbGljYXRpb24vdm5kLnhhcmEnXSxcbiAgICBbJ3dlYmEnLCAnYXVkaW8vd2VibSddLFxuICAgIFsnd2VibScsICd2aWRlby93ZWJtJ10sXG4gICAgWyd3ZWJwJywgJ2ltYWdlL3dlYnAnXSxcbiAgICBbJ3dnJywgJ2FwcGxpY2F0aW9uL3ZuZC5wbWkud2lkZ2V0J10sXG4gICAgWyd3Z3QnLCAnYXBwbGljYXRpb24vd2lkZ2V0J10sXG4gICAgWyd3aXonLCAnYXBwbGljYXRpb24vbXN3b3JkJ10sXG4gICAgWyd3azEnLCAnYXBwbGljYXRpb24veC0xMjMnXSxcbiAgICBbJ3drcycsICdhcHBsaWNhdGlvbi92bmQubXMtd29ya3MnXSxcbiAgICBbJ3dtJywgJ3ZpZGVvL3gtbXMtd20nXSxcbiAgICBbJ3dtYScsICdhdWRpby94LW1zLXdtYSddLFxuICAgIFsnd21kJywgJ2FwcGxpY2F0aW9uL3gtbXMtd21kJ10sXG4gICAgWyd3bWYnLCBbJ3dpbmRvd3MvbWV0YWZpbGUnLCAnYXBwbGljYXRpb24veC1tc21ldGFmaWxlJ11dLFxuICAgIFsnd21sJywgJ3RleHQvdm5kLndhcC53bWwnXSxcbiAgICBbJ3dtbGMnLCAnYXBwbGljYXRpb24vdm5kLndhcC53bWxjJ10sXG4gICAgWyd3bWxzJywgJ3RleHQvdm5kLndhcC53bWxzY3JpcHQnXSxcbiAgICBbJ3dtbHNjJywgJ2FwcGxpY2F0aW9uL3ZuZC53YXAud21sc2NyaXB0YyddLFxuICAgIFsnd212JywgJ3ZpZGVvL3gtbXMtd212J10sXG4gICAgWyd3bXgnLCAndmlkZW8veC1tcy13bXgnXSxcbiAgICBbJ3dteicsICdhcHBsaWNhdGlvbi94LW1zLXdteiddLFxuICAgIFsnd29mZicsICdhcHBsaWNhdGlvbi94LWZvbnQtd29mZiddLFxuICAgIFsnd29yZCcsICdhcHBsaWNhdGlvbi9tc3dvcmQnXSxcbiAgICBbJ3dwJywgJ2FwcGxpY2F0aW9uL3dvcmRwZXJmZWN0J10sXG4gICAgWyd3cDUnLCBbJ2FwcGxpY2F0aW9uL3dvcmRwZXJmZWN0JywgJ2FwcGxpY2F0aW9uL3dvcmRwZXJmZWN0Ni4wJ11dLFxuICAgIFsnd3A2JywgJ2FwcGxpY2F0aW9uL3dvcmRwZXJmZWN0J10sXG4gICAgWyd3cGQnLCBbJ2FwcGxpY2F0aW9uL3dvcmRwZXJmZWN0JywgJ2FwcGxpY2F0aW9uL3ZuZC53b3JkcGVyZmVjdCcsICdhcHBsaWNhdGlvbi94LXdwd2luJ11dLFxuICAgIFsnd3BsJywgJ2FwcGxpY2F0aW9uL3ZuZC5tcy13cGwnXSxcbiAgICBbJ3dwcycsICdhcHBsaWNhdGlvbi92bmQubXMtd29ya3MnXSxcbiAgICBbJ3dxMScsICdhcHBsaWNhdGlvbi94LWxvdHVzJ10sXG4gICAgWyd3cWQnLCAnYXBwbGljYXRpb24vdm5kLndxZCddLFxuICAgIFsnd3JpJywgWydhcHBsaWNhdGlvbi9tc3dyaXRlJywgJ2FwcGxpY2F0aW9uL3gtd3JpJywgJ2FwcGxpY2F0aW9uL3gtbXN3cml0ZSddXSxcbiAgICBbJ3dybCcsIFsnbW9kZWwvdnJtbCcsICd4LXdvcmxkL3gtdnJtbCcsICdhcHBsaWNhdGlvbi94LXdvcmxkJ11dLFxuICAgIFsnd3J6JywgWydtb2RlbC92cm1sJywgJ3gtd29ybGQveC12cm1sJ11dLFxuICAgIFsnd3NjJywgJ3RleHQvc2NyaXBsZXQnXSxcbiAgICBbJ3dzZGwnLCAnYXBwbGljYXRpb24vd3NkbCt4bWwnXSxcbiAgICBbJ3dzcG9saWN5JywgJ2FwcGxpY2F0aW9uL3dzcG9saWN5K3htbCddLFxuICAgIFsnd3NyYycsICdhcHBsaWNhdGlvbi94LXdhaXMtc291cmNlJ10sXG4gICAgWyd3dGInLCAnYXBwbGljYXRpb24vdm5kLndlYnR1cmJvJ10sXG4gICAgWyd3dGsnLCAnYXBwbGljYXRpb24veC13aW50YWxrJ10sXG4gICAgWyd3dngnLCAndmlkZW8veC1tcy13dngnXSxcbiAgICBbJ3gtcG5nJywgJ2ltYWdlL3BuZyddLFxuICAgIFsneDNkJywgJ2FwcGxpY2F0aW9uL3ZuZC5oem4tM2QtY3Jvc3N3b3JkJ10sXG4gICAgWyd4YWYnLCAneC13b3JsZC94LXZybWwnXSxcbiAgICBbJ3hhcCcsICdhcHBsaWNhdGlvbi94LXNpbHZlcmxpZ2h0LWFwcCddLFxuICAgIFsneGFyJywgJ2FwcGxpY2F0aW9uL3ZuZC54YXJhJ10sXG4gICAgWyd4YmFwJywgJ2FwcGxpY2F0aW9uL3gtbXMteGJhcCddLFxuICAgIFsneGJkJywgJ2FwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guZG9jdXdvcmtzLmJpbmRlciddLFxuICAgIFsneGJtJywgWydpbWFnZS94Ym0nLCAnaW1hZ2UveC14Ym0nLCAnaW1hZ2UveC14Yml0bWFwJ11dLFxuICAgIFsneGRmJywgJ2FwcGxpY2F0aW9uL3hjYXAtZGlmZit4bWwnXSxcbiAgICBbJ3hkbScsICdhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtK3htbCddLFxuICAgIFsneGRwJywgJ2FwcGxpY2F0aW9uL3ZuZC5hZG9iZS54ZHAreG1sJ10sXG4gICAgWyd4ZHInLCAndmlkZW8veC1hbXQtZGVtb3J1biddLFxuICAgIFsneGRzc2MnLCAnYXBwbGljYXRpb24vZHNzYyt4bWwnXSxcbiAgICBbJ3hkdycsICdhcHBsaWNhdGlvbi92bmQuZnVqaXhlcm94LmRvY3V3b3JrcyddLFxuICAgIFsneGVuYycsICdhcHBsaWNhdGlvbi94ZW5jK3htbCddLFxuICAgIFsneGVyJywgJ2FwcGxpY2F0aW9uL3BhdGNoLW9wcy1lcnJvcit4bWwnXSxcbiAgICBbJ3hmZGYnLCAnYXBwbGljYXRpb24vdm5kLmFkb2JlLnhmZGYnXSxcbiAgICBbJ3hmZGwnLCAnYXBwbGljYXRpb24vdm5kLnhmZGwnXSxcbiAgICBbJ3hneicsICd4Z2wvZHJhd2luZyddLFxuICAgIFsneGh0bWwnLCAnYXBwbGljYXRpb24veGh0bWwreG1sJ10sXG4gICAgWyd4aWYnLCAnaW1hZ2Uvdm5kLnhpZmYnXSxcbiAgICBbJ3hsJywgJ2FwcGxpY2F0aW9uL2V4Y2VsJ10sXG4gICAgWyd4bGEnLCBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsICdhcHBsaWNhdGlvbi9leGNlbCcsICdhcHBsaWNhdGlvbi94LW1zZXhjZWwnLCAnYXBwbGljYXRpb24veC1leGNlbCddXSxcbiAgICBbJ3hsYW0nLCAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLmFkZGluLm1hY3JvZW5hYmxlZC4xMiddLFxuICAgIFsneGxiJywgWydhcHBsaWNhdGlvbi9leGNlbCcsICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLCAnYXBwbGljYXRpb24veC1leGNlbCddXSxcbiAgICBbJ3hsYycsIFsnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJywgJ2FwcGxpY2F0aW9uL2V4Y2VsJywgJ2FwcGxpY2F0aW9uL3gtZXhjZWwnXV0sXG4gICAgWyd4bGQnLCBbJ2FwcGxpY2F0aW9uL2V4Y2VsJywgJ2FwcGxpY2F0aW9uL3gtZXhjZWwnXV0sXG4gICAgWyd4bGsnLCBbJ2FwcGxpY2F0aW9uL2V4Y2VsJywgJ2FwcGxpY2F0aW9uL3gtZXhjZWwnXV0sXG4gICAgWyd4bGwnLCBbJ2FwcGxpY2F0aW9uL2V4Y2VsJywgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsICdhcHBsaWNhdGlvbi94LWV4Y2VsJ11dLFxuICAgIFsneGxtJywgWydhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLCAnYXBwbGljYXRpb24vZXhjZWwnLCAnYXBwbGljYXRpb24veC1leGNlbCddXSxcbiAgICBbJ3hscycsIFsnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJywgJ2FwcGxpY2F0aW9uL2V4Y2VsJywgJ2FwcGxpY2F0aW9uL3gtbXNleGNlbCcsICdhcHBsaWNhdGlvbi94LWV4Y2VsJ11dLFxuICAgIFsneGxzYicsICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQuYmluYXJ5Lm1hY3JvZW5hYmxlZC4xMiddLFxuICAgIFsneGxzbScsICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQubWFjcm9lbmFibGVkLjEyJ10sXG4gICAgWyd4bHN4JywgJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0J10sXG4gICAgWyd4bHQnLCBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsICdhcHBsaWNhdGlvbi9leGNlbCcsICdhcHBsaWNhdGlvbi94LWV4Y2VsJ11dLFxuICAgIFsneGx0bScsICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyJ10sXG4gICAgWyd4bHR4JywgJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnRlbXBsYXRlJ10sXG4gICAgWyd4bHYnLCBbJ2FwcGxpY2F0aW9uL2V4Y2VsJywgJ2FwcGxpY2F0aW9uL3gtZXhjZWwnXV0sXG4gICAgWyd4bHcnLCBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsICdhcHBsaWNhdGlvbi9leGNlbCcsICdhcHBsaWNhdGlvbi94LW1zZXhjZWwnLCAnYXBwbGljYXRpb24veC1leGNlbCddXSxcbiAgICBbJ3htJywgJ2F1ZGlvL3htJ10sXG4gICAgWyd4bWwnLCBbJ2FwcGxpY2F0aW9uL3htbCcsICd0ZXh0L3htbCcsICdhcHBsaWNhdGlvbi9hdG9tK3htbCcsICdhcHBsaWNhdGlvbi9yc3MreG1sJ11dLFxuICAgIFsneG16JywgJ3hnbC9tb3ZpZSddLFxuICAgIFsneG8nLCAnYXBwbGljYXRpb24vdm5kLm9scGMtc3VnYXInXSxcbiAgICBbJ3hvZicsICd4LXdvcmxkL3gtdnJtbCddLFxuICAgIFsneG9wJywgJ2FwcGxpY2F0aW9uL3hvcCt4bWwnXSxcbiAgICBbJ3hwaScsICdhcHBsaWNhdGlvbi94LXhwaW5zdGFsbCddLFxuICAgIFsneHBpeCcsICdhcHBsaWNhdGlvbi94LXZuZC5scy14cGl4J10sXG4gICAgWyd4cG0nLCBbJ2ltYWdlL3hwbScsICdpbWFnZS94LXhwaXhtYXAnXV0sXG4gICAgWyd4cHInLCAnYXBwbGljYXRpb24vdm5kLmlzLXhwciddLFxuICAgIFsneHBzJywgJ2FwcGxpY2F0aW9uL3ZuZC5tcy14cHNkb2N1bWVudCddLFxuICAgIFsneHB3JywgJ2FwcGxpY2F0aW9uL3ZuZC5pbnRlcmNvbi5mb3JtbmV0J10sXG4gICAgWyd4c2x0JywgJ2FwcGxpY2F0aW9uL3hzbHQreG1sJ10sXG4gICAgWyd4c20nLCAnYXBwbGljYXRpb24vdm5kLnN5bmNtbCt4bWwnXSxcbiAgICBbJ3hzcGYnLCAnYXBwbGljYXRpb24veHNwZit4bWwnXSxcbiAgICBbJ3hzcicsICd2aWRlby94LWFtdC1zaG93cnVuJ10sXG4gICAgWyd4dWwnLCAnYXBwbGljYXRpb24vdm5kLm1vemlsbGEueHVsK3htbCddLFxuICAgIFsneHdkJywgWydpbWFnZS94LXh3ZCcsICdpbWFnZS94LXh3aW5kb3dkdW1wJ11dLFxuICAgIFsneHl6JywgWydjaGVtaWNhbC94LXh5eicsICdjaGVtaWNhbC94LXBkYiddXSxcbiAgICBbJ3lhbmcnLCAnYXBwbGljYXRpb24veWFuZyddLFxuICAgIFsneWluJywgJ2FwcGxpY2F0aW9uL3lpbit4bWwnXSxcbiAgICBbJ3onLCBbJ2FwcGxpY2F0aW9uL3gtY29tcHJlc3NlZCcsICdhcHBsaWNhdGlvbi94LWNvbXByZXNzJ11dLFxuICAgIFsnemF6JywgJ2FwcGxpY2F0aW9uL3ZuZC56emF6ei5kZWNrK3htbCddLFxuICAgIFsnemlwJywgWydhcHBsaWNhdGlvbi96aXAnLCAnbXVsdGlwYXJ0L3gtemlwJywgJ2FwcGxpY2F0aW9uL3gtemlwLWNvbXByZXNzZWQnLCAnYXBwbGljYXRpb24veC1jb21wcmVzc2VkJ11dLFxuICAgIFsnemlyJywgJ2FwcGxpY2F0aW9uL3ZuZC56dWwnXSxcbiAgICBbJ3ptbScsICdhcHBsaWNhdGlvbi92bmQuaGFuZGhlbGQtZW50ZXJ0YWlubWVudCt4bWwnXSxcbiAgICBbJ3pvbycsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXSxcbiAgICBbJ3pzaCcsICd0ZXh0L3gtc2NyaXB0LnpzaCddXG5dKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGV0ZWN0TWltZVR5cGUoZmlsZW5hbWUpIHtcbiAgICAgICAgaWYgKCFmaWxlbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRNaW1lVHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXJzZWQgPSBwYXRoLnBhcnNlKGZpbGVuYW1lKTtcbiAgICAgICAgbGV0IGV4dGVuc2lvbiA9IChwYXJzZWQuZXh0LnN1YnN0cigxKSB8fCBwYXJzZWQubmFtZSB8fCAnJykuc3BsaXQoJz8nKS5zaGlmdCgpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsZXQgdmFsdWUgPSBkZWZhdWx0TWltZVR5cGU7XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbnMuaGFzKGV4dGVuc2lvbikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZXh0ZW5zaW9ucy5nZXQoZXh0ZW5zaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZGV0ZWN0RXh0ZW5zaW9uKG1pbWVUeXBlKSB7XG4gICAgICAgIGlmICghbWltZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RXh0ZW5zaW9uO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJ0cyA9IChtaW1lVHlwZSB8fCAnJykudG9Mb3dlckNhc2UoKS50cmltKCkuc3BsaXQoJy8nKTtcbiAgICAgICAgbGV0IHJvb3RUeXBlID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICAgIGxldCBzdWJUeXBlID0gcGFydHMuam9pbignLycpLnRyaW0oKTtcblxuICAgICAgICBpZiAobWltZVR5cGVzLmhhcyhyb290VHlwZSArICcvJyArIHN1YlR5cGUpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBtaW1lVHlwZXMuZ2V0KHJvb3RUeXBlICsgJy8nICsgc3ViVHlwZSk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHJvb3RUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3R4dCc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnYmluJztcbiAgICAgICAgfVxuICAgIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/mime-funcs/mime-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/mime-node/index.js":
/*!********************************************************!*\
  !*** ./node_modules/nodemailer/lib/mime-node/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */\n\n\n\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst punycode = __webpack_require__(/*! ../punycode */ \"(rsc)/./node_modules/nodemailer/lib/punycode/index.js\");\nconst PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nconst shared = __webpack_require__(/*! ../shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\");\n\nconst mimeFuncs = __webpack_require__(/*! ../mime-funcs */ \"(rsc)/./node_modules/nodemailer/lib/mime-funcs/index.js\");\nconst qp = __webpack_require__(/*! ../qp */ \"(rsc)/./node_modules/nodemailer/lib/qp/index.js\");\nconst base64 = __webpack_require__(/*! ../base64 */ \"(rsc)/./node_modules/nodemailer/lib/base64/index.js\");\nconst addressparser = __webpack_require__(/*! ../addressparser */ \"(rsc)/./node_modules/nodemailer/lib/addressparser/index.js\");\nconst nmfetch = __webpack_require__(/*! ../fetch */ \"(rsc)/./node_modules/nodemailer/lib/fetch/index.js\");\nconst LastNewline = __webpack_require__(/*! ./last-newline */ \"(rsc)/./node_modules/nodemailer/lib/mime-node/last-newline.js\");\n\nconst LeWindows = __webpack_require__(/*! ./le-windows */ \"(rsc)/./node_modules/nodemailer/lib/mime-node/le-windows.js\");\nconst LeUnix = __webpack_require__(/*! ./le-unix */ \"(rsc)/./node_modules/nodemailer/lib/mime-node/le-unix.js\");\n\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\nclass MimeNode {\n    constructor(contentType, options) {\n        this.nodeCounter = 0;\n\n        options = options || {};\n\n        /**\n         * shared part of the unique multipart boundary\n         */\n        this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');\n        this.boundaryPrefix = options.boundaryPrefix || '--_NmP';\n\n        this.disableFileAccess = !!options.disableFileAccess;\n        this.disableUrlAccess = !!options.disableUrlAccess;\n\n        this.normalizeHeaderKey = options.normalizeHeaderKey;\n\n        /**\n         * If date headers is missing and current node is the root, this value is used instead\n         */\n        this.date = new Date();\n\n        /**\n         * Root node for current mime tree\n         */\n        this.rootNode = options.rootNode || this;\n\n        /**\n         * If true include Bcc in generated headers (if available)\n         */\n        this.keepBcc = !!options.keepBcc;\n\n        /**\n         * If filename is specified but contentType is not (probably an attachment)\n         * detect the content type from filename extension\n         */\n        if (options.filename) {\n            /**\n             * Filename for this node. Useful with attachments\n             */\n            this.filename = options.filename;\n            if (!contentType) {\n                contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());\n            }\n        }\n\n        /**\n         * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n         */\n        this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n\n        /**\n         * Immediate parent for this node (or undefined if not set)\n         */\n        this.parentNode = options.parentNode;\n\n        /**\n         * Hostname for default message-id values\n         */\n        this.hostname = options.hostname;\n\n        /**\n         * If set to 'win' then uses \\r\\n, if 'linux' then \\n. If not set (or `raw` is used) then newlines are kept as is.\n         */\n        this.newline = options.newline;\n\n        /**\n         * An array for possible child nodes\n         */\n        this.childNodes = [];\n\n        /**\n         * Used for generating unique boundaries (prepended to the shared base)\n         */\n        this._nodeId = ++this.rootNode.nodeCounter;\n\n        /**\n         * A list of header values for this node in the form of [{key:'', value:''}]\n         */\n        this._headers = [];\n\n        /**\n         * True if the content only uses ASCII printable characters\n         * @type {Boolean}\n         */\n        this._isPlainText = false;\n\n        /**\n         * True if the content is plain text but has longer lines than allowed\n         * @type {Boolean}\n         */\n        this._hasLongLines = false;\n\n        /**\n         * If set, use instead this value for envelopes instead of generating one\n         * @type {Boolean}\n         */\n        this._envelope = false;\n\n        /**\n         * If set then use this value as the stream content instead of building it\n         * @type {String|Buffer|Stream}\n         */\n        this._raw = false;\n\n        /**\n         * Additional transform streams that the message will be piped before\n         * exposing by createReadStream\n         * @type {Array}\n         */\n        this._transforms = [];\n\n        /**\n         * Additional process functions that the message will be piped through before\n         * exposing by createReadStream. These functions are run after transforms\n         * @type {Array}\n         */\n        this._processFuncs = [];\n\n        /**\n         * If content type is set (or derived from the filename) add it to headers\n         */\n        if (contentType) {\n            this.setHeader('Content-Type', contentType);\n        }\n    }\n\n    /////// PUBLIC METHODS\n\n    /**\n     * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n     *\n     * @param {String} [contentType] Optional content type\n     * @param {Object} [options] Optional options object\n     * @return {Object} Created node object\n     */\n    createChild(contentType, options) {\n        if (!options && typeof contentType === 'object') {\n            options = contentType;\n            contentType = undefined;\n        }\n        let node = new MimeNode(contentType, options);\n        this.appendChild(node);\n        return node;\n    }\n\n    /**\n     * Appends an existing node to the mime tree. Removes the node from an existing\n     * tree if needed\n     *\n     * @param {Object} childNode node to be appended\n     * @return {Object} Appended node object\n     */\n    appendChild(childNode) {\n        if (childNode.rootNode !== this.rootNode) {\n            childNode.rootNode = this.rootNode;\n            childNode._nodeId = ++this.rootNode.nodeCounter;\n        }\n\n        childNode.parentNode = this;\n\n        this.childNodes.push(childNode);\n        return childNode;\n    }\n\n    /**\n     * Replaces current node with another node\n     *\n     * @param {Object} node Replacement node\n     * @return {Object} Replacement node\n     */\n    replace(node) {\n        if (node === this) {\n            return this;\n        }\n\n        this.parentNode.childNodes.forEach((childNode, i) => {\n            if (childNode === this) {\n                node.rootNode = this.rootNode;\n                node.parentNode = this.parentNode;\n                node._nodeId = this._nodeId;\n\n                this.rootNode = this;\n                this.parentNode = undefined;\n\n                node.parentNode.childNodes[i] = node;\n            }\n        });\n\n        return node;\n    }\n\n    /**\n     * Removes current node from the mime tree\n     *\n     * @return {Object} removed node\n     */\n    remove() {\n        if (!this.parentNode) {\n            return this;\n        }\n\n        for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n            if (this.parentNode.childNodes[i] === this) {\n                this.parentNode.childNodes.splice(i, 1);\n                this.parentNode = undefined;\n                this.rootNode = this;\n                return this;\n            }\n        }\n    }\n\n    /**\n     * Sets a header value. If the value for selected key exists, it is overwritten.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    setHeader(key, value) {\n        let added = false,\n            headerValue;\n\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && 'value' in key) {\n                this.setHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.setHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.setHeader(i, key[i]);\n                });\n            }\n            return this;\n        }\n\n        key = this._normalizeHeaderKey(key);\n\n        headerValue = {\n            key,\n            value\n        };\n\n        // Check if the value exists and overwrite\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                if (!added) {\n                    // replace the first match\n                    this._headers[i] = headerValue;\n                    added = true;\n                } else {\n                    // remove following matches\n                    this._headers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n\n        // match not found, append the value\n        if (!added) {\n            this._headers.push(headerValue);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a header value. If the value for selected key exists, the value is appended\n     * as a new field and old one is not touched.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    addHeader(key, value) {\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && key.value) {\n                this.addHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.addHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.addHeader(i, key[i]);\n                });\n            }\n            return this;\n        } else if (Array.isArray(value)) {\n            value.forEach(val => {\n                this.addHeader(key, val);\n            });\n            return this;\n        }\n\n        this._headers.push({\n            key: this._normalizeHeaderKey(key),\n            value\n        });\n\n        return this;\n    }\n\n    /**\n     * Retrieves the first mathcing value of a selected key\n     *\n     * @param {String} key Key to search for\n     * @retun {String} Value for the key\n     */\n    getHeader(key) {\n        key = this._normalizeHeaderKey(key);\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                return this._headers[i].value;\n            }\n        }\n    }\n\n    /**\n     * Sets body content for current node. If the value is a string, charset is added automatically\n     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n     * the charset yourself\n     *\n     * @param (String|Buffer) content Body content\n     * @return {Object} current node\n     */\n    setContent(content) {\n        this.content = content;\n        if (typeof this.content.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this.content.removeListener('error', this._contentErrorHandler);\n                this.content = err;\n            };\n            this.content.once('error', this._contentErrorHandler);\n        } else if (typeof this.content === 'string') {\n            this._isPlainText = mimeFuncs.isPlainText(this.content);\n            if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {\n                // If there are lines longer than 76 symbols/bytes do not use 7bit\n                this._hasLongLines = true;\n            }\n        }\n        return this;\n    }\n\n    build(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        let stream = this.createReadStream();\n        let buf = [];\n        let buflen = 0;\n        let returned = false;\n\n        stream.on('readable', () => {\n            let chunk;\n\n            while ((chunk = stream.read()) !== null) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n        });\n\n        stream.once('error', err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            return callback(err);\n        });\n\n        stream.once('end', chunk => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            if (chunk && chunk.length) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n            return callback(null, Buffer.concat(buf, buflen));\n        });\n\n        return promise;\n    }\n\n    getTransferEncoding() {\n        let transferEncoding = false;\n        let contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n        if (this.content) {\n            transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n            if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {\n                if (/^text\\//i.test(contentType)) {\n                    // If there are no special symbols, no need to modify the text\n                    if (this._isPlainText && !this._hasLongLines) {\n                        transferEncoding = '7bit';\n                    } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n                        // detect preferred encoding for string value\n                        transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n                    } else {\n                        // we can not check content for a stream, so either use preferred encoding or fallback to QP\n                        transferEncoding = this.textEncoding === 'B' ? 'base64' : 'quoted-printable';\n                    }\n                } else if (!/^(multipart|message)\\//i.test(contentType)) {\n                    transferEncoding = transferEncoding || 'base64';\n                }\n            }\n        }\n        return transferEncoding;\n    }\n\n    /**\n     * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n     *\n     * @returns {String} Headers\n     */\n    buildHeaders() {\n        let transferEncoding = this.getTransferEncoding();\n        let headers = [];\n\n        if (transferEncoding) {\n            this.setHeader('Content-Transfer-Encoding', transferEncoding);\n        }\n\n        if (this.filename && !this.getHeader('Content-Disposition')) {\n            this.setHeader('Content-Disposition', 'attachment');\n        }\n\n        // Ensure mandatory header fields\n        if (this.rootNode === this) {\n            if (!this.getHeader('Date')) {\n                this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n            }\n\n            // ensure that Message-Id is present\n            this.messageId();\n\n            if (!this.getHeader('MIME-Version')) {\n                this.setHeader('MIME-Version', '1.0');\n            }\n\n            // Ensure that Content-Type is the last header for the root node\n            for (let i = this._headers.length - 2; i >= 0; i--) {\n                let header = this._headers[i];\n                if (header.key === 'Content-Type') {\n                    this._headers.splice(i, 1);\n                    this._headers.push(header);\n                }\n            }\n        }\n\n        this._headers.forEach(header => {\n            let key = header.key;\n            let value = header.value;\n            let structured;\n            let param;\n            let options = {};\n            let formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n            if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {\n                Object.keys(value).forEach(key => {\n                    if (key !== 'value') {\n                        options[key] = value[key];\n                    }\n                });\n                value = (value.value || '').toString();\n                if (!value.trim()) {\n                    return;\n                }\n            }\n\n            if (options.prepared) {\n                // header value is\n                if (options.foldLines) {\n                    headers.push(mimeFuncs.foldLines(key + ': ' + value));\n                } else {\n                    headers.push(key + ': ' + value);\n                }\n                return;\n            }\n\n            switch (header.key) {\n                case 'Content-Disposition':\n                    structured = mimeFuncs.parseHeaderValue(value);\n                    if (this.filename) {\n                        structured.params.filename = this.filename;\n                    }\n                    value = mimeFuncs.buildHeaderValue(structured);\n                    break;\n\n                case 'Content-Type':\n                    structured = mimeFuncs.parseHeaderValue(value);\n\n                    this._handleContentType(structured);\n\n                    if (structured.value.match(/^text\\/plain\\b/) && typeof this.content === 'string' && /[\\u0080-\\uFFFF]/.test(this.content)) {\n                        structured.params.charset = 'utf-8';\n                    }\n\n                    value = mimeFuncs.buildHeaderValue(structured);\n\n                    if (this.filename) {\n                        // add support for non-compliant clients like QQ webmail\n                        // we can't build the value with buildHeaderValue as the value is non standard and\n                        // would be converted to parameter continuation encoding that we do not want\n                        param = this._encodeWords(this.filename);\n\n                        if (param !== this.filename || /[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(param)) {\n                            // include value in quotes if needed\n                            param = '\"' + param + '\"';\n                        }\n                        value += '; name=' + param;\n                    }\n                    break;\n\n                case 'Bcc':\n                    if (!this.keepBcc) {\n                        // skip BCC values\n                        return;\n                    }\n                    break;\n            }\n\n            value = this._encodeHeaderValue(key, value);\n\n            // skip empty lines\n            if (!(value || '').toString().trim()) {\n                return;\n            }\n\n            if (typeof this.normalizeHeaderKey === 'function') {\n                let normalized = this.normalizeHeaderKey(key, value);\n                if (normalized && typeof normalized === 'string' && normalized.length) {\n                    key = normalized;\n                }\n            }\n\n            headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));\n        });\n\n        return headers.join('\\r\\n');\n    }\n\n    /**\n     * Streams the rfc2822 message from the current node. If this is a root node,\n     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n     *\n     * @return {String} Compiled message\n     */\n    createReadStream(options) {\n        options = options || {};\n\n        let stream = new PassThrough(options);\n        let outputStream = stream;\n        let transform;\n\n        this.stream(stream, options, err => {\n            if (err) {\n                outputStream.emit('error', err);\n                return;\n            }\n            stream.end();\n        });\n\n        for (let i = 0, len = this._transforms.length; i < len; i++) {\n            transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n            outputStream.once('error', err => {\n                transform.emit('error', err);\n            });\n            outputStream = outputStream.pipe(transform);\n        }\n\n        // ensure terminating newline after possible user transforms\n        transform = new LastNewline();\n        outputStream.once('error', err => {\n            transform.emit('error', err);\n        });\n        outputStream = outputStream.pipe(transform);\n\n        // dkim and stuff\n        for (let i = 0, len = this._processFuncs.length; i < len; i++) {\n            transform = this._processFuncs[i];\n            outputStream = transform(outputStream);\n        }\n\n        if (this.newline) {\n            const winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes(this.newline.toString().toLowerCase());\n            const newlineTransform = winbreak ? new LeWindows() : new LeUnix();\n\n            const stream = outputStream.pipe(newlineTransform);\n            outputStream.on('error', err => stream.emit('error', err));\n            return stream;\n        }\n\n        return outputStream;\n    }\n\n    /**\n     * Appends a transform stream object to the transforms list. Final output\n     * is passed through this stream before exposing\n     *\n     * @param {Object} transform Read-Write stream\n     */\n    transform(transform) {\n        this._transforms.push(transform);\n    }\n\n    /**\n     * Appends a post process function. The functon is run after transforms and\n     * uses the following syntax\n     *\n     *   processFunc(input) -> outputStream\n     *\n     * @param {Object} processFunc Read-Write stream\n     */\n    processFunc(processFunc) {\n        this._processFuncs.push(processFunc);\n    }\n\n    stream(outputStream, options, done) {\n        let transferEncoding = this.getTransferEncoding();\n        let contentStream;\n        let localStream;\n\n        // protect actual callback against multiple triggering\n        let returned = false;\n        let callback = err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            done(err);\n        };\n\n        // for multipart nodes, push child nodes\n        // for content nodes end the stream\n        let finalize = () => {\n            let childId = 0;\n            let processChildNode = () => {\n                if (childId >= this.childNodes.length) {\n                    outputStream.write('\\r\\n--' + this.boundary + '--\\r\\n');\n                    return callback();\n                }\n                let child = this.childNodes[childId++];\n                outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + this.boundary + '\\r\\n');\n                child.stream(outputStream, options, err => {\n                    if (err) {\n                        return callback(err);\n                    }\n                    setImmediate(processChildNode);\n                });\n            };\n\n            if (this.multipart) {\n                setImmediate(processChildNode);\n            } else {\n                return callback();\n            }\n        };\n\n        // pushes node content\n        let sendContent = () => {\n            if (this.content) {\n                if (Object.prototype.toString.call(this.content) === '[object Error]') {\n                    // content is already errored\n                    return callback(this.content);\n                }\n\n                if (typeof this.content.pipe === 'function') {\n                    this.content.removeListener('error', this._contentErrorHandler);\n                    this._contentErrorHandler = err => callback(err);\n                    this.content.once('error', this._contentErrorHandler);\n                }\n\n                let createStream = () => {\n                    if (['quoted-printable', 'base64'].includes(transferEncoding)) {\n                        contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);\n\n                        contentStream.pipe(outputStream, {\n                            end: false\n                        });\n                        contentStream.once('end', finalize);\n                        contentStream.once('error', err => callback(err));\n\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(contentStream);\n                    } else {\n                        // anything that is not QP or Base54 passes as-is\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(outputStream, {\n                            end: false\n                        });\n                        localStream.once('end', finalize);\n                    }\n\n                    localStream.once('error', err => callback(err));\n                };\n\n                if (this.content._resolve) {\n                    let chunks = [];\n                    let chunklen = 0;\n                    let returned = false;\n                    let sourceStream = this._getStream(this.content);\n                    sourceStream.on('error', err => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        callback(err);\n                    });\n                    sourceStream.on('readable', () => {\n                        let chunk;\n                        while ((chunk = sourceStream.read()) !== null) {\n                            chunks.push(chunk);\n                            chunklen += chunk.length;\n                        }\n                    });\n                    sourceStream.on('end', () => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        this.content._resolve = false;\n                        this.content._resolvedValue = Buffer.concat(chunks, chunklen);\n                        setImmediate(createStream);\n                    });\n                } else {\n                    setImmediate(createStream);\n                }\n                return;\n            } else {\n                return setImmediate(finalize);\n            }\n        };\n\n        if (this._raw) {\n            setImmediate(() => {\n                if (Object.prototype.toString.call(this._raw) === '[object Error]') {\n                    // content is already errored\n                    return callback(this._raw);\n                }\n\n                // remove default error handler (if set)\n                if (typeof this._raw.pipe === 'function') {\n                    this._raw.removeListener('error', this._contentErrorHandler);\n                }\n\n                let raw = this._getStream(this._raw);\n                raw.pipe(outputStream, {\n                    end: false\n                });\n                raw.on('error', err => outputStream.emit('error', err));\n                raw.on('end', finalize);\n            });\n        } else {\n            outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n            setImmediate(sendContent);\n        }\n    }\n\n    /**\n     * Sets envelope to be used instead of the generated one\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    setEnvelope(envelope) {\n        let list;\n\n        this._envelope = {\n            from: false,\n            to: []\n        };\n\n        if (envelope.from) {\n            list = [];\n            this._convertAddresses(this._parseAddresses(envelope.from), list);\n            list = list.filter(address => address && address.address);\n            if (list.length && list[0]) {\n                this._envelope.from = list[0].address;\n            }\n        }\n        ['to', 'cc', 'bcc'].forEach(key => {\n            if (envelope[key]) {\n                this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n            }\n        });\n\n        this._envelope.to = this._envelope.to.map(to => to.address).filter(address => address);\n\n        let standardFields = ['to', 'cc', 'bcc', 'from'];\n        Object.keys(envelope).forEach(key => {\n            if (!standardFields.includes(key)) {\n                this._envelope[key] = envelope[key];\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Generates and returns an object with parsed address fields\n     *\n     * @return {Object} Address object\n     */\n    getAddresses() {\n        let addresses = {};\n\n        this._headers.forEach(header => {\n            let key = header.key.toLowerCase();\n            if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {\n                if (!Array.isArray(addresses[key])) {\n                    addresses[key] = [];\n                }\n\n                this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n            }\n        });\n\n        return addresses;\n    }\n\n    /**\n     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    getEnvelope() {\n        if (this._envelope) {\n            return this._envelope;\n        }\n\n        let envelope = {\n            from: false,\n            to: []\n        };\n        this._headers.forEach(header => {\n            let list = [];\n            if (header.key === 'From' || (!envelope.from && ['Reply-To', 'Sender'].includes(header.key))) {\n                this._convertAddresses(this._parseAddresses(header.value), list);\n                if (list.length && list[0]) {\n                    envelope.from = list[0].address;\n                }\n            } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {\n                this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n            }\n        });\n\n        envelope.to = envelope.to.map(to => to.address);\n\n        return envelope;\n    }\n\n    /**\n     * Returns Message-Id value. If it does not exist, then creates one\n     *\n     * @return {String} Message-Id value\n     */\n    messageId() {\n        let messageId = this.getHeader('Message-ID');\n        // You really should define your own Message-Id field!\n        if (!messageId) {\n            messageId = this._generateMessageId();\n            this.setHeader('Message-ID', messageId);\n        }\n        return messageId;\n    }\n\n    /**\n     * Sets pregenerated content that will be used as the output of this node\n     *\n     * @param {String|Buffer|Stream} Raw MIME contents\n     */\n    setRaw(raw) {\n        this._raw = raw;\n\n        if (this._raw && typeof this._raw.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this._raw.removeListener('error', this._contentErrorHandler);\n                this._raw = err;\n            };\n            this._raw.once('error', this._contentErrorHandler);\n        }\n\n        return this;\n    }\n\n    /////// PRIVATE METHODS\n\n    /**\n     * Detects and returns handle to a stream related with the content.\n     *\n     * @param {Mixed} content Node content\n     * @returns {Object} Stream object\n     */\n    _getStream(content) {\n        let contentStream;\n\n        if (content._resolvedValue) {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n\n            setImmediate(() => {\n                try {\n                    contentStream.end(content._resolvedValue);\n                } catch (err) {\n                    contentStream.emit('error', err);\n                }\n            });\n\n            return contentStream;\n        } else if (typeof content.pipe === 'function') {\n            // assume as stream\n            return content;\n        } else if (content && typeof content.path === 'string' && !content.href) {\n            if (this.disableFileAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('File access rejected for ' + content.path)));\n                return contentStream;\n            }\n            // read file\n            return fs.createReadStream(content.path);\n        } else if (content && typeof content.href === 'string') {\n            if (this.disableUrlAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('Url access rejected for ' + content.href)));\n                return contentStream;\n            }\n            // fetch URL\n            return nmfetch(content.href, { headers: content.httpHeaders });\n        } else {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n\n            setImmediate(() => {\n                try {\n                    contentStream.end(content || '');\n                } catch (err) {\n                    contentStream.emit('error', err);\n                }\n            });\n            return contentStream;\n        }\n    }\n\n    /**\n     * Parses addresses. Takes in a single address or an array or an\n     * array of address arrays (eg. To: [[first group], [second group],...])\n     *\n     * @param {Mixed} addresses Addresses to be parsed\n     * @return {Array} An array of address objects\n     */\n    _parseAddresses(addresses) {\n        return [].concat.apply(\n            [],\n            [].concat(addresses).map(address => {\n                // eslint-disable-line prefer-spread\n                if (address && address.address) {\n                    address.address = this._normalizeAddress(address.address);\n                    address.name = address.name || '';\n                    return [address];\n                }\n                return addressparser(address);\n            })\n        );\n    }\n\n    /**\n     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n     *\n     * @param {String} key Key to be normalized\n     * @return {String} key in Camel-Case form\n     */\n    _normalizeHeaderKey(key) {\n        key = (key || '')\n            .toString()\n            // no newlines in keys\n            .replace(/\\r?\\n|\\r/g, ' ')\n            .trim()\n            .toLowerCase()\n            // use uppercase words, except MIME\n            .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c => c.toUpperCase())\n            // special case\n            .replace(/^Content-Features$/i, 'Content-features');\n\n        return key;\n    }\n\n    /**\n     * Checks if the content type is multipart and defines boundary if needed.\n     * Doesn't return anything, modifies object argument instead.\n     *\n     * @param {Object} structured Parsed header value for 'Content-Type' key\n     */\n    _handleContentType(structured) {\n        this.contentType = structured.value.trim().toLowerCase();\n\n        this.multipart = /^multipart\\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;\n\n        if (this.multipart) {\n            this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n        } else {\n            this.boundary = false;\n        }\n    }\n\n    /**\n     * Generates a multipart boundary value\n     *\n     * @return {String} boundary value\n     */\n    _generateBoundary() {\n        return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;\n    }\n\n    /**\n     * Encodes a header value for use in the generated rfc2822 email.\n     *\n     * @param {String} key Header key\n     * @param {String} value Header value\n     */\n    _encodeHeaderValue(key, value) {\n        key = this._normalizeHeaderKey(key);\n\n        switch (key) {\n            // Structured headers\n            case 'From':\n            case 'Sender':\n            case 'To':\n            case 'Cc':\n            case 'Bcc':\n            case 'Reply-To':\n                return this._convertAddresses(this._parseAddresses(value));\n\n            // values enclosed in <>\n            case 'Message-ID':\n            case 'In-Reply-To':\n            case 'Content-Id':\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n                if (value.charAt(0) !== '<') {\n                    value = '<' + value;\n                }\n\n                if (value.charAt(value.length - 1) !== '>') {\n                    value = value + '>';\n                }\n                return value;\n\n            // space separated list of values enclosed in <>\n            case 'References':\n                value = [].concat\n                    .apply(\n                        [],\n                        [].concat(value || '').map(elm => {\n                            // eslint-disable-line prefer-spread\n                            elm = (elm || '')\n                                .toString()\n                                .replace(/\\r?\\n|\\r/g, ' ')\n                                .trim();\n                            return elm.replace(/<[^>]*>/g, str => str.replace(/\\s/g, '')).split(/\\s+/);\n                        })\n                    )\n                    .map(elm => {\n                        if (elm.charAt(0) !== '<') {\n                            elm = '<' + elm;\n                        }\n                        if (elm.charAt(elm.length - 1) !== '>') {\n                            elm = elm + '>';\n                        }\n                        return elm;\n                    });\n\n                return value.join(' ').trim();\n\n            case 'Date':\n                if (Object.prototype.toString.call(value) === '[object Date]') {\n                    return value.toUTCString().replace(/GMT/, '+0000');\n                }\n\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                return this._encodeWords(value);\n\n            case 'Content-Type':\n            case 'Content-Disposition':\n                // if it includes a filename then it is already encoded\n                return (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n            default:\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                // encodeWords only encodes if needed, otherwise the original string is returned\n                return this._encodeWords(value);\n        }\n    }\n\n    /**\n     * Rebuilds address object using punycode and other adjustments\n     *\n     * @param {Array} addresses An array of address objects\n     * @param {Array} [uniqueList] An array to be populated with addresses\n     * @return {String} address string\n     */\n    _convertAddresses(addresses, uniqueList) {\n        let values = [];\n\n        uniqueList = uniqueList || [];\n\n        [].concat(addresses || []).forEach(address => {\n            if (address.address) {\n                address.address = this._normalizeAddress(address.address);\n\n                if (!address.name) {\n                    values.push(address.address.indexOf(' ') >= 0 ? `<${address.address}>` : `${address.address}`);\n                } else if (address.name) {\n                    values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);\n                }\n\n                if (address.address) {\n                    if (!uniqueList.filter(a => a.address === address.address).length) {\n                        uniqueList.push(address);\n                    }\n                }\n            } else if (address.group) {\n                let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim();\n                values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);\n            }\n        });\n\n        return values.join(', ');\n    }\n\n    /**\n     * Normalizes an email address\n     *\n     * @param {Array} address An array of address objects\n     * @return {String} address string\n     */\n    _normalizeAddress(address) {\n        address = (address || '')\n            .toString()\n            .replace(/[\\x00-\\x1F<>]+/g, ' ') // remove unallowed characters\n            .trim();\n\n        let lastAt = address.lastIndexOf('@');\n        if (lastAt < 0) {\n            // Bare username\n            return address;\n        }\n\n        let user = address.substr(0, lastAt);\n        let domain = address.substr(lastAt + 1);\n\n        // Usernames are not touched and are kept as is even if these include unicode\n        // Domains are punycoded by default\n        // 'jõgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n        // non-unicode domains are left as is\n\n        let encodedDomain;\n\n        try {\n            encodedDomain = punycode.toASCII(domain.toLowerCase());\n        } catch (err) {\n            // keep as is?\n        }\n\n        if (user.indexOf(' ') >= 0) {\n            if (user.charAt(0) !== '\"') {\n                user = '\"' + user;\n            }\n            if (user.substr(-1) !== '\"') {\n                user = user + '\"';\n            }\n        }\n\n        return `${user}@${encodedDomain}`;\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeAddressName(name) {\n        if (!/^[\\w ]*$/.test(name)) {\n            if (/^[\\x20-\\x7e]*$/.test(name)) {\n                return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n            } else {\n                return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);\n            }\n        }\n        return name;\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeWords(value) {\n        // set encodeAll parameter to true even though it is against the recommendation of RFC2047,\n        // by default only words that include non-ascii should be converted into encoded words\n        // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace\n        return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);\n    }\n\n    /**\n     * Detects best mime encoding for a text value\n     *\n     * @param {String} value Value to check for\n     * @return {String} either 'Q' or 'B'\n     */\n    _getTextEncoding(value) {\n        value = (value || '').toString();\n\n        let encoding = this.textEncoding;\n        let latinLen;\n        let nonLatinLen;\n\n        if (!encoding) {\n            // count latin alphabet symbols and 8-bit range symbols + control symbols\n            // if there are more latin characters, then use quoted-printable\n            // encoding, otherwise use base64\n            nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex\n            latinLen = (value.match(/[a-z]/gi) || []).length;\n            // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n            encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n        }\n        return encoding;\n    }\n\n    /**\n     * Generates a message id\n     *\n     * @return {String} Random Message-ID value\n     */\n    _generateMessageId() {\n        return (\n            '<' +\n            [2, 2, 2, 6].reduce(\n                // crux to generate UUID-like random strings\n                (prev, len) => prev + '-' + crypto.randomBytes(len).toString('hex'),\n                crypto.randomBytes(4).toString('hex')\n            ) +\n            '@' +\n            // try to use the domain of the FROM address or fallback to server hostname\n            (this.getEnvelope().from || this.hostname || 'localhost').split('@').pop() +\n            '>'\n        );\n    }\n}\n\nmodule.exports = MimeNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvbWltZS1ub2RlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixpQkFBaUIsbUJBQU8sQ0FBQywwRUFBYTtBQUN0QyxvQkFBb0IseURBQTZCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxzRUFBVzs7QUFFbEMsa0JBQWtCLG1CQUFPLENBQUMsOEVBQWU7QUFDekMsV0FBVyxtQkFBTyxDQUFDLDhEQUFPO0FBQzFCLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVztBQUNsQyxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBa0I7QUFDaEQsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQVU7QUFDbEMsb0JBQW9CLG1CQUFPLENBQUMscUZBQWdCOztBQUU1QyxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBYztBQUN4QyxlQUFlLG1CQUFPLENBQUMsMkVBQVc7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0UsaUJBQWlCO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDREQUE0RCxRQUFRO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRCxpQkFBaUI7QUFDdkUsUUFBUSxjQUFjO0FBQ3RCO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGNBQWM7QUFDZCwyQkFBMkIsd0NBQXdDO0FBQ25FO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUJBQWlCO0FBQ3ZFLFFBQVEsY0FBYztBQUN0QjtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsY0FBYztBQUNkLDJCQUEyQix3Q0FBd0M7QUFDbkU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2QsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVEsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsOEJBQThCO0FBQ3pFLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RUFBd0UsZ0JBQWdCLFFBQVEsZ0JBQWdCO0FBQ2hILGtCQUFrQjtBQUNsQixtQ0FBbUMsdUNBQXVDLEdBQUcsZ0JBQWdCO0FBQzdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSwrQkFBK0Isc0NBQXNDLEdBQUcsb0JBQW9CO0FBQzVGO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixLQUFLLEdBQUcsY0FBYztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9taW1lLW5vZGUvaW5kZXguanM/NDcyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW5kZWZpbmVkOiAwLCBwcmVmZXItc3ByZWFkOiAwLCBuby1jb250cm9sLXJlZ2V4OiAwICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwdW55Y29kZSA9IHJlcXVpcmUoJy4uL3B1bnljb2RlJyk7XG5jb25zdCBQYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3N0cmVhbScpLlBhc3NUaHJvdWdoO1xuY29uc3Qgc2hhcmVkID0gcmVxdWlyZSgnLi4vc2hhcmVkJyk7XG5cbmNvbnN0IG1pbWVGdW5jcyA9IHJlcXVpcmUoJy4uL21pbWUtZnVuY3MnKTtcbmNvbnN0IHFwID0gcmVxdWlyZSgnLi4vcXAnKTtcbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJy4uL2Jhc2U2NCcpO1xuY29uc3QgYWRkcmVzc3BhcnNlciA9IHJlcXVpcmUoJy4uL2FkZHJlc3NwYXJzZXInKTtcbmNvbnN0IG5tZmV0Y2ggPSByZXF1aXJlKCcuLi9mZXRjaCcpO1xuY29uc3QgTGFzdE5ld2xpbmUgPSByZXF1aXJlKCcuL2xhc3QtbmV3bGluZScpO1xuXG5jb25zdCBMZVdpbmRvd3MgPSByZXF1aXJlKCcuL2xlLXdpbmRvd3MnKTtcbmNvbnN0IExlVW5peCA9IHJlcXVpcmUoJy4vbGUtdW5peCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWltZSB0cmVlIG5vZGUuIEFzc3VtZXMgJ211bHRpcGFydC8qJyBhcyB0aGUgY29udGVudCB0eXBlXG4gKiBpZiBpdCBpcyBhIGJyYW5jaCwgYW55dGhpbmcgZWxzZSBjb3VudHMgYXMgbGVhZi4gSWYgcm9vdE5vZGUgaXMgbWlzc2luZyBmcm9tXG4gKiB0aGUgb3B0aW9ucywgYXNzdW1lcyB0aGlzIGlzIHRoZSByb290LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50VHlwZSBEZWZpbmUgdGhlIGNvbnRlbnQgdHlwZSBmb3IgdGhlIG5vZGUuIENhbiBiZSBsZWZ0IGJsYW5rIGZvciBhdHRhY2htZW50cyAoZGVyaXZlZCBmcm9tIGZpbGVuYW1lKVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucm9vdE5vZGVdIHJvb3Qgbm9kZSBmb3IgdGhpcyB0cmVlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFyZW50Tm9kZV0gaW1tZWRpYXRlIHBhcmVudCBmb3IgdGhpcyBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZmlsZW5hbWVdIGZpbGVuYW1lIGZvciBhbiBhdHRhY2htZW50IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5iYXNlQm91bmRhcnldIHNoYXJlZCBwYXJ0IG9mIHRoZSB1bmlxdWUgbXVsdGlwYXJ0IGJvdW5kYXJ5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmtlZXBCY2NdIElmIHRydWUsIGRvIG5vdCBleGNsdWRlIEJjYyBmcm9tIHRoZSBnZW5lcmF0ZWQgaGVhZGVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubm9ybWFsaXplSGVhZGVyS2V5XSBtZXRob2QgdG8gbm9ybWFsaXplIGhlYWRlciBrZXlzIGZvciBjdXN0b20gY2FzZWluZ1xuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHRFbmNvZGluZ10gZWl0aGVyICdRJyAodGhlIGRlZmF1bHQpIG9yICdCJ1xuICovXG5jbGFzcyBNaW1lTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29udGVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ub2RlQ291bnRlciA9IDA7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNoYXJlZCBwYXJ0IG9mIHRoZSB1bmlxdWUgbXVsdGlwYXJ0IGJvdW5kYXJ5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhc2VCb3VuZGFyeSA9IG9wdGlvbnMuYmFzZUJvdW5kYXJ5IHx8IGNyeXB0by5yYW5kb21CeXRlcyg4KS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIHRoaXMuYm91bmRhcnlQcmVmaXggPSBvcHRpb25zLmJvdW5kYXJ5UHJlZml4IHx8ICctLV9ObVAnO1xuXG4gICAgICAgIHRoaXMuZGlzYWJsZUZpbGVBY2Nlc3MgPSAhIW9wdGlvbnMuZGlzYWJsZUZpbGVBY2Nlc3M7XG4gICAgICAgIHRoaXMuZGlzYWJsZVVybEFjY2VzcyA9ICEhb3B0aW9ucy5kaXNhYmxlVXJsQWNjZXNzO1xuXG4gICAgICAgIHRoaXMubm9ybWFsaXplSGVhZGVyS2V5ID0gb3B0aW9ucy5ub3JtYWxpemVIZWFkZXJLZXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGRhdGUgaGVhZGVycyBpcyBtaXNzaW5nIGFuZCBjdXJyZW50IG5vZGUgaXMgdGhlIHJvb3QsIHRoaXMgdmFsdWUgaXMgdXNlZCBpbnN0ZWFkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSb290IG5vZGUgZm9yIGN1cnJlbnQgbWltZSB0cmVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJvb3ROb2RlID0gb3B0aW9ucy5yb290Tm9kZSB8fCB0aGlzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlIGluY2x1ZGUgQmNjIGluIGdlbmVyYXRlZCBoZWFkZXJzIChpZiBhdmFpbGFibGUpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtlZXBCY2MgPSAhIW9wdGlvbnMua2VlcEJjYztcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZmlsZW5hbWUgaXMgc3BlY2lmaWVkIGJ1dCBjb250ZW50VHlwZSBpcyBub3QgKHByb2JhYmx5IGFuIGF0dGFjaG1lbnQpXG4gICAgICAgICAqIGRldGVjdCB0aGUgY29udGVudCB0eXBlIGZyb20gZmlsZW5hbWUgZXh0ZW5zaW9uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAob3B0aW9ucy5maWxlbmFtZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGaWxlbmFtZSBmb3IgdGhpcyBub2RlLiBVc2VmdWwgd2l0aCBhdHRhY2htZW50c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZTtcbiAgICAgICAgICAgIGlmICghY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IG1pbWVGdW5jcy5kZXRlY3RNaW1lVHlwZSh0aGlzLmZpbGVuYW1lLnNwbGl0KCcuJykucG9wKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGljaCBlbmNvZGluZyBzaG91bGQgYmUgdXNlZCBmb3IgaGVhZGVyIHN0cmluZ3M6IFwiUVwiIG9yIFwiQlwiXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHRFbmNvZGluZyA9IChvcHRpb25zLnRleHRFbmNvZGluZyB8fCAnJykudG9TdHJpbmcoKS50cmltKCkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltbWVkaWF0ZSBwYXJlbnQgZm9yIHRoaXMgbm9kZSAob3IgdW5kZWZpbmVkIGlmIG5vdCBzZXQpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBvcHRpb25zLnBhcmVudE5vZGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvc3RuYW1lIGZvciBkZWZhdWx0IG1lc3NhZ2UtaWQgdmFsdWVzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhvc3RuYW1lID0gb3B0aW9ucy5ob3N0bmFtZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvICd3aW4nIHRoZW4gdXNlcyBcXHJcXG4sIGlmICdsaW51eCcgdGhlbiBcXG4uIElmIG5vdCBzZXQgKG9yIGByYXdgIGlzIHVzZWQpIHRoZW4gbmV3bGluZXMgYXJlIGtlcHQgYXMgaXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5ld2xpbmUgPSBvcHRpb25zLm5ld2xpbmU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IGZvciBwb3NzaWJsZSBjaGlsZCBub2Rlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgZm9yIGdlbmVyYXRpbmcgdW5pcXVlIGJvdW5kYXJpZXMgKHByZXBlbmRlZCB0byB0aGUgc2hhcmVkIGJhc2UpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ub2RlSWQgPSArK3RoaXMucm9vdE5vZGUubm9kZUNvdW50ZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBoZWFkZXIgdmFsdWVzIGZvciB0aGlzIG5vZGUgaW4gdGhlIGZvcm0gb2YgW3trZXk6JycsIHZhbHVlOicnfV1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBpZiB0aGUgY29udGVudCBvbmx5IHVzZXMgQVNDSUkgcHJpbnRhYmxlIGNoYXJhY3RlcnNcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pc1BsYWluVGV4dCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGlmIHRoZSBjb250ZW50IGlzIHBsYWluIHRleHQgYnV0IGhhcyBsb25nZXIgbGluZXMgdGhhbiBhbGxvd2VkXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGFzTG9uZ0xpbmVzID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCwgdXNlIGluc3RlYWQgdGhpcyB2YWx1ZSBmb3IgZW52ZWxvcGVzIGluc3RlYWQgb2YgZ2VuZXJhdGluZyBvbmVcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9lbnZlbG9wZSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdGhlbiB1c2UgdGhpcyB2YWx1ZSBhcyB0aGUgc3RyZWFtIGNvbnRlbnQgaW5zdGVhZCBvZiBidWlsZGluZyBpdFxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfEJ1ZmZlcnxTdHJlYW19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yYXcgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCB0cmFuc2Zvcm0gc3RyZWFtcyB0aGF0IHRoZSBtZXNzYWdlIHdpbGwgYmUgcGlwZWQgYmVmb3JlXG4gICAgICAgICAqIGV4cG9zaW5nIGJ5IGNyZWF0ZVJlYWRTdHJlYW1cbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIHByb2Nlc3MgZnVuY3Rpb25zIHRoYXQgdGhlIG1lc3NhZ2Ugd2lsbCBiZSBwaXBlZCB0aHJvdWdoIGJlZm9yZVxuICAgICAgICAgKiBleHBvc2luZyBieSBjcmVhdGVSZWFkU3RyZWFtLiBUaGVzZSBmdW5jdGlvbnMgYXJlIHJ1biBhZnRlciB0cmFuc2Zvcm1zXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NGdW5jcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBjb250ZW50IHR5cGUgaXMgc2V0IChvciBkZXJpdmVkIGZyb20gdGhlIGZpbGVuYW1lKSBhZGQgaXQgdG8gaGVhZGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhlYWRlcignQ29udGVudC1UeXBlJywgY29udGVudFR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8vLy8vLyBQVUJMSUMgTUVUSE9EU1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgYXBwZW5kcyBhIGNoaWxkIG5vZGUuQXJndW1lbnRzIHByb3ZpZGVkIGFyZSBwYXNzZWQgdG8gTWltZU5vZGUgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29udGVudFR5cGVdIE9wdGlvbmFsIGNvbnRlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENyZWF0ZWQgbm9kZSBvYmplY3RcbiAgICAgKi9cbiAgICBjcmVhdGVDaGlsZChjb250ZW50VHlwZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMgJiYgdHlwZW9mIGNvbnRlbnRUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgY29udGVudFR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSBuZXcgTWltZU5vZGUoY29udGVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGFuIGV4aXN0aW5nIG5vZGUgdG8gdGhlIG1pbWUgdHJlZS4gUmVtb3ZlcyB0aGUgbm9kZSBmcm9tIGFuIGV4aXN0aW5nXG4gICAgICogdHJlZSBpZiBuZWVkZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGlsZE5vZGUgbm9kZSB0byBiZSBhcHBlbmRlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQXBwZW5kZWQgbm9kZSBvYmplY3RcbiAgICAgKi9cbiAgICBhcHBlbmRDaGlsZChjaGlsZE5vZGUpIHtcbiAgICAgICAgaWYgKGNoaWxkTm9kZS5yb290Tm9kZSAhPT0gdGhpcy5yb290Tm9kZSkge1xuICAgICAgICAgICAgY2hpbGROb2RlLnJvb3ROb2RlID0gdGhpcy5yb290Tm9kZTtcbiAgICAgICAgICAgIGNoaWxkTm9kZS5fbm9kZUlkID0gKyt0aGlzLnJvb3ROb2RlLm5vZGVDb3VudGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGROb2RlLnBhcmVudE5vZGUgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuY2hpbGROb2Rlcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgY3VycmVudCBub2RlIHdpdGggYW5vdGhlciBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBSZXBsYWNlbWVudCBub2RlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXBsYWNlbWVudCBub2RlXG4gICAgICovXG4gICAgcmVwbGFjZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIG5vZGUucm9vdE5vZGUgPSB0aGlzLnJvb3ROb2RlO1xuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBub2RlLl9ub2RlSWQgPSB0aGlzLl9ub2RlSWQ7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJvb3ROb2RlID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlc1tpXSA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgY3VycmVudCBub2RlIGZyb20gdGhlIG1pbWUgdHJlZVxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSByZW1vdmVkIG5vZGVcbiAgICAgKi9cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzW2ldID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3ROb2RlID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBoZWFkZXIgdmFsdWUuIElmIHRoZSB2YWx1ZSBmb3Igc2VsZWN0ZWQga2V5IGV4aXN0cywgaXQgaXMgb3ZlcndyaXR0ZW4uXG4gICAgICogWW91IGNhbiBzZXQgbXVsdGlwbGUgdmFsdWVzIGFzIHdlbGwgYnkgdXNpbmcgW3trZXk6JycsIHZhbHVlOicnfV0gb3JcbiAgICAgKiB7a2V5OiAndmFsdWUnfSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxPYmplY3R9IGtleSBIZWFkZXIga2V5IG9yIGEgbGlzdCBvZiBrZXkgdmFsdWUgcGFpcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgSGVhZGVyIHZhbHVlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IG5vZGVcbiAgICAgKi9cbiAgICBzZXRIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgYWRkZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGhlYWRlclZhbHVlO1xuXG4gICAgICAgIC8vIEFsbG93IHNldHRpbmcgbXVsdGlwbGUgaGVhZGVycyBhdCBvbmNlXG4gICAgICAgIGlmICghdmFsdWUgJiYga2V5ICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBhbGxvdyB7a2V5Oidjb250ZW50LXR5cGUnLCB2YWx1ZTogJ3RleHQvcGxhaW4nfVxuICAgICAgICAgICAgaWYgKGtleS5rZXkgJiYgJ3ZhbHVlJyBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhlYWRlcihrZXkua2V5LCBrZXkudmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBbe2tleTonY29udGVudC10eXBlJywgdmFsdWU6ICd0ZXh0L3BsYWluJ31dXG4gICAgICAgICAgICAgICAga2V5LmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVyKGkua2V5LCBpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgeydjb250ZW50LXR5cGUnOiAndGV4dC9wbGFpbid9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoa2V5KS5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEhlYWRlcihpLCBrZXlbaV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSB0aGlzLl9ub3JtYWxpemVIZWFkZXJLZXkoa2V5KTtcblxuICAgICAgICBoZWFkZXJWYWx1ZSA9IHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHZhbHVlIGV4aXN0cyBhbmQgb3ZlcndyaXRlXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9oZWFkZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGVhZGVyc1tpXS5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGlmICghYWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgZmlyc3QgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGVhZGVyc1tpXSA9IGhlYWRlclZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZvbGxvd2luZyBtYXRjaGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1hdGNoIG5vdCBmb3VuZCwgYXBwZW5kIHRoZSB2YWx1ZVxuICAgICAgICBpZiAoIWFkZGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJzLnB1c2goaGVhZGVyVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGhlYWRlciB2YWx1ZS4gSWYgdGhlIHZhbHVlIGZvciBzZWxlY3RlZCBrZXkgZXhpc3RzLCB0aGUgdmFsdWUgaXMgYXBwZW5kZWRcbiAgICAgKiBhcyBhIG5ldyBmaWVsZCBhbmQgb2xkIG9uZSBpcyBub3QgdG91Y2hlZC5cbiAgICAgKiBZb3UgY2FuIHNldCBtdWx0aXBsZSB2YWx1ZXMgYXMgd2VsbCBieSB1c2luZyBbe2tleTonJywgdmFsdWU6Jyd9XSBvclxuICAgICAqIHtrZXk6ICd2YWx1ZSd9IGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fE9iamVjdH0ga2V5IEhlYWRlciBrZXkgb3IgYSBsaXN0IG9mIGtleSB2YWx1ZSBwYWlyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBIZWFkZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgbm9kZVxuICAgICAqL1xuICAgIGFkZEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIC8vIEFsbG93IHNldHRpbmcgbXVsdGlwbGUgaGVhZGVycyBhdCBvbmNlXG4gICAgICAgIGlmICghdmFsdWUgJiYga2V5ICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBhbGxvdyB7a2V5Oidjb250ZW50LXR5cGUnLCB2YWx1ZTogJ3RleHQvcGxhaW4nfVxuICAgICAgICAgICAgaWYgKGtleS5rZXkgJiYga2V5LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRIZWFkZXIoa2V5LmtleSwga2V5LnZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgW3trZXk6J2NvbnRlbnQtdHlwZScsIHZhbHVlOiAndGV4dC9wbGFpbid9XVxuICAgICAgICAgICAgICAgIGtleS5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEhlYWRlcihpLmtleSwgaS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHsnY29udGVudC10eXBlJzogJ3RleHQvcGxhaW4nfVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGtleSkuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRIZWFkZXIoaSwga2V5W2ldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKHZhbCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2hlYWRlcnMucHVzaCh7XG4gICAgICAgICAgICBrZXk6IHRoaXMuX25vcm1hbGl6ZUhlYWRlcktleShrZXkpLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBmaXJzdCBtYXRoY2luZyB2YWx1ZSBvZiBhIHNlbGVjdGVkIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgdG8gc2VhcmNoIGZvclxuICAgICAqIEByZXR1biB7U3RyaW5nfSBWYWx1ZSBmb3IgdGhlIGtleVxuICAgICAqL1xuICAgIGdldEhlYWRlcihrZXkpIHtcbiAgICAgICAga2V5ID0gdGhpcy5fbm9ybWFsaXplSGVhZGVyS2V5KGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9oZWFkZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGVhZGVyc1tpXS5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzW2ldLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBib2R5IGNvbnRlbnQgZm9yIGN1cnJlbnQgbm9kZS4gSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCBjaGFyc2V0IGlzIGFkZGVkIGF1dG9tYXRpY2FsbHlcbiAgICAgKiB0byBDb250ZW50LVR5cGUgKGlmIGl0IGlzIHRleHQvKikuIElmIHRoZSB2YWx1ZSBpcyBhIEJ1ZmZlciwgeW91IG5lZWQgdG8gc3BlY2lmeVxuICAgICAqIHRoZSBjaGFyc2V0IHlvdXJzZWxmXG4gICAgICpcbiAgICAgKiBAcGFyYW0gKFN0cmluZ3xCdWZmZXIpIGNvbnRlbnQgQm9keSBjb250ZW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IG5vZGVcbiAgICAgKi9cbiAgICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnQucGlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gcHJlLXN0cmVhbSBoYW5kbGVyLiBtaWdodCBiZSB0cmlnZ2VyZWQgaWYgYSBzdHJlYW0gaXMgc2V0IGFzIGNvbnRlbnRcbiAgICAgICAgICAgIC8vIGFuZCAnZXJyb3InIGZpcmVzIGJlZm9yZSBhbnl0aGluZyBpcyBkb25lIHdpdGggdGhpcyBzdHJlYW1cbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRFcnJvckhhbmRsZXIgPSBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9jb250ZW50RXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBlcnI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jb250ZW50Lm9uY2UoJ2Vycm9yJywgdGhpcy5fY29udGVudEVycm9ySGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzUGxhaW5UZXh0ID0gbWltZUZ1bmNzLmlzUGxhaW5UZXh0KHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNQbGFpblRleHQgJiYgbWltZUZ1bmNzLmhhc0xvbmdlckxpbmVzKHRoaXMuY29udGVudCwgNzYpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGxpbmVzIGxvbmdlciB0aGFuIDc2IHN5bWJvbHMvYnl0ZXMgZG8gbm90IHVzZSA3Yml0XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzTG9uZ0xpbmVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBidWlsZChjYWxsYmFjaykge1xuICAgICAgICBsZXQgcHJvbWlzZTtcblxuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gc2hhcmVkLmNhbGxiYWNrUHJvbWlzZShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RyZWFtID0gdGhpcy5jcmVhdGVSZWFkU3RyZWFtKCk7XG4gICAgICAgIGxldCBidWYgPSBbXTtcbiAgICAgICAgbGV0IGJ1ZmxlbiA9IDA7XG4gICAgICAgIGxldCByZXR1cm5lZCA9IGZhbHNlO1xuXG4gICAgICAgIHN0cmVhbS5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2h1bms7XG5cbiAgICAgICAgICAgIHdoaWxlICgoY2h1bmsgPSBzdHJlYW0ucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICBidWZsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzdHJlYW0ub25jZSgnZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RyZWFtLm9uY2UoJ2VuZCcsIGNodW5rID0+IHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICBidWZsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIEJ1ZmZlci5jb25jYXQoYnVmLCBidWZsZW4pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgZ2V0VHJhbnNmZXJFbmNvZGluZygpIHtcbiAgICAgICAgbGV0IHRyYW5zZmVyRW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gKHRoaXMuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKSB8fCAnJykudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcblxuICAgICAgICBpZiAodGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICB0cmFuc2ZlckVuY29kaW5nID0gKHRoaXMuZ2V0SGVhZGVyKCdDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nJykgfHwgJycpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZmVyRW5jb2RpbmcgfHwgIVsnYmFzZTY0JywgJ3F1b3RlZC1wcmludGFibGUnXS5pbmNsdWRlcyh0cmFuc2ZlckVuY29kaW5nKSkge1xuICAgICAgICAgICAgICAgIGlmICgvXnRleHRcXC8vaS50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc3BlY2lhbCBzeW1ib2xzLCBubyBuZWVkIHRvIG1vZGlmeSB0aGUgdGV4dFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNQbGFpblRleHQgJiYgIXRoaXMuX2hhc0xvbmdMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXJFbmNvZGluZyA9ICc3Yml0JztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb250ZW50ID09PSAnc3RyaW5nJyB8fCB0aGlzLmNvbnRlbnQgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRldGVjdCBwcmVmZXJyZWQgZW5jb2RpbmcgZm9yIHN0cmluZyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXJFbmNvZGluZyA9IHRoaXMuX2dldFRleHRFbmNvZGluZyh0aGlzLmNvbnRlbnQpID09PSAnUScgPyAncXVvdGVkLXByaW50YWJsZScgOiAnYmFzZTY0JztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBub3QgY2hlY2sgY29udGVudCBmb3IgYSBzdHJlYW0sIHNvIGVpdGhlciB1c2UgcHJlZmVycmVkIGVuY29kaW5nIG9yIGZhbGxiYWNrIHRvIFFQXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2ZlckVuY29kaW5nID0gdGhpcy50ZXh0RW5jb2RpbmcgPT09ICdCJyA/ICdiYXNlNjQnIDogJ3F1b3RlZC1wcmludGFibGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghL14obXVsdGlwYXJ0fG1lc3NhZ2UpXFwvL2kudGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXJFbmNvZGluZyA9IHRyYW5zZmVyRW5jb2RpbmcgfHwgJ2Jhc2U2NCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2ZlckVuY29kaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgaGVhZGVyIGJsb2NrIGZvciB0aGUgbWltZSBub2RlLiBBcHBlbmQgXFxyXFxuXFxyXFxuIGJlZm9yZSB3cml0aW5nIHRoZSBjb250ZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBIZWFkZXJzXG4gICAgICovXG4gICAgYnVpbGRIZWFkZXJzKCkge1xuICAgICAgICBsZXQgdHJhbnNmZXJFbmNvZGluZyA9IHRoaXMuZ2V0VHJhbnNmZXJFbmNvZGluZygpO1xuICAgICAgICBsZXQgaGVhZGVycyA9IFtdO1xuXG4gICAgICAgIGlmICh0cmFuc2ZlckVuY29kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhlYWRlcignQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZycsIHRyYW5zZmVyRW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZmlsZW5hbWUgJiYgIXRoaXMuZ2V0SGVhZGVyKCdDb250ZW50LURpc3Bvc2l0aW9uJykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVyKCdDb250ZW50LURpc3Bvc2l0aW9uJywgJ2F0dGFjaG1lbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSBtYW5kYXRvcnkgaGVhZGVyIGZpZWxkc1xuICAgICAgICBpZiAodGhpcy5yb290Tm9kZSA9PT0gdGhpcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldEhlYWRlcignRGF0ZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXIoJ0RhdGUnLCB0aGlzLmRhdGUudG9VVENTdHJpbmcoKS5yZXBsYWNlKC9HTVQvLCAnKzAwMDAnKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IE1lc3NhZ2UtSWQgaXMgcHJlc2VudFxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlSWQoKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldEhlYWRlcignTUlNRS1WZXJzaW9uJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhlYWRlcignTUlNRS1WZXJzaW9uJywgJzEuMCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBDb250ZW50LVR5cGUgaXMgdGhlIGxhc3QgaGVhZGVyIGZvciB0aGUgcm9vdCBub2RlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5faGVhZGVycy5sZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBoZWFkZXIgPSB0aGlzLl9oZWFkZXJzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXIua2V5ID09PSAnQ29udGVudC1UeXBlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGVhZGVycy5wdXNoKGhlYWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICBsZXQga2V5ID0gaGVhZGVyLmtleTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGhlYWRlci52YWx1ZTtcbiAgICAgICAgICAgIGxldCBzdHJ1Y3R1cmVkO1xuICAgICAgICAgICAgbGV0IHBhcmFtO1xuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGxldCBmb3JtYXR0ZWRIZWFkZXJzID0gWydGcm9tJywgJ1NlbmRlcicsICdUbycsICdDYycsICdCY2MnLCAnUmVwbHktVG8nLCAnRGF0ZScsICdSZWZlcmVuY2VzJ107XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFmb3JtYXR0ZWRIZWFkZXJzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUudmFsdWUgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJlcGFyZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBoZWFkZXIgdmFsdWUgaXNcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5mb2xkTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycy5wdXNoKG1pbWVGdW5jcy5mb2xkTGluZXMoa2V5ICsgJzogJyArIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycy5wdXNoKGtleSArICc6ICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChoZWFkZXIua2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnQ29udGVudC1EaXNwb3NpdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdHVyZWQgPSBtaW1lRnVuY3MucGFyc2VIZWFkZXJWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJ1Y3R1cmVkLnBhcmFtcy5maWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtaW1lRnVuY3MuYnVpbGRIZWFkZXJWYWx1ZShzdHJ1Y3R1cmVkKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdDb250ZW50LVR5cGUnOlxuICAgICAgICAgICAgICAgICAgICBzdHJ1Y3R1cmVkID0gbWltZUZ1bmNzLnBhcnNlSGVhZGVyVmFsdWUodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNvbnRlbnRUeXBlKHN0cnVjdHVyZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJ1Y3R1cmVkLnZhbHVlLm1hdGNoKC9edGV4dFxcL3BsYWluXFxiLykgJiYgdHlwZW9mIHRoaXMuY29udGVudCA9PT0gJ3N0cmluZycgJiYgL1tcXHUwMDgwLVxcdUZGRkZdLy50ZXN0KHRoaXMuY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdHVyZWQucGFyYW1zLmNoYXJzZXQgPSAndXRmLTgnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtaW1lRnVuY3MuYnVpbGRIZWFkZXJWYWx1ZShzdHJ1Y3R1cmVkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maWxlbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHN1cHBvcnQgZm9yIG5vbi1jb21wbGlhbnQgY2xpZW50cyBsaWtlIFFRIHdlYm1haWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbid0IGJ1aWxkIHRoZSB2YWx1ZSB3aXRoIGJ1aWxkSGVhZGVyVmFsdWUgYXMgdGhlIHZhbHVlIGlzIG5vbiBzdGFuZGFyZCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIGNvbnZlcnRlZCB0byBwYXJhbWV0ZXIgY29udGludWF0aW9uIGVuY29kaW5nIHRoYXQgd2UgZG8gbm90IHdhbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtID0gdGhpcy5fZW5jb2RlV29yZHModGhpcy5maWxlbmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbSAhPT0gdGhpcy5maWxlbmFtZSB8fCAvW1xccydcIlxcXFw7Oi89KCksPD5AW1xcXT9dfF4tLy50ZXN0KHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgdmFsdWUgaW4gcXVvdGVzIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtID0gJ1wiJyArIHBhcmFtICsgJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9ICc7IG5hbWU9JyArIHBhcmFtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnQmNjJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmtlZXBCY2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNraXAgQkNDIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2VuY29kZUhlYWRlclZhbHVlKGtleSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBza2lwIGVtcHR5IGxpbmVzXG4gICAgICAgICAgICBpZiAoISh2YWx1ZSB8fCAnJykudG9TdHJpbmcoKS50cmltKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5ub3JtYWxpemVIZWFkZXJLZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9ybWFsaXplZCA9IHRoaXMubm9ybWFsaXplSGVhZGVyS2V5KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkICYmIHR5cGVvZiBub3JtYWxpemVkID09PSAnc3RyaW5nJyAmJiBub3JtYWxpemVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBub3JtYWxpemVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGVhZGVycy5wdXNoKG1pbWVGdW5jcy5mb2xkTGluZXMoa2V5ICsgJzogJyArIHZhbHVlLCA3NikpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaGVhZGVycy5qb2luKCdcXHJcXG4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHJlYW1zIHRoZSByZmMyODIyIG1lc3NhZ2UgZnJvbSB0aGUgY3VycmVudCBub2RlLiBJZiB0aGlzIGlzIGEgcm9vdCBub2RlLFxuICAgICAqIG1hbmRhdG9yeSBoZWFkZXIgZmllbGRzIGFyZSBzZXQgaWYgbWlzc2luZyAoRGF0ZSwgTWVzc2FnZS1JZCwgTUlNRS1WZXJzaW9uKVxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBDb21waWxlZCBtZXNzYWdlXG4gICAgICovXG4gICAgY3JlYXRlUmVhZFN0cmVhbShvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGxldCBzdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG4gICAgICAgIGxldCBvdXRwdXRTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIGxldCB0cmFuc2Zvcm07XG5cbiAgICAgICAgdGhpcy5zdHJlYW0oc3RyZWFtLCBvcHRpb25zLCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIG91dHB1dFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtLmVuZCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fdHJhbnNmb3Jtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdHJhbnNmb3JtID0gdHlwZW9mIHRoaXMuX3RyYW5zZm9ybXNbaV0gPT09ICdmdW5jdGlvbicgPyB0aGlzLl90cmFuc2Zvcm1zW2ldKCkgOiB0aGlzLl90cmFuc2Zvcm1zW2ldO1xuICAgICAgICAgICAgb3V0cHV0U3RyZWFtLm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdXRwdXRTdHJlYW0gPSBvdXRwdXRTdHJlYW0ucGlwZSh0cmFuc2Zvcm0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRlcm1pbmF0aW5nIG5ld2xpbmUgYWZ0ZXIgcG9zc2libGUgdXNlciB0cmFuc2Zvcm1zXG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBMYXN0TmV3bGluZSgpO1xuICAgICAgICBvdXRwdXRTdHJlYW0ub25jZSgnZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgdHJhbnNmb3JtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dFN0cmVhbSA9IG91dHB1dFN0cmVhbS5waXBlKHRyYW5zZm9ybSk7XG5cbiAgICAgICAgLy8gZGtpbSBhbmQgc3R1ZmZcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX3Byb2Nlc3NGdW5jcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdHJhbnNmb3JtID0gdGhpcy5fcHJvY2Vzc0Z1bmNzW2ldO1xuICAgICAgICAgICAgb3V0cHV0U3RyZWFtID0gdHJhbnNmb3JtKG91dHB1dFN0cmVhbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5uZXdsaW5lKSB7XG4gICAgICAgICAgICBjb25zdCB3aW5icmVhayA9IFsnd2luJywgJ3dpbmRvd3MnLCAnZG9zJywgJ1xcclxcbiddLmluY2x1ZGVzKHRoaXMubmV3bGluZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgY29uc3QgbmV3bGluZVRyYW5zZm9ybSA9IHdpbmJyZWFrID8gbmV3IExlV2luZG93cygpIDogbmV3IExlVW5peCgpO1xuXG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBvdXRwdXRTdHJlYW0ucGlwZShuZXdsaW5lVHJhbnNmb3JtKTtcbiAgICAgICAgICAgIG91dHB1dFN0cmVhbS5vbignZXJyb3InLCBlcnIgPT4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dFN0cmVhbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgdHJhbnNmb3JtIHN0cmVhbSBvYmplY3QgdG8gdGhlIHRyYW5zZm9ybXMgbGlzdC4gRmluYWwgb3V0cHV0XG4gICAgICogaXMgcGFzc2VkIHRocm91Z2ggdGhpcyBzdHJlYW0gYmVmb3JlIGV4cG9zaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIFJlYWQtV3JpdGUgc3RyZWFtXG4gICAgICovXG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgcG9zdCBwcm9jZXNzIGZ1bmN0aW9uLiBUaGUgZnVuY3RvbiBpcyBydW4gYWZ0ZXIgdHJhbnNmb3JtcyBhbmRcbiAgICAgKiB1c2VzIHRoZSBmb2xsb3dpbmcgc3ludGF4XG4gICAgICpcbiAgICAgKiAgIHByb2Nlc3NGdW5jKGlucHV0KSAtPiBvdXRwdXRTdHJlYW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9jZXNzRnVuYyBSZWFkLVdyaXRlIHN0cmVhbVxuICAgICAqL1xuICAgIHByb2Nlc3NGdW5jKHByb2Nlc3NGdW5jKSB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NGdW5jcy5wdXNoKHByb2Nlc3NGdW5jKTtcbiAgICB9XG5cbiAgICBzdHJlYW0ob3V0cHV0U3RyZWFtLCBvcHRpb25zLCBkb25lKSB7XG4gICAgICAgIGxldCB0cmFuc2ZlckVuY29kaW5nID0gdGhpcy5nZXRUcmFuc2ZlckVuY29kaW5nKCk7XG4gICAgICAgIGxldCBjb250ZW50U3RyZWFtO1xuICAgICAgICBsZXQgbG9jYWxTdHJlYW07XG5cbiAgICAgICAgLy8gcHJvdGVjdCBhY3R1YWwgY2FsbGJhY2sgYWdhaW5zdCBtdWx0aXBsZSB0cmlnZ2VyaW5nXG4gICAgICAgIGxldCByZXR1cm5lZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsbGJhY2sgPSBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGZvciBtdWx0aXBhcnQgbm9kZXMsIHB1c2ggY2hpbGQgbm9kZXNcbiAgICAgICAgLy8gZm9yIGNvbnRlbnQgbm9kZXMgZW5kIHRoZSBzdHJlYW1cbiAgICAgICAgbGV0IGZpbmFsaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNoaWxkSWQgPSAwO1xuICAgICAgICAgICAgbGV0IHByb2Nlc3NDaGlsZE5vZGUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkSWQgPj0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRTdHJlYW0ud3JpdGUoJ1xcclxcbi0tJyArIHRoaXMuYm91bmRhcnkgKyAnLS1cXHJcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGROb2Rlc1tjaGlsZElkKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFN0cmVhbS53cml0ZSgoY2hpbGRJZCA+IDEgPyAnXFxyXFxuJyA6ICcnKSArICctLScgKyB0aGlzLmJvdW5kYXJ5ICsgJ1xcclxcbicpO1xuICAgICAgICAgICAgICAgIGNoaWxkLnN0cmVhbShvdXRwdXRTdHJlYW0sIG9wdGlvbnMsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShwcm9jZXNzQ2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGFydCkge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShwcm9jZXNzQ2hpbGROb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcHVzaGVzIG5vZGUgY29udGVudFxuICAgICAgICBsZXQgc2VuZENvbnRlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzLmNvbnRlbnQpID09PSAnW29iamVjdCBFcnJvcl0nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRlbnQgaXMgYWxyZWFkeSBlcnJvcmVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb250ZW50LnBpcGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHRoaXMuX2NvbnRlbnRFcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50RXJyb3JIYW5kbGVyID0gZXJyID0+IGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5vbmNlKCdlcnJvcicsIHRoaXMuX2NvbnRlbnRFcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBjcmVhdGVTdHJlYW0gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChbJ3F1b3RlZC1wcmludGFibGUnLCAnYmFzZTY0J10uaW5jbHVkZXModHJhbnNmZXJFbmNvZGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTdHJlYW0gPSBuZXcgKHRyYW5zZmVyRW5jb2RpbmcgPT09ICdiYXNlNjQnID8gYmFzZTY0IDogcXApLkVuY29kZXIob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTdHJlYW0ucGlwZShvdXRwdXRTdHJlYW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTdHJlYW0ub25jZSgnZW5kJywgZmluYWxpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFN0cmVhbS5vbmNlKCdlcnJvcicsIGVyciA9PiBjYWxsYmFjayhlcnIpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdHJlYW0gPSB0aGlzLl9nZXRTdHJlYW0odGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RyZWFtLnBpcGUoY29udGVudFN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbnl0aGluZyB0aGF0IGlzIG5vdCBRUCBvciBCYXNlNTQgcGFzc2VzIGFzLWlzXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0cmVhbSA9IHRoaXMuX2dldFN0cmVhbSh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdHJlYW0ucGlwZShvdXRwdXRTdHJlYW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RyZWFtLm9uY2UoJ2VuZCcsIGZpbmFsaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RyZWFtLm9uY2UoJ2Vycm9yJywgZXJyID0+IGNhbGxiYWNrKGVycikpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZW50Ll9yZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNodW5rbGVuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVybmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzb3VyY2VTdHJlYW0gPSB0aGlzLl9nZXRTdHJlYW0odGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3RyZWFtLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3RyZWFtLm9uKCdyZWFkYWJsZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2h1bmsgPSBzb3VyY2VTdHJlYW0ucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua2xlbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VTdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5fcmVzb2x2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50Ll9yZXNvbHZlZFZhbHVlID0gQnVmZmVyLmNvbmNhdChjaHVua3MsIGNodW5rbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShjcmVhdGVTdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoY3JlYXRlU3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKGZpbmFsaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5fcmF3KSB7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcy5fcmF3KSA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb250ZW50IGlzIGFscmVhZHkgZXJyb3JlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fcmF3KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZGVmYXVsdCBlcnJvciBoYW5kbGVyIChpZiBzZXQpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9yYXcucGlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYXcucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fY29udGVudEVycm9ySGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHJhdyA9IHRoaXMuX2dldFN0cmVhbSh0aGlzLl9yYXcpO1xuICAgICAgICAgICAgICAgIHJhdy5waXBlKG91dHB1dFN0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICBlbmQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmF3Lm9uKCdlcnJvcicsIGVyciA9PiBvdXRwdXRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpKTtcbiAgICAgICAgICAgICAgICByYXcub24oJ2VuZCcsIGZpbmFsaXplKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0U3RyZWFtLndyaXRlKHRoaXMuYnVpbGRIZWFkZXJzKCkgKyAnXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoc2VuZENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBlbnZlbG9wZSB0byBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGdlbmVyYXRlZCBvbmVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gU01UUCBlbnZlbG9wZSBpbiB0aGUgZm9ybSBvZiB7ZnJvbTogJ2Zyb21AZXhhbXBsZS5jb20nLCB0bzogWyd0b0BleGFtcGxlLmNvbSddfVxuICAgICAqL1xuICAgIHNldEVudmVsb3BlKGVudmVsb3BlKSB7XG4gICAgICAgIGxldCBsaXN0O1xuXG4gICAgICAgIHRoaXMuX2VudmVsb3BlID0ge1xuICAgICAgICAgICAgZnJvbTogZmFsc2UsXG4gICAgICAgICAgICB0bzogW11cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZW52ZWxvcGUuZnJvbSkge1xuICAgICAgICAgICAgbGlzdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY29udmVydEFkZHJlc3Nlcyh0aGlzLl9wYXJzZUFkZHJlc3NlcyhlbnZlbG9wZS5mcm9tKSwgbGlzdCk7XG4gICAgICAgICAgICBsaXN0ID0gbGlzdC5maWx0ZXIoYWRkcmVzcyA9PiBhZGRyZXNzICYmIGFkZHJlc3MuYWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAobGlzdC5sZW5ndGggJiYgbGlzdFswXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VudmVsb3BlLmZyb20gPSBsaXN0WzBdLmFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgWyd0bycsICdjYycsICdiY2MnXS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAoZW52ZWxvcGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnZlcnRBZGRyZXNzZXModGhpcy5fcGFyc2VBZGRyZXNzZXMoZW52ZWxvcGVba2V5XSksIHRoaXMuX2VudmVsb3BlLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fZW52ZWxvcGUudG8gPSB0aGlzLl9lbnZlbG9wZS50by5tYXAodG8gPT4gdG8uYWRkcmVzcykuZmlsdGVyKGFkZHJlc3MgPT4gYWRkcmVzcyk7XG5cbiAgICAgICAgbGV0IHN0YW5kYXJkRmllbGRzID0gWyd0bycsICdjYycsICdiY2MnLCAnZnJvbSddO1xuICAgICAgICBPYmplY3Qua2V5cyhlbnZlbG9wZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzdGFuZGFyZEZpZWxkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW52ZWxvcGVba2V5XSA9IGVudmVsb3BlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBwYXJzZWQgYWRkcmVzcyBmaWVsZHNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQWRkcmVzcyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzZXMoKSB7XG4gICAgICAgIGxldCBhZGRyZXNzZXMgPSB7fTtcblxuICAgICAgICB0aGlzLl9oZWFkZXJzLmZvckVhY2goaGVhZGVyID0+IHtcbiAgICAgICAgICAgIGxldCBrZXkgPSBoZWFkZXIua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoWydmcm9tJywgJ3NlbmRlcicsICdyZXBseS10bycsICd0bycsICdjYycsICdiY2MnXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFkZHJlc3Nlc1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXNba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnZlcnRBZGRyZXNzZXModGhpcy5fcGFyc2VBZGRyZXNzZXMoaGVhZGVyLnZhbHVlKSwgYWRkcmVzc2VzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYWRkcmVzc2VzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyBTTVRQIGVudmVsb3BlIHdpdGggdGhlIHNlbmRlciBhZGRyZXNzIGFuZCBhIGxpc3Qgb2YgcmVjaXBpZW50cyBhZGRyZXNzZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gU01UUCBlbnZlbG9wZSBpbiB0aGUgZm9ybSBvZiB7ZnJvbTogJ2Zyb21AZXhhbXBsZS5jb20nLCB0bzogWyd0b0BleGFtcGxlLmNvbSddfVxuICAgICAqL1xuICAgIGdldEVudmVsb3BlKCkge1xuICAgICAgICBpZiAodGhpcy5fZW52ZWxvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbnZlbG9wZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBlbnZlbG9wZSA9IHtcbiAgICAgICAgICAgIGZyb206IGZhbHNlLFxuICAgICAgICAgICAgdG86IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2hlYWRlcnMuZm9yRWFjaChoZWFkZXIgPT4ge1xuICAgICAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgICAgIGlmIChoZWFkZXIua2V5ID09PSAnRnJvbScgfHwgKCFlbnZlbG9wZS5mcm9tICYmIFsnUmVwbHktVG8nLCAnU2VuZGVyJ10uaW5jbHVkZXMoaGVhZGVyLmtleSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udmVydEFkZHJlc3Nlcyh0aGlzLl9wYXJzZUFkZHJlc3NlcyhoZWFkZXIudmFsdWUpLCBsaXN0KTtcbiAgICAgICAgICAgICAgICBpZiAobGlzdC5sZW5ndGggJiYgbGlzdFswXSkge1xuICAgICAgICAgICAgICAgICAgICBlbnZlbG9wZS5mcm9tID0gbGlzdFswXS5hZGRyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoWydUbycsICdDYycsICdCY2MnXS5pbmNsdWRlcyhoZWFkZXIua2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnZlcnRBZGRyZXNzZXModGhpcy5fcGFyc2VBZGRyZXNzZXMoaGVhZGVyLnZhbHVlKSwgZW52ZWxvcGUudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBlbnZlbG9wZS50byA9IGVudmVsb3BlLnRvLm1hcCh0byA9PiB0by5hZGRyZXNzKTtcblxuICAgICAgICByZXR1cm4gZW52ZWxvcGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBNZXNzYWdlLUlkIHZhbHVlLiBJZiBpdCBkb2VzIG5vdCBleGlzdCwgdGhlbiBjcmVhdGVzIG9uZVxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBNZXNzYWdlLUlkIHZhbHVlXG4gICAgICovXG4gICAgbWVzc2FnZUlkKCkge1xuICAgICAgICBsZXQgbWVzc2FnZUlkID0gdGhpcy5nZXRIZWFkZXIoJ01lc3NhZ2UtSUQnKTtcbiAgICAgICAgLy8gWW91IHJlYWxseSBzaG91bGQgZGVmaW5lIHlvdXIgb3duIE1lc3NhZ2UtSWQgZmllbGQhXG4gICAgICAgIGlmICghbWVzc2FnZUlkKSB7XG4gICAgICAgICAgICBtZXNzYWdlSWQgPSB0aGlzLl9nZW5lcmF0ZU1lc3NhZ2VJZCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXIoJ01lc3NhZ2UtSUQnLCBtZXNzYWdlSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlSWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBwcmVnZW5lcmF0ZWQgY29udGVudCB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgb3V0cHV0IG9mIHRoaXMgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfFN0cmVhbX0gUmF3IE1JTUUgY29udGVudHNcbiAgICAgKi9cbiAgICBzZXRSYXcocmF3KSB7XG4gICAgICAgIHRoaXMuX3JhdyA9IHJhdztcblxuICAgICAgICBpZiAodGhpcy5fcmF3ICYmIHR5cGVvZiB0aGlzLl9yYXcucGlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gcHJlLXN0cmVhbSBoYW5kbGVyLiBtaWdodCBiZSB0cmlnZ2VyZWQgaWYgYSBzdHJlYW0gaXMgc2V0IGFzIGNvbnRlbnRcbiAgICAgICAgICAgIC8vIGFuZCAnZXJyb3InIGZpcmVzIGJlZm9yZSBhbnl0aGluZyBpcyBkb25lIHdpdGggdGhpcyBzdHJlYW1cbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRFcnJvckhhbmRsZXIgPSBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jhdy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9jb250ZW50RXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXcgPSBlcnI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fcmF3Lm9uY2UoJ2Vycm9yJywgdGhpcy5fY29udGVudEVycm9ySGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy8vLy8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyBhbmQgcmV0dXJucyBoYW5kbGUgdG8gYSBzdHJlYW0gcmVsYXRlZCB3aXRoIHRoZSBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNaXhlZH0gY29udGVudCBOb2RlIGNvbnRlbnRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBTdHJlYW0gb2JqZWN0XG4gICAgICovXG4gICAgX2dldFN0cmVhbShjb250ZW50KSB7XG4gICAgICAgIGxldCBjb250ZW50U3RyZWFtO1xuXG4gICAgICAgIGlmIChjb250ZW50Ll9yZXNvbHZlZFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBwYXNzIHN0cmluZyBvciBidWZmZXIgY29udGVudCBhcyBhIHN0cmVhbVxuICAgICAgICAgICAgY29udGVudFN0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuXG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTdHJlYW0uZW5kKGNvbnRlbnQuX3Jlc29sdmVkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50U3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRTdHJlYW07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRlbnQucGlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gYXNzdW1lIGFzIHN0cmVhbVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGVudCAmJiB0eXBlb2YgY29udGVudC5wYXRoID09PSAnc3RyaW5nJyAmJiAhY29udGVudC5ocmVmKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlRmlsZUFjY2Vzcykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRTdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goKTtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gY29udGVudFN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignRmlsZSBhY2Nlc3MgcmVqZWN0ZWQgZm9yICcgKyBjb250ZW50LnBhdGgpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRTdHJlYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWFkIGZpbGVcbiAgICAgICAgICAgIHJldHVybiBmcy5jcmVhdGVSZWFkU3RyZWFtKGNvbnRlbnQucGF0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGVudCAmJiB0eXBlb2YgY29udGVudC5ocmVmID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZVVybEFjY2Vzcykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRTdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goKTtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gY29udGVudFN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignVXJsIGFjY2VzcyByZWplY3RlZCBmb3IgJyArIGNvbnRlbnQuaHJlZikpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFN0cmVhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZldGNoIFVSTFxuICAgICAgICAgICAgcmV0dXJuIG5tZmV0Y2goY29udGVudC5ocmVmLCB7IGhlYWRlcnM6IGNvbnRlbnQuaHR0cEhlYWRlcnMgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXNzIHN0cmluZyBvciBidWZmZXIgY29udGVudCBhcyBhIHN0cmVhbVxuICAgICAgICAgICAgY29udGVudFN0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuXG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTdHJlYW0uZW5kKGNvbnRlbnQgfHwgJycpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50U3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50U3RyZWFtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFkZHJlc3Nlcy4gVGFrZXMgaW4gYSBzaW5nbGUgYWRkcmVzcyBvciBhbiBhcnJheSBvciBhblxuICAgICAqIGFycmF5IG9mIGFkZHJlc3MgYXJyYXlzIChlZy4gVG86IFtbZmlyc3QgZ3JvdXBdLCBbc2Vjb25kIGdyb3VwXSwuLi5dKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtNaXhlZH0gYWRkcmVzc2VzIEFkZHJlc3NlcyB0byBiZSBwYXJzZWRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgYWRkcmVzcyBvYmplY3RzXG4gICAgICovXG4gICAgX3BhcnNlQWRkcmVzc2VzKGFkZHJlc3Nlcykge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFxuICAgICAgICAgICAgW10sXG4gICAgICAgICAgICBbXS5jb25jYXQoYWRkcmVzc2VzKS5tYXAoYWRkcmVzcyA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgJiYgYWRkcmVzcy5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MuYWRkcmVzcyA9IHRoaXMuX25vcm1hbGl6ZUFkZHJlc3MoYWRkcmVzcy5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5uYW1lID0gYWRkcmVzcy5uYW1lIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2FkZHJlc3NdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzc3BhcnNlcihhZGRyZXNzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyBhIGhlYWRlciBrZXksIHVzZXMgQ2FtZWwtQ2FzZSBmb3JtLCBleGNlcHQgZm9yIHVwcGVyY2FzZSBNSU1FLVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgdG8gYmUgbm9ybWFsaXplZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30ga2V5IGluIENhbWVsLUNhc2UgZm9ybVxuICAgICAqL1xuICAgIF9ub3JtYWxpemVIZWFkZXJLZXkoa2V5KSB7XG4gICAgICAgIGtleSA9IChrZXkgfHwgJycpXG4gICAgICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAgICAgLy8gbm8gbmV3bGluZXMgaW4ga2V5c1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xccj9cXG58XFxyL2csICcgJylcbiAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAvLyB1c2UgdXBwZXJjYXNlIHdvcmRzLCBleGNlcHQgTUlNRVxuICAgICAgICAgICAgLnJlcGxhY2UoL15YLVNNVFBBUEkkfF4oTUlNRXxES0lNfEFSQ3xCSU1JKVxcYnxeW2Etel18LShTUEZ8RkJMfElEfE1ENSkkfC1bYS16XS9naSwgYyA9PiBjLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2VcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eQ29udGVudC1GZWF0dXJlcyQvaSwgJ0NvbnRlbnQtZmVhdHVyZXMnKTtcblxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY29udGVudCB0eXBlIGlzIG11bHRpcGFydCBhbmQgZGVmaW5lcyBib3VuZGFyeSBpZiBuZWVkZWQuXG4gICAgICogRG9lc24ndCByZXR1cm4gYW55dGhpbmcsIG1vZGlmaWVzIG9iamVjdCBhcmd1bWVudCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0cnVjdHVyZWQgUGFyc2VkIGhlYWRlciB2YWx1ZSBmb3IgJ0NvbnRlbnQtVHlwZScga2V5XG4gICAgICovXG4gICAgX2hhbmRsZUNvbnRlbnRUeXBlKHN0cnVjdHVyZWQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IHN0cnVjdHVyZWQudmFsdWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgdGhpcy5tdWx0aXBhcnQgPSAvXm11bHRpcGFydFxcLy9pLnRlc3QodGhpcy5jb250ZW50VHlwZSkgPyB0aGlzLmNvbnRlbnRUeXBlLnN1YnN0cih0aGlzLmNvbnRlbnRUeXBlLmluZGV4T2YoJy8nKSArIDEpIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMubXVsdGlwYXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmJvdW5kYXJ5ID0gc3RydWN0dXJlZC5wYXJhbXMuYm91bmRhcnkgPSBzdHJ1Y3R1cmVkLnBhcmFtcy5ib3VuZGFyeSB8fCB0aGlzLmJvdW5kYXJ5IHx8IHRoaXMuX2dlbmVyYXRlQm91bmRhcnkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRhcnkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG11bHRpcGFydCBib3VuZGFyeSB2YWx1ZVxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBib3VuZGFyeSB2YWx1ZVxuICAgICAqL1xuICAgIF9nZW5lcmF0ZUJvdW5kYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Tm9kZS5ib3VuZGFyeVByZWZpeCArICctJyArIHRoaXMucm9vdE5vZGUuYmFzZUJvdW5kYXJ5ICsgJy1QYXJ0XycgKyB0aGlzLl9ub2RlSWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhIGhlYWRlciB2YWx1ZSBmb3IgdXNlIGluIHRoZSBnZW5lcmF0ZWQgcmZjMjgyMiBlbWFpbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgSGVhZGVyIGtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBIZWFkZXIgdmFsdWVcbiAgICAgKi9cbiAgICBfZW5jb2RlSGVhZGVyVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXkgPSB0aGlzLl9ub3JtYWxpemVIZWFkZXJLZXkoa2V5KTtcblxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgLy8gU3RydWN0dXJlZCBoZWFkZXJzXG4gICAgICAgICAgICBjYXNlICdGcm9tJzpcbiAgICAgICAgICAgIGNhc2UgJ1NlbmRlcic6XG4gICAgICAgICAgICBjYXNlICdUbyc6XG4gICAgICAgICAgICBjYXNlICdDYyc6XG4gICAgICAgICAgICBjYXNlICdCY2MnOlxuICAgICAgICAgICAgY2FzZSAnUmVwbHktVG8nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0QWRkcmVzc2VzKHRoaXMuX3BhcnNlQWRkcmVzc2VzKHZhbHVlKSk7XG5cbiAgICAgICAgICAgIC8vIHZhbHVlcyBlbmNsb3NlZCBpbiA8PlxuICAgICAgICAgICAgY2FzZSAnTWVzc2FnZS1JRCc6XG4gICAgICAgICAgICBjYXNlICdJbi1SZXBseS1Ubyc6XG4gICAgICAgICAgICBjYXNlICdDb250ZW50LUlkJzpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8fCAnJykudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCAnICcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNoYXJBdCgwKSAhPT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJzwnICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNoYXJBdCh2YWx1ZS5sZW5ndGggLSAxKSAhPT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAnPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgdmFsdWVzIGVuY2xvc2VkIGluIDw+XG4gICAgICAgICAgICBjYXNlICdSZWZlcmVuY2VzJzpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdLmNvbmNhdFxuICAgICAgICAgICAgICAgICAgICAuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdLmNvbmNhdCh2YWx1ZSB8fCAnJykubWFwKGVsbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtID0gKGVsbSB8fCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xccj9cXG58XFxyL2csICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxtLnJlcGxhY2UoLzxbXj5dKj4vZywgc3RyID0+IHN0ci5yZXBsYWNlKC9cXHMvZywgJycpKS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGVsbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxtLmNoYXJBdCgwKSAhPT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtID0gJzwnICsgZWxtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsbS5jaGFyQXQoZWxtLmxlbmd0aCAtIDEpICE9PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbG0gPSBlbG0gKyAnPic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxtO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5qb2luKCcgJykudHJpbSgpO1xuXG4gICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1VUQ1N0cmluZygpLnJlcGxhY2UoL0dNVC8sICcrMDAwMCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlIHx8ICcnKS50b1N0cmluZygpLnJlcGxhY2UoL1xccj9cXG58XFxyL2csICcgJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVdvcmRzKHZhbHVlKTtcblxuICAgICAgICAgICAgY2FzZSAnQ29udGVudC1UeXBlJzpcbiAgICAgICAgICAgIGNhc2UgJ0NvbnRlbnQtRGlzcG9zaXRpb24nOlxuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGluY2x1ZGVzIGEgZmlsZW5hbWUgdGhlbiBpdCBpcyBhbHJlYWR5IGVuY29kZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlIHx8ICcnKS50b1N0cmluZygpLnJlcGxhY2UoL1xccj9cXG58XFxyL2csICcgJyk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgfHwgJycpLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgJyAnKTtcbiAgICAgICAgICAgICAgICAvLyBlbmNvZGVXb3JkcyBvbmx5IGVuY29kZXMgaWYgbmVlZGVkLCBvdGhlcndpc2UgdGhlIG9yaWdpbmFsIHN0cmluZyBpcyByZXR1cm5lZFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVXb3Jkcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWJ1aWxkcyBhZGRyZXNzIG9iamVjdCB1c2luZyBwdW55Y29kZSBhbmQgb3RoZXIgYWRqdXN0bWVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFkZHJlc3NlcyBBbiBhcnJheSBvZiBhZGRyZXNzIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdW5pcXVlTGlzdF0gQW4gYXJyYXkgdG8gYmUgcG9wdWxhdGVkIHdpdGggYWRkcmVzc2VzXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBhZGRyZXNzIHN0cmluZ1xuICAgICAqL1xuICAgIF9jb252ZXJ0QWRkcmVzc2VzKGFkZHJlc3NlcywgdW5pcXVlTGlzdCkge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG5cbiAgICAgICAgdW5pcXVlTGlzdCA9IHVuaXF1ZUxpc3QgfHwgW107XG5cbiAgICAgICAgW10uY29uY2F0KGFkZHJlc3NlcyB8fCBbXSkuZm9yRWFjaChhZGRyZXNzID0+IHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLmFkZHJlc3MgPSB0aGlzLl9ub3JtYWxpemVBZGRyZXNzKGFkZHJlc3MuYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFkZHJlc3MubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChhZGRyZXNzLmFkZHJlc3MuaW5kZXhPZignICcpID49IDAgPyBgPCR7YWRkcmVzcy5hZGRyZXNzfT5gIDogYCR7YWRkcmVzcy5hZGRyZXNzfWApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGAke3RoaXMuX2VuY29kZUFkZHJlc3NOYW1lKGFkZHJlc3MubmFtZSl9IDwke2FkZHJlc3MuYWRkcmVzc30+YCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZUxpc3QuZmlsdGVyKGEgPT4gYS5hZGRyZXNzID09PSBhZGRyZXNzLmFkZHJlc3MpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlTGlzdC5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhZGRyZXNzLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwTGlzdEFkZHJlc3NlcyA9IChhZGRyZXNzLmdyb3VwLmxlbmd0aCA/IHRoaXMuX2NvbnZlcnRBZGRyZXNzZXMoYWRkcmVzcy5ncm91cCwgdW5pcXVlTGlzdCkgOiAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGAke3RoaXMuX2VuY29kZUFkZHJlc3NOYW1lKGFkZHJlc3MubmFtZSl9OiR7Z3JvdXBMaXN0QWRkcmVzc2VzfTtgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcy5qb2luKCcsICcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYW4gZW1haWwgYWRkcmVzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWRkcmVzcyBBbiBhcnJheSBvZiBhZGRyZXNzIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGFkZHJlc3Mgc3RyaW5nXG4gICAgICovXG4gICAgX25vcm1hbGl6ZUFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICBhZGRyZXNzID0gKGFkZHJlc3MgfHwgJycpXG4gICAgICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgxRjw+XSsvZywgJyAnKSAvLyByZW1vdmUgdW5hbGxvd2VkIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIC50cmltKCk7XG5cbiAgICAgICAgbGV0IGxhc3RBdCA9IGFkZHJlc3MubGFzdEluZGV4T2YoJ0AnKTtcbiAgICAgICAgaWYgKGxhc3RBdCA8IDApIHtcbiAgICAgICAgICAgIC8vIEJhcmUgdXNlcm5hbWVcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHVzZXIgPSBhZGRyZXNzLnN1YnN0cigwLCBsYXN0QXQpO1xuICAgICAgICBsZXQgZG9tYWluID0gYWRkcmVzcy5zdWJzdHIobGFzdEF0ICsgMSk7XG5cbiAgICAgICAgLy8gVXNlcm5hbWVzIGFyZSBub3QgdG91Y2hlZCBhbmQgYXJlIGtlcHQgYXMgaXMgZXZlbiBpZiB0aGVzZSBpbmNsdWRlIHVuaWNvZGVcbiAgICAgICAgLy8gRG9tYWlucyBhcmUgcHVueWNvZGVkIGJ5IGRlZmF1bHRcbiAgICAgICAgLy8gJ2rDtWdldmEuZWUnIHdpbGwgYmUgY29udmVydGVkIHRvICd4bi0tamdldmEtZHVhLmVlJ1xuICAgICAgICAvLyBub24tdW5pY29kZSBkb21haW5zIGFyZSBsZWZ0IGFzIGlzXG5cbiAgICAgICAgbGV0IGVuY29kZWREb21haW47XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVuY29kZWREb21haW4gPSBwdW55Y29kZS50b0FTQ0lJKGRvbWFpbi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBrZWVwIGFzIGlzP1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVzZXIuaW5kZXhPZignICcpID49IDApIHtcbiAgICAgICAgICAgIGlmICh1c2VyLmNoYXJBdCgwKSAhPT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIHVzZXIgPSAnXCInICsgdXNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2VyLnN1YnN0cigtMSkgIT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICB1c2VyID0gdXNlciArICdcIic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYCR7dXNlcn1AJHtlbmNvZGVkRG9tYWlufWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgbmVlZGVkLCBtaW1lIGVuY29kZXMgdGhlIG5hbWUgcGFydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBwYXJ0IG9mIGFuIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBNaW1lIHdvcmQgZW5jb2RlZCBzdHJpbmcgaWYgbmVlZGVkXG4gICAgICovXG4gICAgX2VuY29kZUFkZHJlc3NOYW1lKG5hbWUpIHtcbiAgICAgICAgaWYgKCEvXltcXHcgXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoL15bXFx4MjAtXFx4N2VdKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1wiJyArIG5hbWUucmVwbGFjZSgvKFtcXFxcXCJdKS9nLCAnXFxcXCQxJykgKyAnXCInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWltZUZ1bmNzLmVuY29kZVdvcmQobmFtZSwgdGhpcy5fZ2V0VGV4dEVuY29kaW5nKG5hbWUpLCA1Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgbmVlZGVkLCBtaW1lIGVuY29kZXMgdGhlIG5hbWUgcGFydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBwYXJ0IG9mIGFuIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBNaW1lIHdvcmQgZW5jb2RlZCBzdHJpbmcgaWYgbmVlZGVkXG4gICAgICovXG4gICAgX2VuY29kZVdvcmRzKHZhbHVlKSB7XG4gICAgICAgIC8vIHNldCBlbmNvZGVBbGwgcGFyYW1ldGVyIHRvIHRydWUgZXZlbiB0aG91Z2ggaXQgaXMgYWdhaW5zdCB0aGUgcmVjb21tZW5kYXRpb24gb2YgUkZDMjA0NyxcbiAgICAgICAgLy8gYnkgZGVmYXVsdCBvbmx5IHdvcmRzIHRoYXQgaW5jbHVkZSBub24tYXNjaWkgc2hvdWxkIGJlIGNvbnZlcnRlZCBpbnRvIGVuY29kZWQgd29yZHNcbiAgICAgICAgLy8gYnV0IHNvbWUgY2xpZW50cyAoZWcuIFppbWJyYSkgZG8gbm90IGhhbmRsZSBpdCBwcm9wZXJseSBhbmQgcmVtb3ZlIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgcmV0dXJuIG1pbWVGdW5jcy5lbmNvZGVXb3Jkcyh2YWx1ZSwgdGhpcy5fZ2V0VGV4dEVuY29kaW5nKHZhbHVlKSwgNTIsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVjdHMgYmVzdCBtaW1lIGVuY29kaW5nIGZvciBhIHRleHQgdmFsdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byBjaGVjayBmb3JcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGVpdGhlciAnUScgb3IgJ0InXG4gICAgICovXG4gICAgX2dldFRleHRFbmNvZGluZyh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8fCAnJykudG9TdHJpbmcoKTtcblxuICAgICAgICBsZXQgZW5jb2RpbmcgPSB0aGlzLnRleHRFbmNvZGluZztcbiAgICAgICAgbGV0IGxhdGluTGVuO1xuICAgICAgICBsZXQgbm9uTGF0aW5MZW47XG5cbiAgICAgICAgaWYgKCFlbmNvZGluZykge1xuICAgICAgICAgICAgLy8gY291bnQgbGF0aW4gYWxwaGFiZXQgc3ltYm9scyBhbmQgOC1iaXQgcmFuZ2Ugc3ltYm9scyArIGNvbnRyb2wgc3ltYm9sc1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG1vcmUgbGF0aW4gY2hhcmFjdGVycywgdGhlbiB1c2UgcXVvdGVkLXByaW50YWJsZVxuICAgICAgICAgICAgLy8gZW5jb2RpbmcsIG90aGVyd2lzZSB1c2UgYmFzZTY0XG4gICAgICAgICAgICBub25MYXRpbkxlbiA9ICh2YWx1ZS5tYXRjaCgvW1xceDAwLVxceDA4XFx4MEJcXHgwQ1xceDBFLVxceDFGXFx1MDA4MC1cXHVGRkZGXS9nKSB8fCBbXSkubGVuZ3RoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICAgICAgICAgIGxhdGluTGVuID0gKHZhbHVlLm1hdGNoKC9bYS16XS9naSkgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBtb3JlIGxhdGluIHN5bWJvbHMgdGhhbiBiaW5hcnkvdW5pY29kZSwgdGhlbiBwcmVmZXIgUSwgb3RoZXJ3aXNlIEJcbiAgICAgICAgICAgIGVuY29kaW5nID0gbm9uTGF0aW5MZW4gPCBsYXRpbkxlbiA/ICdRJyA6ICdCJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2Rpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbWVzc2FnZSBpZFxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBSYW5kb20gTWVzc2FnZS1JRCB2YWx1ZVxuICAgICAqL1xuICAgIF9nZW5lcmF0ZU1lc3NhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICc8JyArXG4gICAgICAgICAgICBbMiwgMiwgMiwgNl0ucmVkdWNlKFxuICAgICAgICAgICAgICAgIC8vIGNydXggdG8gZ2VuZXJhdGUgVVVJRC1saWtlIHJhbmRvbSBzdHJpbmdzXG4gICAgICAgICAgICAgICAgKHByZXYsIGxlbikgPT4gcHJldiArICctJyArIGNyeXB0by5yYW5kb21CeXRlcyhsZW4pLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNCkudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgICAgICApICtcbiAgICAgICAgICAgICdAJyArXG4gICAgICAgICAgICAvLyB0cnkgdG8gdXNlIHRoZSBkb21haW4gb2YgdGhlIEZST00gYWRkcmVzcyBvciBmYWxsYmFjayB0byBzZXJ2ZXIgaG9zdG5hbWVcbiAgICAgICAgICAgICh0aGlzLmdldEVudmVsb3BlKCkuZnJvbSB8fCB0aGlzLmhvc3RuYW1lIHx8ICdsb2NhbGhvc3QnKS5zcGxpdCgnQCcpLnBvcCgpICtcbiAgICAgICAgICAgICc+J1xuICAgICAgICApO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNaW1lTm9kZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/mime-node/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/mime-node/last-newline.js":
/*!***************************************************************!*\
  !*** ./node_modules/nodemailer/lib/mime-node/last-newline.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\n\nclass LastNewline extends Transform {\n    constructor() {\n        super();\n        this.lastByte = false;\n    }\n\n    _transform(chunk, encoding, done) {\n        if (chunk.length) {\n            this.lastByte = chunk[chunk.length - 1];\n        }\n\n        this.push(chunk);\n        done();\n    }\n\n    _flush(done) {\n        if (this.lastByte === 0x0a) {\n            return done();\n        }\n        if (this.lastByte === 0x0d) {\n            this.push(Buffer.from('\\n'));\n            return done();\n        }\n        this.push(Buffer.from('\\r\\n'));\n        return done();\n    }\n}\n\nmodule.exports = LastNewline;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvbWltZS1ub2RlL2xhc3QtbmV3bGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsdURBQTJCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9taW1lLW5vZGUvbGFzdC1uZXdsaW5lLmpzP2ExZTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm07XG5cbmNsYXNzIExhc3ROZXdsaW5lIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sYXN0Qnl0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBkb25lKSB7XG4gICAgICAgIGlmIChjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEJ5dGUgPSBjaHVua1tjaHVuay5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHVzaChjaHVuayk7XG4gICAgICAgIGRvbmUoKTtcbiAgICB9XG5cbiAgICBfZmx1c2goZG9uZSkge1xuICAgICAgICBpZiAodGhpcy5sYXN0Qnl0ZSA9PT0gMHgwYSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXN0Qnl0ZSA9PT0gMHgwZCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKEJ1ZmZlci5mcm9tKCdcXG4nKSk7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVzaChCdWZmZXIuZnJvbSgnXFxyXFxuJykpO1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMYXN0TmV3bGluZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/mime-node/last-newline.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/mime-node/le-unix.js":
/*!**********************************************************!*\
  !*** ./node_modules/nodemailer/lib/mime-node/le-unix.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst Transform = stream.Transform;\n\n/**\n * Ensures that only <LF> is used for linebreaks\n *\n * @param {Object} options Stream options\n */\nclass LeWindows extends Transform {\n    constructor(options) {\n        super(options);\n        // init Transform\n        this.options = options || {};\n    }\n\n    /**\n     * Escapes dots\n     */\n    _transform(chunk, encoding, done) {\n        let buf;\n        let lastPos = 0;\n\n        for (let i = 0, len = chunk.length; i < len; i++) {\n            if (chunk[i] === 0x0d) {\n                // \\n\n                buf = chunk.slice(lastPos, i);\n                lastPos = i + 1;\n                this.push(buf);\n            }\n        }\n        if (lastPos && lastPos < chunk.length) {\n            buf = chunk.slice(lastPos);\n            this.push(buf);\n        } else if (!lastPos) {\n            this.push(chunk);\n        }\n        done();\n    }\n}\n\nmodule.exports = LeWindows;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvbWltZS1ub2RlL2xlLXVuaXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlbWFya2V0Ly4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL21pbWUtbm9kZS9sZS11bml4LmpzPzA1ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IFRyYW5zZm9ybSA9IHN0cmVhbS5UcmFuc2Zvcm07XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0IG9ubHkgPExGPiBpcyB1c2VkIGZvciBsaW5lYnJlYWtzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgU3RyZWFtIG9wdGlvbnNcbiAqL1xuY2xhc3MgTGVXaW5kb3dzIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICAvLyBpbml0IFRyYW5zZm9ybVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgZG90c1xuICAgICAqL1xuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBkb25lKSB7XG4gICAgICAgIGxldCBidWY7XG4gICAgICAgIGxldCBsYXN0UG9zID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2h1bmsubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjaHVua1tpXSA9PT0gMHgwZCkge1xuICAgICAgICAgICAgICAgIC8vIFxcblxuICAgICAgICAgICAgICAgIGJ1ZiA9IGNodW5rLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goYnVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFBvcyAmJiBsYXN0UG9zIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBidWYgPSBjaHVuay5zbGljZShsYXN0UG9zKTtcbiAgICAgICAgICAgIHRoaXMucHVzaChidWYpO1xuICAgICAgICB9IGVsc2UgaWYgKCFsYXN0UG9zKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUoKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGVXaW5kb3dzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/mime-node/le-unix.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/mime-node/le-windows.js":
/*!*************************************************************!*\
  !*** ./node_modules/nodemailer/lib/mime-node/le-windows.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst Transform = stream.Transform;\n\n/**\n * Ensures that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\nclass LeWindows extends Transform {\n    constructor(options) {\n        super(options);\n        // init Transform\n        this.options = options || {};\n        this.lastByte = false;\n    }\n\n    /**\n     * Escapes dots\n     */\n    _transform(chunk, encoding, done) {\n        let buf;\n        let lastPos = 0;\n\n        for (let i = 0, len = chunk.length; i < len; i++) {\n            if (chunk[i] === 0x0a) {\n                // \\n\n                if ((i && chunk[i - 1] !== 0x0d) || (!i && this.lastByte !== 0x0d)) {\n                    if (i > lastPos) {\n                        buf = chunk.slice(lastPos, i);\n                        this.push(buf);\n                    }\n                    this.push(Buffer.from('\\r\\n'));\n                    lastPos = i + 1;\n                }\n            }\n        }\n\n        if (lastPos && lastPos < chunk.length) {\n            buf = chunk.slice(lastPos);\n            this.push(buf);\n        } else if (!lastPos) {\n            this.push(chunk);\n        }\n\n        this.lastByte = chunk[chunk.length - 1];\n        done();\n    }\n}\n\nmodule.exports = LeWindows;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvbWltZS1ub2RlL2xlLXdpbmRvd3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9taW1lLW5vZGUvbGUtd2luZG93cy5qcz9iMWQ1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCBUcmFuc2Zvcm0gPSBzdHJlYW0uVHJhbnNmb3JtO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCBvbmx5IDxDUj48TEY+IHNlcXVlbmNlcyBhcmUgdXNlZCBmb3IgbGluZWJyZWFrc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFN0cmVhbSBvcHRpb25zXG4gKi9cbmNsYXNzIExlV2luZG93cyBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgLy8gaW5pdCBUcmFuc2Zvcm1cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5sYXN0Qnl0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgZG90c1xuICAgICAqL1xuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBkb25lKSB7XG4gICAgICAgIGxldCBidWY7XG4gICAgICAgIGxldCBsYXN0UG9zID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2h1bmsubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjaHVua1tpXSA9PT0gMHgwYSkge1xuICAgICAgICAgICAgICAgIC8vIFxcblxuICAgICAgICAgICAgICAgIGlmICgoaSAmJiBjaHVua1tpIC0gMV0gIT09IDB4MGQpIHx8ICghaSAmJiB0aGlzLmxhc3RCeXRlICE9PSAweDBkKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IGxhc3RQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGNodW5rLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKEJ1ZmZlci5mcm9tKCdcXHJcXG4nKSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdFBvcyAmJiBsYXN0UG9zIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBidWYgPSBjaHVuay5zbGljZShsYXN0UG9zKTtcbiAgICAgICAgICAgIHRoaXMucHVzaChidWYpO1xuICAgICAgICB9IGVsc2UgaWYgKCFsYXN0UG9zKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0Qnl0ZSA9IGNodW5rW2NodW5rLmxlbmd0aCAtIDFdO1xuICAgICAgICBkb25lKCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExlV2luZG93cztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/mime-node/le-windows.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/nodemailer.js":
/*!***************************************************!*\
  !*** ./node_modules/nodemailer/lib/nodemailer.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Mailer = __webpack_require__(/*! ./mailer */ \"(rsc)/./node_modules/nodemailer/lib/mailer/index.js\");\nconst shared = __webpack_require__(/*! ./shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\");\nconst SMTPPool = __webpack_require__(/*! ./smtp-pool */ \"(rsc)/./node_modules/nodemailer/lib/smtp-pool/index.js\");\nconst SMTPTransport = __webpack_require__(/*! ./smtp-transport */ \"(rsc)/./node_modules/nodemailer/lib/smtp-transport/index.js\");\nconst SendmailTransport = __webpack_require__(/*! ./sendmail-transport */ \"(rsc)/./node_modules/nodemailer/lib/sendmail-transport/index.js\");\nconst StreamTransport = __webpack_require__(/*! ./stream-transport */ \"(rsc)/./node_modules/nodemailer/lib/stream-transport/index.js\");\nconst JSONTransport = __webpack_require__(/*! ./json-transport */ \"(rsc)/./node_modules/nodemailer/lib/json-transport/index.js\");\nconst SESTransport = __webpack_require__(/*! ./ses-transport */ \"(rsc)/./node_modules/nodemailer/lib/ses-transport/index.js\");\nconst nmfetch = __webpack_require__(/*! ./fetch */ \"(rsc)/./node_modules/nodemailer/lib/fetch/index.js\");\nconst packageData = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/nodemailer/package.json\");\n\nconst ETHEREAL_API = (process.env.ETHEREAL_API || 'https://api.nodemailer.com').replace(/\\/+$/, '');\nconst ETHEREAL_WEB = (process.env.ETHEREAL_WEB || 'https://ethereal.email').replace(/\\/+$/, '');\nconst ETHEREAL_CACHE = ['true', 'yes', 'y', '1'].includes((process.env.ETHEREAL_CACHE || 'yes').toString().trim().toLowerCase());\n\nlet testAccount = false;\n\nmodule.exports.createTransport = function (transporter, defaults) {\n    let urlConfig;\n    let options;\n    let mailer;\n\n    if (\n        // provided transporter is a configuration object, not transporter plugin\n        (typeof transporter === 'object' && typeof transporter.send !== 'function') ||\n        // provided transporter looks like a connection url\n        (typeof transporter === 'string' && /^(smtps?|direct):/i.test(transporter))\n    ) {\n        if ((urlConfig = typeof transporter === 'string' ? transporter : transporter.url)) {\n            // parse a configuration URL into configuration options\n            options = shared.parseConnectionUrl(urlConfig);\n        } else {\n            options = transporter;\n        }\n\n        if (options.pool) {\n            transporter = new SMTPPool(options);\n        } else if (options.sendmail) {\n            transporter = new SendmailTransport(options);\n        } else if (options.streamTransport) {\n            transporter = new StreamTransport(options);\n        } else if (options.jsonTransport) {\n            transporter = new JSONTransport(options);\n        } else if (options.SES) {\n            transporter = new SESTransport(options);\n        } else {\n            transporter = new SMTPTransport(options);\n        }\n    }\n\n    mailer = new Mailer(transporter, options, defaults);\n\n    return mailer;\n};\n\nmodule.exports.createTestAccount = function (apiUrl, callback) {\n    let promise;\n\n    if (!callback && typeof apiUrl === 'function') {\n        callback = apiUrl;\n        apiUrl = false;\n    }\n\n    if (!callback) {\n        promise = new Promise((resolve, reject) => {\n            callback = shared.callbackPromise(resolve, reject);\n        });\n    }\n\n    if (ETHEREAL_CACHE && testAccount) {\n        setImmediate(() => callback(null, testAccount));\n        return promise;\n    }\n\n    apiUrl = apiUrl || ETHEREAL_API;\n\n    let chunks = [];\n    let chunklen = 0;\n\n    let req = nmfetch(apiUrl + '/user', {\n        contentType: 'application/json',\n        method: 'POST',\n        body: Buffer.from(\n            JSON.stringify({\n                requestor: packageData.name,\n                version: packageData.version\n            })\n        )\n    });\n\n    req.on('readable', () => {\n        let chunk;\n        while ((chunk = req.read()) !== null) {\n            chunks.push(chunk);\n            chunklen += chunk.length;\n        }\n    });\n\n    req.once('error', err => callback(err));\n\n    req.once('end', () => {\n        let res = Buffer.concat(chunks, chunklen);\n        let data;\n        let err;\n        try {\n            data = JSON.parse(res.toString());\n        } catch (E) {\n            err = E;\n        }\n        if (err) {\n            return callback(err);\n        }\n        if (data.status !== 'success' || data.error) {\n            return callback(new Error(data.error || 'Request failed'));\n        }\n        delete data.status;\n        testAccount = data;\n        callback(null, testAccount);\n    });\n\n    return promise;\n};\n\nmodule.exports.getTestMessageUrl = function (info) {\n    if (!info || !info.response) {\n        return false;\n    }\n\n    let infoProps = new Map();\n    info.response.replace(/\\[([^\\]]+)\\]$/, (m, props) => {\n        props.replace(/\\b([A-Z0-9]+)=([^\\s]+)/g, (m, key, value) => {\n            infoProps.set(key, value);\n        });\n    });\n\n    if (infoProps.has('STATUS') && infoProps.has('MSGID')) {\n        return (testAccount.web || ETHEREAL_WEB) + '/message/' + infoProps.get('MSGID');\n    }\n\n    return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvbm9kZW1haWxlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMscUVBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLHFFQUFVO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLDJFQUFhO0FBQ3RDLHNCQUFzQixtQkFBTyxDQUFDLHFGQUFrQjtBQUNoRCwwQkFBMEIsbUJBQU8sQ0FBQyw2RkFBc0I7QUFDeEQsd0JBQXdCLG1CQUFPLENBQUMseUZBQW9CO0FBQ3BELHNCQUFzQixtQkFBTyxDQUFDLHFGQUFrQjtBQUNoRCxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBaUI7QUFDOUMsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQVM7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMscUVBQWlCOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9ub2RlbWFpbGVyLmpzPzYyMTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNYWlsZXIgPSByZXF1aXJlKCcuL21haWxlcicpO1xuY29uc3Qgc2hhcmVkID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcbmNvbnN0IFNNVFBQb29sID0gcmVxdWlyZSgnLi9zbXRwLXBvb2wnKTtcbmNvbnN0IFNNVFBUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3NtdHAtdHJhbnNwb3J0Jyk7XG5jb25zdCBTZW5kbWFpbFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vc2VuZG1haWwtdHJhbnNwb3J0Jyk7XG5jb25zdCBTdHJlYW1UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3N0cmVhbS10cmFuc3BvcnQnKTtcbmNvbnN0IEpTT05UcmFuc3BvcnQgPSByZXF1aXJlKCcuL2pzb24tdHJhbnNwb3J0Jyk7XG5jb25zdCBTRVNUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3Nlcy10cmFuc3BvcnQnKTtcbmNvbnN0IG5tZmV0Y2ggPSByZXF1aXJlKCcuL2ZldGNoJyk7XG5jb25zdCBwYWNrYWdlRGF0YSA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuXG5jb25zdCBFVEhFUkVBTF9BUEkgPSAocHJvY2Vzcy5lbnYuRVRIRVJFQUxfQVBJIHx8ICdodHRwczovL2FwaS5ub2RlbWFpbGVyLmNvbScpLnJlcGxhY2UoL1xcLyskLywgJycpO1xuY29uc3QgRVRIRVJFQUxfV0VCID0gKHByb2Nlc3MuZW52LkVUSEVSRUFMX1dFQiB8fCAnaHR0cHM6Ly9ldGhlcmVhbC5lbWFpbCcpLnJlcGxhY2UoL1xcLyskLywgJycpO1xuY29uc3QgRVRIRVJFQUxfQ0FDSEUgPSBbJ3RydWUnLCAneWVzJywgJ3knLCAnMSddLmluY2x1ZGVzKChwcm9jZXNzLmVudi5FVEhFUkVBTF9DQUNIRSB8fCAneWVzJykudG9TdHJpbmcoKS50cmltKCkudG9Mb3dlckNhc2UoKSk7XG5cbmxldCB0ZXN0QWNjb3VudCA9IGZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAodHJhbnNwb3J0ZXIsIGRlZmF1bHRzKSB7XG4gICAgbGV0IHVybENvbmZpZztcbiAgICBsZXQgb3B0aW9ucztcbiAgICBsZXQgbWFpbGVyO1xuXG4gICAgaWYgKFxuICAgICAgICAvLyBwcm92aWRlZCB0cmFuc3BvcnRlciBpcyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBub3QgdHJhbnNwb3J0ZXIgcGx1Z2luXG4gICAgICAgICh0eXBlb2YgdHJhbnNwb3J0ZXIgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0cmFuc3BvcnRlci5zZW5kICE9PSAnZnVuY3Rpb24nKSB8fFxuICAgICAgICAvLyBwcm92aWRlZCB0cmFuc3BvcnRlciBsb29rcyBsaWtlIGEgY29ubmVjdGlvbiB1cmxcbiAgICAgICAgKHR5cGVvZiB0cmFuc3BvcnRlciA9PT0gJ3N0cmluZycgJiYgL14oc210cHM/fGRpcmVjdCk6L2kudGVzdCh0cmFuc3BvcnRlcikpXG4gICAgKSB7XG4gICAgICAgIGlmICgodXJsQ29uZmlnID0gdHlwZW9mIHRyYW5zcG9ydGVyID09PSAnc3RyaW5nJyA/IHRyYW5zcG9ydGVyIDogdHJhbnNwb3J0ZXIudXJsKSkge1xuICAgICAgICAgICAgLy8gcGFyc2UgYSBjb25maWd1cmF0aW9uIFVSTCBpbnRvIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgICAgICAgICAgb3B0aW9ucyA9IHNoYXJlZC5wYXJzZUNvbm5lY3Rpb25VcmwodXJsQ29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0cmFuc3BvcnRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnBvb2wpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydGVyID0gbmV3IFNNVFBQb29sKG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VuZG1haWwpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydGVyID0gbmV3IFNlbmRtYWlsVHJhbnNwb3J0KG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RyZWFtVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnRlciA9IG5ldyBTdHJlYW1UcmFuc3BvcnQob3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5qc29uVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnRlciA9IG5ldyBKU09OVHJhbnNwb3J0KG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuU0VTKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnRlciA9IG5ldyBTRVNUcmFuc3BvcnQob3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc3BvcnRlciA9IG5ldyBTTVRQVHJhbnNwb3J0KG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWFpbGVyID0gbmV3IE1haWxlcih0cmFuc3BvcnRlciwgb3B0aW9ucywgZGVmYXVsdHMpO1xuXG4gICAgcmV0dXJuIG1haWxlcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNyZWF0ZVRlc3RBY2NvdW50ID0gZnVuY3Rpb24gKGFwaVVybCwgY2FsbGJhY2spIHtcbiAgICBsZXQgcHJvbWlzZTtcblxuICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIGFwaVVybCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGFwaVVybDtcbiAgICAgICAgYXBpVXJsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBzaGFyZWQuY2FsbGJhY2tQcm9taXNlKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChFVEhFUkVBTF9DQUNIRSAmJiB0ZXN0QWNjb3VudCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwgdGVzdEFjY291bnQpKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgYXBpVXJsID0gYXBpVXJsIHx8IEVUSEVSRUFMX0FQSTtcblxuICAgIGxldCBjaHVua3MgPSBbXTtcbiAgICBsZXQgY2h1bmtsZW4gPSAwO1xuXG4gICAgbGV0IHJlcSA9IG5tZmV0Y2goYXBpVXJsICsgJy91c2VyJywge1xuICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogQnVmZmVyLmZyb20oXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdG9yOiBwYWNrYWdlRGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IHBhY2thZ2VEYXRhLnZlcnNpb25cbiAgICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICB9KTtcblxuICAgIHJlcS5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgd2hpbGUgKChjaHVuayA9IHJlcS5yZWFkKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICBjaHVua2xlbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlcS5vbmNlKCdlcnJvcicsIGVyciA9PiBjYWxsYmFjayhlcnIpKTtcblxuICAgIHJlcS5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIGxldCByZXMgPSBCdWZmZXIuY29uY2F0KGNodW5rcywgY2h1bmtsZW4pO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgbGV0IGVycjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHJlcy50b1N0cmluZygpKTtcbiAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgZXJyID0gRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zdGF0dXMgIT09ICdzdWNjZXNzJyB8fCBkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgJ1JlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBkYXRhLnN0YXR1cztcbiAgICAgICAgdGVzdEFjY291bnQgPSBkYXRhO1xuICAgICAgICBjYWxsYmFjayhudWxsLCB0ZXN0QWNjb3VudCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldFRlc3RNZXNzYWdlVXJsID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICBpZiAoIWluZm8gfHwgIWluZm8ucmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBpbmZvUHJvcHMgPSBuZXcgTWFwKCk7XG4gICAgaW5mby5yZXNwb25zZS5yZXBsYWNlKC9cXFsoW15cXF1dKylcXF0kLywgKG0sIHByb3BzKSA9PiB7XG4gICAgICAgIHByb3BzLnJlcGxhY2UoL1xcYihbQS1aMC05XSspPShbXlxcc10rKS9nLCAobSwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaW5mb1Byb3BzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5mb1Byb3BzLmhhcygnU1RBVFVTJykgJiYgaW5mb1Byb3BzLmhhcygnTVNHSUQnKSkge1xuICAgICAgICByZXR1cm4gKHRlc3RBY2NvdW50LndlYiB8fCBFVEhFUkVBTF9XRUIpICsgJy9tZXNzYWdlLycgKyBpbmZvUHJvcHMuZ2V0KCdNU0dJRCcpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/nodemailer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/punycode/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/nodemailer/lib/punycode/index.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/*\n\nCopied from https://github.com/mathiasbynens/punycode.js/blob/ef3505c8abb5143a00d53ce59077c9f7f4b2ac47/punycode.js\n\nCopyright Mathias Bynens <https://mathiasbynens.be/>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n/* eslint callback-return: 0, no-bitwise: 0, eqeqeq: 0, prefer-arrow-callback: 0, object-shorthand: 0 */\n\n\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7F]/; // Note: U+007F DEL is excluded too.\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n    overflow: 'Overflow: input needs wider integers to process',\n    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n    'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n    throw new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, callback) {\n    const result = [];\n    let length = array.length;\n    while (length--) {\n        result[length] = callback(array[length]);\n    }\n    return result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {String} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(domain, callback) {\n    const parts = domain.split('@');\n    let result = '';\n    if (parts.length > 1) {\n        // In email addresses, only the domain name should be punycoded. Leave\n        // the local part (i.e. everything up to `@`) intact.\n        result = parts[0] + '@';\n        domain = parts[1];\n    }\n    // Avoid `split(regex)` for IE8 compatibility. See #17.\n    domain = domain.replace(regexSeparators, '\\x2E');\n    const labels = domain.split('.');\n    const encoded = map(labels, callback).join('.');\n    return result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n    const output = [];\n    let counter = 0;\n    const length = string.length;\n    while (counter < length) {\n        const value = string.charCodeAt(counter++);\n        if (value >= 0xd800 && value <= 0xdbff && counter < length) {\n            // It's a high surrogate, and there is a next character.\n            const extra = string.charCodeAt(counter++);\n            if ((extra & 0xfc00) == 0xdc00) {\n                // Low surrogate.\n                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n            } else {\n                // It's an unmatched surrogate; only append this code unit, in case the\n                // next code unit is the high surrogate of a surrogate pair.\n                output.push(value);\n                counter--;\n            }\n        } else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = codePoints => String.fromCodePoint(...codePoints);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function (codePoint) {\n    if (codePoint >= 0x30 && codePoint < 0x3a) {\n        return 26 + (codePoint - 0x30);\n    }\n    if (codePoint >= 0x41 && codePoint < 0x5b) {\n        return codePoint - 0x41;\n    }\n    if (codePoint >= 0x61 && codePoint < 0x7b) {\n        return codePoint - 0x61;\n    }\n    return base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function (digit, flag) {\n    //  0..25 map to ASCII a..z or A..Z\n    // 26..35 map to ASCII 0..9\n    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function (delta, numPoints, firstTime) {\n    let k = 0;\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\n    delta += floor(delta / numPoints);\n    for (; /* no initialization */ delta > (baseMinusTMin * tMax) >> 1; k += base) {\n        delta = floor(delta / baseMinusTMin);\n    }\n    return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function (input) {\n    // Don't use UCS-2.\n    const output = [];\n    const inputLength = input.length;\n    let i = 0;\n    let n = initialN;\n    let bias = initialBias;\n\n    // Handle the basic code points: let `basic` be the number of input code\n    // points before the last delimiter, or `0` if there is none, then copy\n    // the first basic code points to the output.\n\n    let basic = input.lastIndexOf(delimiter);\n    if (basic < 0) {\n        basic = 0;\n    }\n\n    for (let j = 0; j < basic; ++j) {\n        // if it's not a basic code point\n        if (input.charCodeAt(j) >= 0x80) {\n            error('not-basic');\n        }\n        output.push(input.charCodeAt(j));\n    }\n\n    // Main decoding loop: start just after the last delimiter if any basic code\n    // points were copied; start at the beginning otherwise.\n\n    for (let index = basic > 0 ? basic + 1 : 0; index < inputLength /* no final expression */; ) {\n        // `index` is the index of the next character to be consumed.\n        // Decode a generalized variable-length integer into `delta`,\n        // which gets added to `i`. The overflow checking is easier\n        // if we increase `i` as we go, then subtract off its starting\n        // value at the end to obtain `delta`.\n        const oldi = i;\n        for (let w = 1, k = base /* no condition */; ; k += base) {\n            if (index >= inputLength) {\n                error('invalid-input');\n            }\n\n            const digit = basicToDigit(input.charCodeAt(index++));\n\n            if (digit >= base) {\n                error('invalid-input');\n            }\n            if (digit > floor((maxInt - i) / w)) {\n                error('overflow');\n            }\n\n            i += digit * w;\n            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n            if (digit < t) {\n                break;\n            }\n\n            const baseMinusT = base - t;\n            if (w > floor(maxInt / baseMinusT)) {\n                error('overflow');\n            }\n\n            w *= baseMinusT;\n        }\n\n        const out = output.length + 1;\n        bias = adapt(i - oldi, out, oldi == 0);\n\n        // `i` was supposed to wrap around from `out` to `0`,\n        // incrementing `n` each time, so we'll fix that now:\n        if (floor(i / out) > maxInt - n) {\n            error('overflow');\n        }\n\n        n += floor(i / out);\n        i %= out;\n\n        // Insert `n` at position `i` of the output.\n        output.splice(i++, 0, n);\n    }\n\n    return String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function (input) {\n    const output = [];\n\n    // Convert the input in UCS-2 to an array of Unicode code points.\n    input = ucs2decode(input);\n\n    // Cache the length.\n    const inputLength = input.length;\n\n    // Initialize the state.\n    let n = initialN;\n    let delta = 0;\n    let bias = initialBias;\n\n    // Handle the basic code points.\n    for (const currentValue of input) {\n        if (currentValue < 0x80) {\n            output.push(stringFromCharCode(currentValue));\n        }\n    }\n\n    const basicLength = output.length;\n    let handledCPCount = basicLength;\n\n    // `handledCPCount` is the number of code points that have been handled;\n    // `basicLength` is the number of basic code points.\n\n    // Finish the basic string with a delimiter unless it's empty.\n    if (basicLength) {\n        output.push(delimiter);\n    }\n\n    // Main encoding loop:\n    while (handledCPCount < inputLength) {\n        // All non-basic code points < n have been handled already. Find the next\n        // larger one:\n        let m = maxInt;\n        for (const currentValue of input) {\n            if (currentValue >= n && currentValue < m) {\n                m = currentValue;\n            }\n        }\n\n        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n        // but guard against overflow.\n        const handledCPCountPlusOne = handledCPCount + 1;\n        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n            error('overflow');\n        }\n\n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n\n        for (const currentValue of input) {\n            if (currentValue < n && ++delta > maxInt) {\n                error('overflow');\n            }\n            if (currentValue === n) {\n                // Represent delta as a generalized variable-length integer.\n                let q = delta;\n                for (let k = base /* no condition */; ; k += base) {\n                    const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                    if (q < t) {\n                        break;\n                    }\n                    const qMinusT = q - t;\n                    const baseMinusT = base - t;\n                    output.push(stringFromCharCode(digitToBasic(t + (qMinusT % baseMinusT), 0)));\n                    q = floor(qMinusT / baseMinusT);\n                }\n\n                output.push(stringFromCharCode(digitToBasic(q, 0)));\n                bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n                delta = 0;\n                ++handledCPCount;\n            }\n        }\n\n        ++delta;\n        ++n;\n    }\n    return output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function (input) {\n    return mapDomain(input, function (string) {\n        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n    });\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function (input) {\n    return mapDomain(input, function (string) {\n        return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n    });\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n    /**\n     * A string representing the current Punycode.js version number.\n     * @memberOf punycode\n     * @type String\n     */\n    version: '2.3.1',\n    /**\n     * An object of methods to convert from JavaScript's internal character\n     * representation (UCS-2) to Unicode code points, and back.\n     * @see <https://mathiasbynens.be/notes/javascript-encoding>\n     * @memberOf punycode\n     * @type Object\n     */\n    ucs2: {\n        decode: ucs2decode,\n        encode: ucs2encode\n    },\n    decode: decode,\n    encode: encode,\n    toASCII: toASCII,\n    toUnicode: toUnicode\n};\n\nmodule.exports = punycode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvcHVueWNvZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVhOztBQUViO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQTZEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCLGdEQUFnRCwrQ0FBK0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlbWFya2V0Ly4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL3B1bnljb2RlL2luZGV4LmpzPzgwODUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblxuQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvcHVueWNvZGUuanMvYmxvYi9lZjM1MDVjOGFiYjUxNDNhMDBkNTNjZTU5MDc3YzlmN2Y0YjJhYzQ3L3B1bnljb2RlLmpzXG5cbkNvcHlyaWdodCBNYXRoaWFzIEJ5bmVucyA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlLz5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG5XSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cbi8qIGVzbGludCBjYWxsYmFjay1yZXR1cm46IDAsIG5vLWJpdHdpc2U6IDAsIGVxZXFlcTogMCwgcHJlZmVyLWFycm93LWNhbGxiYWNrOiAwLCBvYmplY3Qtc2hvcnRoYW5kOiAwICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuY29uc3QgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG4vKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5jb25zdCBiYXNlID0gMzY7XG5jb25zdCB0TWluID0gMTtcbmNvbnN0IHRNYXggPSAyNjtcbmNvbnN0IHNrZXcgPSAzODtcbmNvbnN0IGRhbXAgPSA3MDA7XG5jb25zdCBpbml0aWFsQmlhcyA9IDcyO1xuY29uc3QgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbmNvbnN0IGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuY29uc3QgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS87XG5jb25zdCByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxceDdGXS87IC8vIE5vdGU6IFUrMDA3RiBERUwgaXMgZXhjbHVkZWQgdG9vLlxuY29uc3QgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbmNvbnN0IGVycm9ycyA9IHtcbiAgICBvdmVyZmxvdzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcbiAgICAnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuICAgICdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5jb25zdCBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gY2FsbGJhY2soYXJyYXlbbGVuZ3RoXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG4gKiBhZGRyZXNzZXMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuICogY2hhcmFjdGVyLlxuICogQHJldHVybnMge1N0cmluZ30gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwRG9tYWluKGRvbWFpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBwYXJ0cyA9IGRvbWFpbi5zcGxpdCgnQCcpO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG4gICAgICAgIC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG4gICAgICAgIHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuICAgICAgICBkb21haW4gPSBwYXJ0c1sxXTtcbiAgICB9XG4gICAgLy8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuICAgIGRvbWFpbiA9IGRvbWFpbi5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG4gICAgY29uc3QgbGFiZWxzID0gZG9tYWluLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGNhbGxiYWNrKS5qb2luKCcuJyk7XG4gICAgcmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgd2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICBpZiAodmFsdWUgPj0gMHhkODAwICYmIHZhbHVlIDw9IDB4ZGJmZiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgY29uc3QgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICAgICAgaWYgKChleHRyYSAmIDB4ZmMwMCkgPT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTG93IHN1cnJvZ2F0ZS5cbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzZmYpIDw8IDEwKSArIChleHRyYSAmIDB4M2ZmKSArIDB4MTAwMDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb3VudGVyLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBlbmNvZGVcbiAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG4gKi9cbmNvbnN0IHVjczJlbmNvZGUgPSBjb2RlUG9pbnRzID0+IFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cbiAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG4gKi9cbmNvbnN0IGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uIChjb2RlUG9pbnQpIHtcbiAgICBpZiAoY29kZVBvaW50ID49IDB4MzAgJiYgY29kZVBvaW50IDwgMHgzYSkge1xuICAgICAgICByZXR1cm4gMjYgKyAoY29kZVBvaW50IC0gMHgzMCk7XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgPj0gMHg0MSAmJiBjb2RlUG9pbnQgPCAweDViKSB7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSAweDQxO1xuICAgIH1cbiAgICBpZiAoY29kZVBvaW50ID49IDB4NjEgJiYgY29kZVBvaW50IDwgMHg3Yikge1xuICAgICAgICByZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gKi9cbmNvbnN0IGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIChkaWdpdCwgZmxhZykge1xuICAgIC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG4gICAgLy8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG4gICAgcmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcbn07XG5cbi8qKlxuICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBhZGFwdCA9IGZ1bmN0aW9uIChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcbiAgICBsZXQgayA9IDA7XG4gICAgZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcbiAgICBkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG4gICAgZm9yICg7IC8qIG5vIGluaXRpYWxpemF0aW9uICovIGRlbHRhID4gKGJhc2VNaW51c1RNaW4gKiB0TWF4KSA+PiAxOyBrICs9IGJhc2UpIHtcbiAgICAgICAgZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuICAgIH1cbiAgICByZXR1cm4gZmxvb3IoayArICgoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEpIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAvLyBEb24ndCB1c2UgVUNTLTIuXG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBuID0gaW5pdGlhbE47XG4gICAgbGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuICAgIC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuICAgIC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG4gICAgLy8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cbiAgICBsZXQgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuICAgIGlmIChiYXNpYyA8IDApIHtcbiAgICAgICAgYmFzaWMgPSAwO1xuICAgIH1cblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuICAgICAgICAvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuICAgICAgICAgICAgZXJyb3IoJ25vdC1iYXNpYycpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuICAgIH1cblxuICAgIC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcbiAgICAvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG4gICAgZm9yIChsZXQgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoIC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi87ICkge1xuICAgICAgICAvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG4gICAgICAgIC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcbiAgICAgICAgLy8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcbiAgICAgICAgLy8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcbiAgICAgICAgLy8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cbiAgICAgICAgY29uc3Qgb2xkaSA9IGk7XG4gICAgICAgIGZvciAobGV0IHcgPSAxLCBrID0gYmFzZSAvKiBubyBjb25kaXRpb24gKi87IDsgayArPSBiYXNlKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuICAgICAgICAgICAgaWYgKGRpZ2l0ID49IGJhc2UpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaSArPSBkaWdpdCAqIHc7XG4gICAgICAgICAgICBjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG5cbiAgICAgICAgICAgIGlmIChkaWdpdCA8IHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuICAgICAgICAgICAgaWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3ICo9IGJhc2VNaW51c1Q7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcbiAgICAgICAgYmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cbiAgICAgICAgLy8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcbiAgICAgICAgLy8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcbiAgICAgICAgaWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuICAgICAgICAgICAgZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBuICs9IGZsb29yKGkgLyBvdXQpO1xuICAgICAgICBpICU9IG91dDtcblxuICAgICAgICAvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0LlxuICAgICAgICBvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLm91dHB1dCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKi9cbmNvbnN0IGVuY29kZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuXG4gICAgLy8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cbiAgICBpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG4gICAgLy8gQ2FjaGUgdGhlIGxlbmd0aC5cbiAgICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIHN0YXRlLlxuICAgIGxldCBuID0gaW5pdGlhbE47XG4gICAgbGV0IGRlbHRhID0gMDtcbiAgICBsZXQgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG4gICAgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cbiAgICBmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuICAgIGxldCBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuXG4gICAgLy8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG4gICAgLy8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG4gICAgLy8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgd2l0aCBhIGRlbGltaXRlciB1bmxlc3MgaXQncyBlbXB0eS5cbiAgICBpZiAoYmFzaWNMZW5ndGgpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcbiAgICB9XG5cbiAgICAvLyBNYWluIGVuY29kaW5nIGxvb3A6XG4gICAgd2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgLy8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuICAgICAgICAvLyBsYXJnZXIgb25lOlxuICAgICAgICBsZXQgbSA9IG1heEludDtcbiAgICAgICAgZm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG4gICAgICAgICAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcbiAgICAgICAgLy8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cuXG4gICAgICAgIGNvbnN0IGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcbiAgICAgICAgaWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcbiAgICAgICAgICAgIGVycm9yKCdvdmVyZmxvdycpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcbiAgICAgICAgbiA9IG07XG5cbiAgICAgICAgZm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09IG4pIHtcbiAgICAgICAgICAgICAgICAvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cbiAgICAgICAgICAgICAgICBsZXQgcSA9IGRlbHRhO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSBiYXNlIC8qIG5vIGNvbmRpdGlvbiAqLzsgOyBrICs9IGJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuICAgICAgICAgICAgICAgICAgICBpZiAocSA8IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHFNaW51c1QgPSBxIC0gdDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyAocU1pbnVzVCAlIGJhc2VNaW51c1QpLCAwKSkpO1xuICAgICAgICAgICAgICAgICAgICBxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcbiAgICAgICAgICAgICAgICBiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT09IGJhc2ljTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBkZWx0YSA9IDA7XG4gICAgICAgICAgICAgICAgKytoYW5kbGVkQ1BDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICsrZGVsdGE7XG4gICAgICAgICsrbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICogY29udmVydCB0byBVbmljb2RlLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gKiBzdHJpbmcuXG4gKi9cbmNvbnN0IHRvVW5pY29kZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpID8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKSA6IHN0cmluZztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG4gKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcbiAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuICogQVNDSUkuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG4gKiBVbmljb2RlIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3JcbiAqIGVtYWlsIGFkZHJlc3MuXG4gKi9cbmNvbnN0IHRvQVNDSUkgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKSA/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpIDogc3RyaW5nO1xuICAgIH0pO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cbmNvbnN0IHB1bnljb2RlID0ge1xuICAgIC8qKlxuICAgICAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB2ZXJzaW9uOiAnMi4zLjEnLFxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG4gICAgICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cbiAgICAgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB1Y3MyOiB7XG4gICAgICAgIGRlY29kZTogdWNzMmRlY29kZSxcbiAgICAgICAgZW5jb2RlOiB1Y3MyZW5jb2RlXG4gICAgfSxcbiAgICBkZWNvZGU6IGRlY29kZSxcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICB0b0FTQ0lJOiB0b0FTQ0lJLFxuICAgIHRvVW5pY29kZTogdG9Vbmljb2RlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/punycode/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/qp/index.js":
/*!*************************************************!*\
  !*** ./node_modules/nodemailer/lib/qp/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\n\n/**\n * Encodes a Buffer into a Quoted-Printable encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} Quoted-Printable encoded string\n */\nfunction encode(buffer) {\n    if (typeof buffer === 'string') {\n        buffer = Buffer.from(buffer, 'utf-8');\n    }\n\n    // usable characters that do not need encoding\n    let ranges = [\n        // https://tools.ietf.org/html/rfc2045#section-6.7\n        [0x09], // <TAB>\n        [0x0a], // <LF>\n        [0x0d], // <CR>\n        [0x20, 0x3c], // <SP>!\"#$%&'()*+,-./0123456789:;\n        [0x3e, 0x7e] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n    ];\n    let result = '';\n    let ord;\n\n    for (let i = 0, len = buffer.length; i < len; i++) {\n        ord = buffer[i];\n        // if the char is in allowed range, then keep as is, unless it is a WS in the end of a line\n        if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {\n            result += String.fromCharCode(ord);\n            continue;\n        }\n        result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n    }\n\n    return result;\n}\n\n/**\n * Adds soft line breaks to a Quoted-Printable string\n *\n * @param {String} str Quoted-Printable encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped Quoted-Printable encoded string\n */\nfunction wrap(str, lineLength) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n\n    if (str.length <= lineLength) {\n        return str;\n    }\n\n    let pos = 0;\n    let len = str.length;\n    let match, code, line;\n    let lineMargin = Math.floor(lineLength / 3);\n    let result = '';\n\n    // insert soft linebreaks where needed\n    while (pos < len) {\n        line = str.substr(pos, lineLength);\n        if ((match = line.match(/\\r\\n/))) {\n            line = line.substr(0, match.index + match[0].length);\n            result += line;\n            pos += line.length;\n            continue;\n        }\n\n        if (line.substr(-1) === '\\n') {\n            // nothing to change here\n            result += line;\n            pos += line.length;\n            continue;\n        } else if ((match = line.substr(-lineMargin).match(/\\n.*?$/))) {\n            // truncate to nearest line break\n            line = line.substr(0, line.length - (match[0].length - 1));\n            result += line;\n            pos += line.length;\n            continue;\n        } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t.,!?][^ \\t.,!?]*$/))) {\n            // truncate to nearest space\n            line = line.substr(0, line.length - (match[0].length - 1));\n        } else if (line.match(/[=][\\da-f]{0,2}$/i)) {\n            // push incomplete encoding sequences to the next line\n            if ((match = line.match(/[=][\\da-f]{0,1}$/i))) {\n                line = line.substr(0, line.length - match[0].length);\n            }\n\n            // ensure that utf-8 sequences are not split\n            while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/[=][\\da-f]{2}$/gi))) {\n                code = parseInt(match[0].substr(1, 2), 16);\n                if (code < 128) {\n                    break;\n                }\n\n                line = line.substr(0, line.length - 3);\n\n                if (code >= 0xc0) {\n                    break;\n                }\n            }\n        }\n\n        if (pos + line.length < len && line.substr(-1) !== '\\n') {\n            if (line.length === lineLength && line.match(/[=][\\da-f]{2}$/i)) {\n                line = line.substr(0, line.length - 3);\n            } else if (line.length === lineLength) {\n                line = line.substr(0, line.length - 1);\n            }\n            pos += line.length;\n            line += '=\\r\\n';\n        } else {\n            pos += line.length;\n        }\n\n        result += line;\n    }\n\n    return result;\n}\n\n/**\n * Helper function to check if a number is inside provided ranges\n *\n * @param {Number} nr Number to check for\n * @param {Array} ranges An Array of allowed values\n * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise\n */\nfunction checkRanges(nr, ranges) {\n    for (let i = ranges.length - 1; i >= 0; i--) {\n        if (!ranges[i].length) {\n            continue;\n        }\n        if (ranges[i].length === 1 && nr === ranges[i][0]) {\n            return true;\n        }\n        if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Creates a transform stream for encoding data to Quoted-Printable encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping\n */\nclass Encoder extends Transform {\n    constructor(options) {\n        super();\n\n        // init Transform\n        this.options = options || {};\n\n        if (this.options.lineLength !== false) {\n            this.options.lineLength = this.options.lineLength || 76;\n        }\n\n        this._curLine = '';\n\n        this.inputBytes = 0;\n        this.outputBytes = 0;\n    }\n\n    _transform(chunk, encoding, done) {\n        let qp;\n\n        if (encoding !== 'buffer') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n\n        this.inputBytes += chunk.length;\n\n        if (this.options.lineLength) {\n            qp = this._curLine + encode(chunk);\n            qp = wrap(qp, this.options.lineLength);\n            qp = qp.replace(/(^|\\n)([^\\n]*)$/, (match, lineBreak, lastLine) => {\n                this._curLine = lastLine;\n                return lineBreak;\n            });\n\n            if (qp) {\n                this.outputBytes += qp.length;\n                this.push(qp);\n            }\n        } else {\n            qp = encode(chunk);\n            this.outputBytes += qp.length;\n            this.push(qp, 'ascii');\n        }\n\n        done();\n    }\n\n    _flush(done) {\n        if (this._curLine) {\n            this.outputBytes += this._curLine.length;\n            this.push(this._curLine, 'ascii');\n        }\n        done();\n    }\n}\n\n// expose to the world\nmodule.exports = {\n    encode,\n    wrap,\n    Encoder\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvcXAvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLHVEQUEyQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVSxnQ0FBZ0MsSUFBSTtBQUM5QztBQUNBLGdEQUFnRCxJQUFJO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQSwyRkFBMkYsRUFBRSxFQUFFLElBQUksd0NBQXdDLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRSxFQUFFO0FBQ3ZFO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VtYXJrZXQvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvcXAvaW5kZXguanM/OTc0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgQnVmZmVyIGludG8gYSBRdW90ZWQtUHJpbnRhYmxlIGVuY29kZWQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gY29udmVydFxuICogQHJldHVybnMge1N0cmluZ30gUXVvdGVkLVByaW50YWJsZSBlbmNvZGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBlbmNvZGUoYnVmZmVyKSB7XG4gICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJ1ZmZlciwgJ3V0Zi04Jyk7XG4gICAgfVxuXG4gICAgLy8gdXNhYmxlIGNoYXJhY3RlcnMgdGhhdCBkbyBub3QgbmVlZCBlbmNvZGluZ1xuICAgIGxldCByYW5nZXMgPSBbXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMDQ1I3NlY3Rpb24tNi43XG4gICAgICAgIFsweDA5XSwgLy8gPFRBQj5cbiAgICAgICAgWzB4MGFdLCAvLyA8TEY+XG4gICAgICAgIFsweDBkXSwgLy8gPENSPlxuICAgICAgICBbMHgyMCwgMHgzY10sIC8vIDxTUD4hXCIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7XG4gICAgICAgIFsweDNlLCAweDdlXSAvLyA+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fVxuICAgIF07XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGxldCBvcmQ7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYnVmZmVyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9yZCA9IGJ1ZmZlcltpXTtcbiAgICAgICAgLy8gaWYgdGhlIGNoYXIgaXMgaW4gYWxsb3dlZCByYW5nZSwgdGhlbiBrZWVwIGFzIGlzLCB1bmxlc3MgaXQgaXMgYSBXUyBpbiB0aGUgZW5kIG9mIGEgbGluZVxuICAgICAgICBpZiAoY2hlY2tSYW5nZXMob3JkLCByYW5nZXMpICYmICEoKG9yZCA9PT0gMHgyMCB8fCBvcmQgPT09IDB4MDkpICYmIChpID09PSBsZW4gLSAxIHx8IGJ1ZmZlcltpICsgMV0gPT09IDB4MGEgfHwgYnVmZmVyW2kgKyAxXSA9PT0gMHgwZCkpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShvcmQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICc9JyArIChvcmQgPCAweDEwID8gJzAnIDogJycpICsgb3JkLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQWRkcyBzb2Z0IGxpbmUgYnJlYWtzIHRvIGEgUXVvdGVkLVByaW50YWJsZSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFF1b3RlZC1QcmludGFibGUgZW5jb2RlZCBzdHJpbmcgdGhhdCBtaWdodCBuZWVkIGxpbmUgd3JhcHBpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGluZUxlbmd0aD03Nl0gTWF4aW11bSBhbGxvd2VkIGxlbmd0aCBmb3IgYSBsaW5lXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBTb2Z0LXdyYXBwZWQgUXVvdGVkLVByaW50YWJsZSBlbmNvZGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiB3cmFwKHN0ciwgbGluZUxlbmd0aCkge1xuICAgIHN0ciA9IChzdHIgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgbGluZUxlbmd0aCA9IGxpbmVMZW5ndGggfHwgNzY7XG5cbiAgICBpZiAoc3RyLmxlbmd0aCA8PSBsaW5lTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgbGV0IHBvcyA9IDA7XG4gICAgbGV0IGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgbGV0IG1hdGNoLCBjb2RlLCBsaW5lO1xuICAgIGxldCBsaW5lTWFyZ2luID0gTWF0aC5mbG9vcihsaW5lTGVuZ3RoIC8gMyk7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gICAgLy8gaW5zZXJ0IHNvZnQgbGluZWJyZWFrcyB3aGVyZSBuZWVkZWRcbiAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgIGxpbmUgPSBzdHIuc3Vic3RyKHBvcywgbGluZUxlbmd0aCk7XG4gICAgICAgIGlmICgobWF0Y2ggPSBsaW5lLm1hdGNoKC9cXHJcXG4vKSkpIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICByZXN1bHQgKz0gbGluZTtcbiAgICAgICAgICAgIHBvcyArPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmUuc3Vic3RyKC0xKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gY2hhbmdlIGhlcmVcbiAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lO1xuICAgICAgICAgICAgcG9zICs9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gbGluZS5zdWJzdHIoLWxpbmVNYXJnaW4pLm1hdGNoKC9cXG4uKj8kLykpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0byBuZWFyZXN0IGxpbmUgYnJlYWtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBsaW5lLmxlbmd0aCAtIChtYXRjaFswXS5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICByZXN1bHQgKz0gbGluZTtcbiAgICAgICAgICAgIHBvcyArPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbmUubGVuZ3RoID4gbGluZUxlbmd0aCAtIGxpbmVNYXJnaW4gJiYgKG1hdGNoID0gbGluZS5zdWJzdHIoLWxpbmVNYXJnaW4pLm1hdGNoKC9bIFxcdC4sIT9dW14gXFx0LiwhP10qJC8pKSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdG8gbmVhcmVzdCBzcGFjZVxuICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gKG1hdGNoWzBdLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLm1hdGNoKC9bPV1bXFxkYS1mXXswLDJ9JC9pKSkge1xuICAgICAgICAgICAgLy8gcHVzaCBpbmNvbXBsZXRlIGVuY29kaW5nIHNlcXVlbmNlcyB0byB0aGUgbmV4dCBsaW5lXG4gICAgICAgICAgICBpZiAoKG1hdGNoID0gbGluZS5tYXRjaCgvWz1dW1xcZGEtZl17MCwxfSQvaSkpKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgdXRmLTggc2VxdWVuY2VzIGFyZSBub3Qgc3BsaXRcbiAgICAgICAgICAgIHdoaWxlIChsaW5lLmxlbmd0aCA+IDMgJiYgbGluZS5sZW5ndGggPCBsZW4gLSBwb3MgJiYgIWxpbmUubWF0Y2goL14oPzo9W1xcZGEtZl17Mn0pezEsNH0kL2kpICYmIChtYXRjaCA9IGxpbmUubWF0Y2goL1s9XVtcXGRhLWZdezJ9JC9naSkpKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IHBhcnNlSW50KG1hdGNoWzBdLnN1YnN0cigxLCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBsaW5lLmxlbmd0aCAtIDMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPj0gMHhjMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zICsgbGluZS5sZW5ndGggPCBsZW4gJiYgbGluZS5zdWJzdHIoLTEpICE9PSAnXFxuJykge1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSBsaW5lTGVuZ3RoICYmIGxpbmUubWF0Y2goL1s9XVtcXGRhLWZdezJ9JC9pKSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBsaW5lLmxlbmd0aCAtIDMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lLmxlbmd0aCA9PT0gbGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBsaW5lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgbGluZSArPSAnPVxcclxcbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gbGluZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBhIG51bWJlciBpcyBpbnNpZGUgcHJvdmlkZWQgcmFuZ2VzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5yIE51bWJlciB0byBjaGVjayBmb3JcbiAqIEBwYXJhbSB7QXJyYXl9IHJhbmdlcyBBbiBBcnJheSBvZiBhbGxvd2VkIHZhbHVlc1xuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIHdhcyBmb3VuZCBpbnNpZGUgYWxsb3dlZCByYW5nZXMsIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBjaGVja1JhbmdlcyhuciwgcmFuZ2VzKSB7XG4gICAgZm9yIChsZXQgaSA9IHJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoIXJhbmdlc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZXNbaV0ubGVuZ3RoID09PSAxICYmIG5yID09PSByYW5nZXNbaV1bMF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZXNbaV0ubGVuZ3RoID09PSAyICYmIG5yID49IHJhbmdlc1tpXVswXSAmJiBuciA8PSByYW5nZXNbaV1bMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIHN0cmVhbSBmb3IgZW5jb2RpbmcgZGF0YSB0byBRdW90ZWQtUHJpbnRhYmxlIGVuY29kaW5nXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBTdHJlYW0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxpbmVMZW5ndGg9NzZdIE1heGltdW0gbGVuZ3RoIGZvciBsaW5lcywgc2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgd3JhcHBpbmdcbiAqL1xuY2xhc3MgRW5jb2RlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIGluaXQgVHJhbnNmb3JtXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5lTGVuZ3RoICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxpbmVMZW5ndGggPSB0aGlzLm9wdGlvbnMubGluZUxlbmd0aCB8fCA3NjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N1ckxpbmUgPSAnJztcblxuICAgICAgICB0aGlzLmlucHV0Qnl0ZXMgPSAwO1xuICAgICAgICB0aGlzLm91dHB1dEJ5dGVzID0gMDtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgICBsZXQgcXA7XG5cbiAgICAgICAgaWYgKGVuY29kaW5nICE9PSAnYnVmZmVyJykge1xuICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnB1dEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxpbmVMZW5ndGgpIHtcbiAgICAgICAgICAgIHFwID0gdGhpcy5fY3VyTGluZSArIGVuY29kZShjaHVuayk7XG4gICAgICAgICAgICBxcCA9IHdyYXAocXAsIHRoaXMub3B0aW9ucy5saW5lTGVuZ3RoKTtcbiAgICAgICAgICAgIHFwID0gcXAucmVwbGFjZSgvKF58XFxuKShbXlxcbl0qKSQvLCAobWF0Y2gsIGxpbmVCcmVhaywgbGFzdExpbmUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJMaW5lID0gbGFzdExpbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVCcmVhaztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEJ5dGVzICs9IHFwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2gocXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXAgPSBlbmNvZGUoY2h1bmspO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRCeXRlcyArPSBxcC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnB1c2gocXAsICdhc2NpaScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9uZSgpO1xuICAgIH1cblxuICAgIF9mbHVzaChkb25lKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEJ5dGVzICs9IHRoaXMuX2N1ckxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuX2N1ckxpbmUsICdhc2NpaScpO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUoKTtcbiAgICB9XG59XG5cbi8vIGV4cG9zZSB0byB0aGUgd29ybGRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVuY29kZSxcbiAgICB3cmFwLFxuICAgIEVuY29kZXJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/qp/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/sendmail-transport/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/nodemailer/lib/sendmail-transport/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst spawn = (__webpack_require__(/*! child_process */ \"child_process\").spawn);\nconst packageData = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/nodemailer/package.json\");\nconst shared = __webpack_require__(/*! ../shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\");\n\n/**\n * Generates a Transport object for Sendmail\n *\n * Possible options can be the following:\n *\n *  * **path** optional path to sendmail binary\n *  * **newline** either 'windows' or 'unix'\n *  * **args** an array of arguments for the sendmail binary\n *\n * @constructor\n * @param {Object} optional config parameter for Sendmail\n */\nclass SendmailTransport {\n    constructor(options) {\n        options = options || {};\n\n        // use a reference to spawn for mocking purposes\n        this._spawn = spawn;\n\n        this.options = options || {};\n\n        this.name = 'Sendmail';\n        this.version = packageData.version;\n\n        this.path = 'sendmail';\n        this.args = false;\n        this.winbreak = false;\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'sendmail'\n        });\n\n        if (options) {\n            if (typeof options === 'string') {\n                this.path = options;\n            } else if (typeof options === 'object') {\n                if (options.path) {\n                    this.path = options.path;\n                }\n                if (Array.isArray(options.args)) {\n                    this.args = options.args;\n                }\n                this.winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes((options.newline || '').toString().toLowerCase());\n            }\n        }\n    }\n\n    /**\n     * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>\n     *\n     * @param {Object} emailMessage MailComposer object\n     * @param {Function} callback Callback function to run when the sending is completed\n     */\n    send(mail, done) {\n        // Sendmail strips this header line by itself\n        mail.message.keepBcc = true;\n\n        let envelope = mail.data.envelope || mail.message.getEnvelope();\n        let messageId = mail.message.messageId();\n        let args;\n        let sendmail;\n        let returned;\n\n        const hasInvalidAddresses = []\n            .concat(envelope.from || [])\n            .concat(envelope.to || [])\n            .some(addr => /^-/.test(addr));\n        if (hasInvalidAddresses) {\n            return done(new Error('Can not send mail. Invalid envelope addresses.'));\n        }\n\n        if (this.args) {\n            // force -i to keep single dots\n            args = ['-i'].concat(this.args).concat(envelope.to);\n        } else {\n            args = ['-i'].concat(envelope.from ? ['-f', envelope.from] : []).concat(envelope.to);\n        }\n\n        let callback = err => {\n            if (returned) {\n                // ignore any additional responses, already done\n                return;\n            }\n            returned = true;\n            if (typeof done === 'function') {\n                if (err) {\n                    return done(err);\n                } else {\n                    return done(null, {\n                        envelope: mail.data.envelope || mail.message.getEnvelope(),\n                        messageId,\n                        response: 'Messages queued for delivery'\n                    });\n                }\n            }\n        };\n\n        try {\n            sendmail = this._spawn(this.path, args);\n        } catch (E) {\n            this.logger.error(\n                {\n                    err: E,\n                    tnx: 'spawn',\n                    messageId\n                },\n                'Error occurred while spawning sendmail. %s',\n                E.message\n            );\n            return callback(E);\n        }\n\n        if (sendmail) {\n            sendmail.on('error', err => {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'spawn',\n                        messageId\n                    },\n                    'Error occurred when sending message %s. %s',\n                    messageId,\n                    err.message\n                );\n                callback(err);\n            });\n\n            sendmail.once('exit', code => {\n                if (!code) {\n                    return callback();\n                }\n                let err;\n                if (code === 127) {\n                    err = new Error('Sendmail command not found, process exited with code ' + code);\n                } else {\n                    err = new Error('Sendmail exited with code ' + code);\n                }\n\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'stdin',\n                        messageId\n                    },\n                    'Error sending message %s to sendmail. %s',\n                    messageId,\n                    err.message\n                );\n                callback(err);\n            });\n            sendmail.once('close', callback);\n\n            sendmail.stdin.on('error', err => {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'stdin',\n                        messageId\n                    },\n                    'Error occurred when piping message %s to sendmail. %s',\n                    messageId,\n                    err.message\n                );\n                callback(err);\n            });\n\n            let recipients = [].concat(envelope.to || []);\n            if (recipients.length > 3) {\n                recipients.push('...and ' + recipients.splice(2).length + ' more');\n            }\n            this.logger.info(\n                {\n                    tnx: 'send',\n                    messageId\n                },\n                'Sending message %s to <%s>',\n                messageId,\n                recipients.join(', ')\n            );\n\n            let sourceStream = mail.message.createReadStream();\n            sourceStream.once('error', err => {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'stdin',\n                        messageId\n                    },\n                    'Error occurred when generating message %s. %s',\n                    messageId,\n                    err.message\n                );\n                sendmail.kill('SIGINT'); // do not deliver the message\n                callback(err);\n            });\n\n            sourceStream.pipe(sendmail.stdin);\n        } else {\n            return callback(new Error('sendmail was not found'));\n        }\n    }\n}\n\nmodule.exports = SendmailTransport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc2VuZG1haWwtdHJhbnNwb3J0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsaUVBQThCO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLHdFQUFvQjtBQUNoRCxlQUFlLG1CQUFPLENBQUMsc0VBQVc7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlbWFya2V0Ly4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL3NlbmRtYWlsLXRyYW5zcG9ydC9pbmRleC5qcz82N2M5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc3Bhd24gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuc3Bhd247XG5jb25zdCBwYWNrYWdlRGF0YSA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpO1xuY29uc3Qgc2hhcmVkID0gcmVxdWlyZSgnLi4vc2hhcmVkJyk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgVHJhbnNwb3J0IG9iamVjdCBmb3IgU2VuZG1haWxcbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zIGNhbiBiZSB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAqICoqcGF0aCoqIG9wdGlvbmFsIHBhdGggdG8gc2VuZG1haWwgYmluYXJ5XG4gKiAgKiAqKm5ld2xpbmUqKiBlaXRoZXIgJ3dpbmRvd3MnIG9yICd1bml4J1xuICogICogKiphcmdzKiogYW4gYXJyYXkgb2YgYXJndW1lbnRzIGZvciB0aGUgc2VuZG1haWwgYmluYXJ5XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uYWwgY29uZmlnIHBhcmFtZXRlciBmb3IgU2VuZG1haWxcbiAqL1xuY2xhc3MgU2VuZG1haWxUcmFuc3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLy8gdXNlIGEgcmVmZXJlbmNlIHRvIHNwYXduIGZvciBtb2NraW5nIHB1cnBvc2VzXG4gICAgICAgIHRoaXMuX3NwYXduID0gc3Bhd247XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLm5hbWUgPSAnU2VuZG1haWwnO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBwYWNrYWdlRGF0YS52ZXJzaW9uO1xuXG4gICAgICAgIHRoaXMucGF0aCA9ICdzZW5kbWFpbCc7XG4gICAgICAgIHRoaXMuYXJncyA9IGZhbHNlO1xuICAgICAgICB0aGlzLndpbmJyZWFrID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5sb2dnZXIgPSBzaGFyZWQuZ2V0TG9nZ2VyKHRoaXMub3B0aW9ucywge1xuICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLm9wdGlvbnMuY29tcG9uZW50IHx8ICdzZW5kbWFpbCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBvcHRpb25zO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IG9wdGlvbnMucGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5hcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3MgPSBvcHRpb25zLmFyZ3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMud2luYnJlYWsgPSBbJ3dpbicsICd3aW5kb3dzJywgJ2RvcycsICdcXHJcXG4nXS5pbmNsdWRlcygob3B0aW9ucy5uZXdsaW5lIHx8ICcnKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPHA+Q29tcGlsZXMgYSBtYWlsY29tcG9zZXIgbWVzc2FnZSBhbmQgZm9yd2FyZHMgaXQgdG8gaGFuZGxlciB0aGF0IHNlbmRzIGl0LjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbWFpbE1lc3NhZ2UgTWFpbENvbXBvc2VyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSBzZW5kaW5nIGlzIGNvbXBsZXRlZFxuICAgICAqL1xuICAgIHNlbmQobWFpbCwgZG9uZSkge1xuICAgICAgICAvLyBTZW5kbWFpbCBzdHJpcHMgdGhpcyBoZWFkZXIgbGluZSBieSBpdHNlbGZcbiAgICAgICAgbWFpbC5tZXNzYWdlLmtlZXBCY2MgPSB0cnVlO1xuXG4gICAgICAgIGxldCBlbnZlbG9wZSA9IG1haWwuZGF0YS5lbnZlbG9wZSB8fCBtYWlsLm1lc3NhZ2UuZ2V0RW52ZWxvcGUoKTtcbiAgICAgICAgbGV0IG1lc3NhZ2VJZCA9IG1haWwubWVzc2FnZS5tZXNzYWdlSWQoKTtcbiAgICAgICAgbGV0IGFyZ3M7XG4gICAgICAgIGxldCBzZW5kbWFpbDtcbiAgICAgICAgbGV0IHJldHVybmVkO1xuXG4gICAgICAgIGNvbnN0IGhhc0ludmFsaWRBZGRyZXNzZXMgPSBbXVxuICAgICAgICAgICAgLmNvbmNhdChlbnZlbG9wZS5mcm9tIHx8IFtdKVxuICAgICAgICAgICAgLmNvbmNhdChlbnZlbG9wZS50byB8fCBbXSlcbiAgICAgICAgICAgIC5zb21lKGFkZHIgPT4gL14tLy50ZXN0KGFkZHIpKTtcbiAgICAgICAgaWYgKGhhc0ludmFsaWRBZGRyZXNzZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignQ2FuIG5vdCBzZW5kIG1haWwuIEludmFsaWQgZW52ZWxvcGUgYWRkcmVzc2VzLicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgICAgICAgIC8vIGZvcmNlIC1pIHRvIGtlZXAgc2luZ2xlIGRvdHNcbiAgICAgICAgICAgIGFyZ3MgPSBbJy1pJ10uY29uY2F0KHRoaXMuYXJncykuY29uY2F0KGVudmVsb3BlLnRvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZ3MgPSBbJy1pJ10uY29uY2F0KGVudmVsb3BlLmZyb20gPyBbJy1mJywgZW52ZWxvcGUuZnJvbV0gOiBbXSkuY29uY2F0KGVudmVsb3BlLnRvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjYWxsYmFjayA9IGVyciA9PiB7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgYW55IGFkZGl0aW9uYWwgcmVzcG9uc2VzLCBhbHJlYWR5IGRvbmVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUobnVsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW52ZWxvcGU6IG1haWwuZGF0YS5lbnZlbG9wZSB8fCBtYWlsLm1lc3NhZ2UuZ2V0RW52ZWxvcGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiAnTWVzc2FnZXMgcXVldWVkIGZvciBkZWxpdmVyeSdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZW5kbWFpbCA9IHRoaXMuX3NwYXduKHRoaXMucGF0aCwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyOiBFLFxuICAgICAgICAgICAgICAgICAgICB0bng6ICdzcGF3bicsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ0Vycm9yIG9jY3VycmVkIHdoaWxlIHNwYXduaW5nIHNlbmRtYWlsLiAlcycsXG4gICAgICAgICAgICAgICAgRS5tZXNzYWdlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbmRtYWlsKSB7XG4gICAgICAgICAgICBzZW5kbWFpbC5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0bng6ICdzcGF3bicsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ0Vycm9yIG9jY3VycmVkIHdoZW4gc2VuZGluZyBtZXNzYWdlICVzLiAlcycsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2VuZG1haWwub25jZSgnZXhpdCcsIGNvZGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGVycjtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gMTI3KSB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcignU2VuZG1haWwgY29tbWFuZCBub3QgZm91bmQsIHByb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAnICsgY29kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKCdTZW5kbWFpbCBleGl0ZWQgd2l0aCBjb2RlICcgKyBjb2RlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG54OiAnc3RkaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdFcnJvciBzZW5kaW5nIG1lc3NhZ2UgJXMgdG8gc2VuZG1haWwuICVzJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VuZG1haWwub25jZSgnY2xvc2UnLCBjYWxsYmFjayk7XG5cbiAgICAgICAgICAgIHNlbmRtYWlsLnN0ZGluLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3N0ZGluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnRXJyb3Igb2NjdXJyZWQgd2hlbiBwaXBpbmcgbWVzc2FnZSAlcyB0byBzZW5kbWFpbC4gJXMnLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxldCByZWNpcGllbnRzID0gW10uY29uY2F0KGVudmVsb3BlLnRvIHx8IFtdKTtcbiAgICAgICAgICAgIGlmIChyZWNpcGllbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICByZWNpcGllbnRzLnB1c2goJy4uLmFuZCAnICsgcmVjaXBpZW50cy5zcGxpY2UoMikubGVuZ3RoICsgJyBtb3JlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG54OiAnc2VuZCcsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1NlbmRpbmcgbWVzc2FnZSAlcyB0byA8JXM+JyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgcmVjaXBpZW50cy5qb2luKCcsICcpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBsZXQgc291cmNlU3RyZWFtID0gbWFpbC5tZXNzYWdlLmNyZWF0ZVJlYWRTdHJlYW0oKTtcbiAgICAgICAgICAgIHNvdXJjZVN0cmVhbS5vbmNlKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3N0ZGluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnRXJyb3Igb2NjdXJyZWQgd2hlbiBnZW5lcmF0aW5nIG1lc3NhZ2UgJXMuICVzJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgc2VuZG1haWwua2lsbCgnU0lHSU5UJyk7IC8vIGRvIG5vdCBkZWxpdmVyIHRoZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzb3VyY2VTdHJlYW0ucGlwZShzZW5kbWFpbC5zdGRpbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdzZW5kbWFpbCB3YXMgbm90IGZvdW5kJykpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRtYWlsVHJhbnNwb3J0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/sendmail-transport/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/ses-transport/index.js":
/*!************************************************************!*\
  !*** ./node_modules/nodemailer/lib/ses-transport/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst packageData = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/nodemailer/package.json\");\nconst shared = __webpack_require__(/*! ../shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\");\nconst LeWindows = __webpack_require__(/*! ../mime-node/le-windows */ \"(rsc)/./node_modules/nodemailer/lib/mime-node/le-windows.js\");\n\n/**\n * Generates a Transport object for AWS SES\n *\n * Possible options can be the following:\n *\n *  * **sendingRate** optional Number specifying how many messages per second should be delivered to SES\n *  * **maxConnections** optional Number specifying max number of parallel connections to SES\n *\n * @constructor\n * @param {Object} optional config parameter\n */\nclass SESTransport extends EventEmitter {\n    constructor(options) {\n        super();\n        options = options || {};\n\n        this.options = options || {};\n        this.ses = this.options.SES;\n\n        this.name = 'SESTransport';\n        this.version = packageData.version;\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'ses-transport'\n        });\n\n        // parallel sending connections\n        this.maxConnections = Number(this.options.maxConnections) || Infinity;\n        this.connections = 0;\n\n        // max messages per second\n        this.sendingRate = Number(this.options.sendingRate) || Infinity;\n        this.sendingRateTTL = null;\n        this.rateInterval = 1000; // milliseconds\n        this.rateMessages = [];\n\n        this.pending = [];\n\n        this.idling = true;\n\n        setImmediate(() => {\n            if (this.idling) {\n                this.emit('idle');\n            }\n        });\n    }\n\n    /**\n     * Schedules a sending of a message\n     *\n     * @param {Object} emailMessage MailComposer object\n     * @param {Function} callback Callback function to run when the sending is completed\n     */\n    send(mail, callback) {\n        if (this.connections >= this.maxConnections) {\n            this.idling = false;\n            return this.pending.push({\n                mail,\n                callback\n            });\n        }\n\n        if (!this._checkSendingRate()) {\n            this.idling = false;\n            return this.pending.push({\n                mail,\n                callback\n            });\n        }\n\n        this._send(mail, (...args) => {\n            setImmediate(() => callback(...args));\n            this._sent();\n        });\n    }\n\n    _checkRatedQueue() {\n        if (this.connections >= this.maxConnections || !this._checkSendingRate()) {\n            return;\n        }\n\n        if (!this.pending.length) {\n            if (!this.idling) {\n                this.idling = true;\n                this.emit('idle');\n            }\n            return;\n        }\n\n        let next = this.pending.shift();\n        this._send(next.mail, (...args) => {\n            setImmediate(() => next.callback(...args));\n            this._sent();\n        });\n    }\n\n    _checkSendingRate() {\n        clearTimeout(this.sendingRateTTL);\n\n        let now = Date.now();\n        let oldest = false;\n        // delete older messages\n        for (let i = this.rateMessages.length - 1; i >= 0; i--) {\n            if (this.rateMessages[i].ts >= now - this.rateInterval && (!oldest || this.rateMessages[i].ts < oldest)) {\n                oldest = this.rateMessages[i].ts;\n            }\n\n            if (this.rateMessages[i].ts < now - this.rateInterval && !this.rateMessages[i].pending) {\n                this.rateMessages.splice(i, 1);\n            }\n        }\n\n        if (this.rateMessages.length < this.sendingRate) {\n            return true;\n        }\n\n        let delay = Math.max(oldest + 1001, now + 20);\n        this.sendingRateTTL = setTimeout(() => this._checkRatedQueue(), now - delay);\n\n        try {\n            this.sendingRateTTL.unref();\n        } catch (E) {\n            // Ignore. Happens on envs with non-node timer implementation\n        }\n\n        return false;\n    }\n\n    _sent() {\n        this.connections--;\n        this._checkRatedQueue();\n    }\n\n    /**\n     * Returns true if there are free slots in the queue\n     */\n    isIdle() {\n        return this.idling;\n    }\n\n    /**\n     * Compiles a mailcomposer message and forwards it to SES\n     *\n     * @param {Object} emailMessage MailComposer object\n     * @param {Function} callback Callback function to run when the sending is completed\n     */\n    _send(mail, callback) {\n        let statObject = {\n            ts: Date.now(),\n            pending: true\n        };\n        this.connections++;\n        this.rateMessages.push(statObject);\n\n        let envelope = mail.data.envelope || mail.message.getEnvelope();\n        let messageId = mail.message.messageId();\n\n        let recipients = [].concat(envelope.to || []);\n        if (recipients.length > 3) {\n            recipients.push('...and ' + recipients.splice(2).length + ' more');\n        }\n        this.logger.info(\n            {\n                tnx: 'send',\n                messageId\n            },\n            'Sending message %s to <%s>',\n            messageId,\n            recipients.join(', ')\n        );\n\n        let getRawMessage = next => {\n            // do not use Message-ID and Date in DKIM signature\n            if (!mail.data._dkim) {\n                mail.data._dkim = {};\n            }\n            if (mail.data._dkim.skipFields && typeof mail.data._dkim.skipFields === 'string') {\n                mail.data._dkim.skipFields += ':date:message-id';\n            } else {\n                mail.data._dkim.skipFields = 'date:message-id';\n            }\n\n            let sourceStream = mail.message.createReadStream();\n            let stream = sourceStream.pipe(new LeWindows());\n            let chunks = [];\n            let chunklen = 0;\n\n            stream.on('readable', () => {\n                let chunk;\n                while ((chunk = stream.read()) !== null) {\n                    chunks.push(chunk);\n                    chunklen += chunk.length;\n                }\n            });\n\n            sourceStream.once('error', err => stream.emit('error', err));\n\n            stream.once('error', err => {\n                next(err);\n            });\n\n            stream.once('end', () => next(null, Buffer.concat(chunks, chunklen)));\n        };\n\n        setImmediate(() =>\n            getRawMessage((err, raw) => {\n                if (err) {\n                    this.logger.error(\n                        {\n                            err,\n                            tnx: 'send',\n                            messageId\n                        },\n                        'Failed creating message for %s. %s',\n                        messageId,\n                        err.message\n                    );\n                    statObject.pending = false;\n                    return callback(err);\n                }\n\n                let sesMessage = {\n                    RawMessage: {\n                        // required\n                        Data: raw // required\n                    },\n                    Source: envelope.from,\n                    Destinations: envelope.to\n                };\n\n                Object.keys(mail.data.ses || {}).forEach(key => {\n                    sesMessage[key] = mail.data.ses[key];\n                });\n\n                let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};\n                let aws = this.ses.aws || {};\n\n                let getRegion = cb => {\n                    if (ses.config && typeof ses.config.region === 'function') {\n                        // promise\n                        return ses.config\n                            .region()\n                            .then(region => cb(null, region))\n                            .catch(err => cb(err));\n                    }\n                    return cb(null, (ses.config && ses.config.region) || 'us-east-1');\n                };\n\n                getRegion((err, region) => {\n                    if (err || !region) {\n                        region = 'us-east-1';\n                    }\n\n                    let sendPromise;\n                    if (typeof ses.send === 'function' && aws.SendRawEmailCommand) {\n                        // v3 API\n                        sendPromise = ses.send(new aws.SendRawEmailCommand(sesMessage));\n                    } else {\n                        // v2 API\n                        sendPromise = ses.sendRawEmail(sesMessage).promise();\n                    }\n\n                    sendPromise\n                        .then(data => {\n                            if (region === 'us-east-1') {\n                                region = 'email';\n                            }\n\n                            statObject.pending = false;\n                            callback(null, {\n                                envelope: {\n                                    from: envelope.from,\n                                    to: envelope.to\n                                },\n                                messageId: '<' + data.MessageId + (!/@/.test(data.MessageId) ? '@' + region + '.amazonses.com' : '') + '>',\n                                response: data.MessageId,\n                                raw\n                            });\n                        })\n                        .catch(err => {\n                            this.logger.error(\n                                {\n                                    err,\n                                    tnx: 'send'\n                                },\n                                'Send error for %s: %s',\n                                messageId,\n                                err.message\n                            );\n                            statObject.pending = false;\n                            callback(err);\n                        });\n                });\n            })\n        );\n    }\n\n    /**\n     * Verifies SES configuration\n     *\n     * @param {Function} callback Callback function\n     */\n    verify(callback) {\n        let promise;\n        let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};\n        let aws = this.ses.aws || {};\n\n        const sesMessage = {\n            RawMessage: {\n                // required\n                Data: 'From: invalid@invalid\\r\\nTo: invalid@invalid\\r\\n Subject: Invalid\\r\\n\\r\\nInvalid'\n            },\n            Source: 'invalid@invalid',\n            Destinations: ['invalid@invalid']\n        };\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n        const cb = err => {\n            if (err && (err.code || err.Code) !== 'InvalidParameterValue') {\n                return callback(err);\n            }\n            return callback(null, true);\n        };\n\n        if (typeof ses.send === 'function' && aws.SendRawEmailCommand) {\n            // v3 API\n            sesMessage.RawMessage.Data = Buffer.from(sesMessage.RawMessage.Data);\n            ses.send(new aws.SendRawEmailCommand(sesMessage), cb);\n        } else {\n            // v2 API\n            ses.sendRawEmail(sesMessage, cb);\n        }\n\n        return promise;\n    }\n}\n\nmodule.exports = SESTransport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc2VzLXRyYW5zcG9ydC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBb0I7QUFDaEQsZUFBZSxtQkFBTyxDQUFDLHNFQUFXO0FBQ2xDLGtCQUFrQixtQkFBTyxDQUFDLDRGQUF5Qjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9zZXMtdHJhbnNwb3J0L2luZGV4LmpzPzNkODQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IHBhY2thZ2VEYXRhID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJyk7XG5jb25zdCBzaGFyZWQgPSByZXF1aXJlKCcuLi9zaGFyZWQnKTtcbmNvbnN0IExlV2luZG93cyA9IHJlcXVpcmUoJy4uL21pbWUtbm9kZS9sZS13aW5kb3dzJyk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgVHJhbnNwb3J0IG9iamVjdCBmb3IgQVdTIFNFU1xuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnMgY2FuIGJlIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogICogKipzZW5kaW5nUmF0ZSoqIG9wdGlvbmFsIE51bWJlciBzcGVjaWZ5aW5nIGhvdyBtYW55IG1lc3NhZ2VzIHBlciBzZWNvbmQgc2hvdWxkIGJlIGRlbGl2ZXJlZCB0byBTRVNcbiAqICAqICoqbWF4Q29ubmVjdGlvbnMqKiBvcHRpb25hbCBOdW1iZXIgc3BlY2lmeWluZyBtYXggbnVtYmVyIG9mIHBhcmFsbGVsIGNvbm5lY3Rpb25zIHRvIFNFU1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbmFsIGNvbmZpZyBwYXJhbWV0ZXJcbiAqL1xuY2xhc3MgU0VTVHJhbnNwb3J0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuc2VzID0gdGhpcy5vcHRpb25zLlNFUztcblxuICAgICAgICB0aGlzLm5hbWUgPSAnU0VTVHJhbnNwb3J0JztcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gcGFja2FnZURhdGEudmVyc2lvbjtcblxuICAgICAgICB0aGlzLmxvZ2dlciA9IHNoYXJlZC5nZXRMb2dnZXIodGhpcy5vcHRpb25zLCB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMub3B0aW9ucy5jb21wb25lbnQgfHwgJ3Nlcy10cmFuc3BvcnQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHBhcmFsbGVsIHNlbmRpbmcgY29ubmVjdGlvbnNcbiAgICAgICAgdGhpcy5tYXhDb25uZWN0aW9ucyA9IE51bWJlcih0aGlzLm9wdGlvbnMubWF4Q29ubmVjdGlvbnMpIHx8IEluZmluaXR5O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zID0gMDtcblxuICAgICAgICAvLyBtYXggbWVzc2FnZXMgcGVyIHNlY29uZFxuICAgICAgICB0aGlzLnNlbmRpbmdSYXRlID0gTnVtYmVyKHRoaXMub3B0aW9ucy5zZW5kaW5nUmF0ZSkgfHwgSW5maW5pdHk7XG4gICAgICAgIHRoaXMuc2VuZGluZ1JhdGVUVEwgPSBudWxsO1xuICAgICAgICB0aGlzLnJhdGVJbnRlcnZhbCA9IDEwMDA7IC8vIG1pbGxpc2Vjb25kc1xuICAgICAgICB0aGlzLnJhdGVNZXNzYWdlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMucGVuZGluZyA9IFtdO1xuXG4gICAgICAgIHRoaXMuaWRsaW5nID0gdHJ1ZTtcblxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRsaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpZGxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhIHNlbmRpbmcgb2YgYSBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW1haWxNZXNzYWdlIE1haWxDb21wb3NlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgc2VuZGluZyBpcyBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBzZW5kKG1haWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25zID49IHRoaXMubWF4Q29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuaWRsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nLnB1c2goe1xuICAgICAgICAgICAgICAgIG1haWwsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja1NlbmRpbmdSYXRlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaWRsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nLnB1c2goe1xuICAgICAgICAgICAgICAgIG1haWwsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2VuZChtYWlsLCAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2NoZWNrUmF0ZWRRdWV1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbnMgPj0gdGhpcy5tYXhDb25uZWN0aW9ucyB8fCAhdGhpcy5fY2hlY2tTZW5kaW5nUmF0ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucGVuZGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pZGxpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlkbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpZGxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV4dCA9IHRoaXMucGVuZGluZy5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9zZW5kKG5leHQubWFpbCwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiBuZXh0LmNhbGxiYWNrKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2NoZWNrU2VuZGluZ1JhdGUoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNlbmRpbmdSYXRlVFRMKTtcblxuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IG9sZGVzdCA9IGZhbHNlO1xuICAgICAgICAvLyBkZWxldGUgb2xkZXIgbWVzc2FnZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMucmF0ZU1lc3NhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYXRlTWVzc2FnZXNbaV0udHMgPj0gbm93IC0gdGhpcy5yYXRlSW50ZXJ2YWwgJiYgKCFvbGRlc3QgfHwgdGhpcy5yYXRlTWVzc2FnZXNbaV0udHMgPCBvbGRlc3QpKSB7XG4gICAgICAgICAgICAgICAgb2xkZXN0ID0gdGhpcy5yYXRlTWVzc2FnZXNbaV0udHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnJhdGVNZXNzYWdlc1tpXS50cyA8IG5vdyAtIHRoaXMucmF0ZUludGVydmFsICYmICF0aGlzLnJhdGVNZXNzYWdlc1tpXS5wZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYXRlTWVzc2FnZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucmF0ZU1lc3NhZ2VzLmxlbmd0aCA8IHRoaXMuc2VuZGluZ1JhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRlbGF5ID0gTWF0aC5tYXgob2xkZXN0ICsgMTAwMSwgbm93ICsgMjApO1xuICAgICAgICB0aGlzLnNlbmRpbmdSYXRlVFRMID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9jaGVja1JhdGVkUXVldWUoKSwgbm93IC0gZGVsYXkpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRpbmdSYXRlVFRMLnVucmVmKCk7XG4gICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZS4gSGFwcGVucyBvbiBlbnZzIHdpdGggbm9uLW5vZGUgdGltZXIgaW1wbGVtZW50YXRpb25cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBfc2VudCgpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucy0tO1xuICAgICAgICB0aGlzLl9jaGVja1JhdGVkUXVldWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIGZyZWUgc2xvdHMgaW4gdGhlIHF1ZXVlXG4gICAgICovXG4gICAgaXNJZGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZGxpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGlsZXMgYSBtYWlsY29tcG9zZXIgbWVzc2FnZSBhbmQgZm9yd2FyZHMgaXQgdG8gU0VTXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW1haWxNZXNzYWdlIE1haWxDb21wb3NlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgc2VuZGluZyBpcyBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBfc2VuZChtYWlsLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgc3RhdE9iamVjdCA9IHtcbiAgICAgICAgICAgIHRzOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgcGVuZGluZzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zKys7XG4gICAgICAgIHRoaXMucmF0ZU1lc3NhZ2VzLnB1c2goc3RhdE9iamVjdCk7XG5cbiAgICAgICAgbGV0IGVudmVsb3BlID0gbWFpbC5kYXRhLmVudmVsb3BlIHx8IG1haWwubWVzc2FnZS5nZXRFbnZlbG9wZSgpO1xuICAgICAgICBsZXQgbWVzc2FnZUlkID0gbWFpbC5tZXNzYWdlLm1lc3NhZ2VJZCgpO1xuXG4gICAgICAgIGxldCByZWNpcGllbnRzID0gW10uY29uY2F0KGVudmVsb3BlLnRvIHx8IFtdKTtcbiAgICAgICAgaWYgKHJlY2lwaWVudHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgcmVjaXBpZW50cy5wdXNoKCcuLi5hbmQgJyArIHJlY2lwaWVudHMuc3BsaWNlKDIpLmxlbmd0aCArICcgbW9yZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG54OiAnc2VuZCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ1NlbmRpbmcgbWVzc2FnZSAlcyB0byA8JXM+JyxcbiAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgIHJlY2lwaWVudHMuam9pbignLCAnKVxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBnZXRSYXdNZXNzYWdlID0gbmV4dCA9PiB7XG4gICAgICAgICAgICAvLyBkbyBub3QgdXNlIE1lc3NhZ2UtSUQgYW5kIERhdGUgaW4gREtJTSBzaWduYXR1cmVcbiAgICAgICAgICAgIGlmICghbWFpbC5kYXRhLl9ka2ltKSB7XG4gICAgICAgICAgICAgICAgbWFpbC5kYXRhLl9ka2ltID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFpbC5kYXRhLl9ka2ltLnNraXBGaWVsZHMgJiYgdHlwZW9mIG1haWwuZGF0YS5fZGtpbS5za2lwRmllbGRzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG1haWwuZGF0YS5fZGtpbS5za2lwRmllbGRzICs9ICc6ZGF0ZTptZXNzYWdlLWlkJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFpbC5kYXRhLl9ka2ltLnNraXBGaWVsZHMgPSAnZGF0ZTptZXNzYWdlLWlkJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHNvdXJjZVN0cmVhbSA9IG1haWwubWVzc2FnZS5jcmVhdGVSZWFkU3RyZWFtKCk7XG4gICAgICAgICAgICBsZXQgc3RyZWFtID0gc291cmNlU3RyZWFtLnBpcGUobmV3IExlV2luZG93cygpKTtcbiAgICAgICAgICAgIGxldCBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgIGxldCBjaHVua2xlbiA9IDA7XG5cbiAgICAgICAgICAgIHN0cmVhbS5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNodW5rO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoY2h1bmsgPSBzdHJlYW0ucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rbGVuICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc291cmNlU3RyZWFtLm9uY2UoJ2Vycm9yJywgZXJyID0+IHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycikpO1xuXG4gICAgICAgICAgICBzdHJlYW0ub25jZSgnZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIG5leHQoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzdHJlYW0ub25jZSgnZW5kJywgKCkgPT4gbmV4dChudWxsLCBCdWZmZXIuY29uY2F0KGNodW5rcywgY2h1bmtsZW4pKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+XG4gICAgICAgICAgICBnZXRSYXdNZXNzYWdlKChlcnIsIHJhdykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgY3JlYXRpbmcgbWVzc2FnZSBmb3IgJXMuICVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRPYmplY3QucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgc2VzTWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgUmF3TWVzc2FnZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIERhdGE6IHJhdyAvLyByZXF1aXJlZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBTb3VyY2U6IGVudmVsb3BlLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIERlc3RpbmF0aW9uczogZW52ZWxvcGUudG9cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobWFpbC5kYXRhLnNlcyB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXNNZXNzYWdlW2tleV0gPSBtYWlsLmRhdGEuc2VzW2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgc2VzID0gKHRoaXMuc2VzLmF3cyA/IHRoaXMuc2VzLnNlcyA6IHRoaXMuc2VzKSB8fCB7fTtcbiAgICAgICAgICAgICAgICBsZXQgYXdzID0gdGhpcy5zZXMuYXdzIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgbGV0IGdldFJlZ2lvbiA9IGNiID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcy5jb25maWcgJiYgdHlwZW9mIHNlcy5jb25maWcucmVnaW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VzLmNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWdpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlZ2lvbiA9PiBjYihudWxsLCByZWdpb24pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY2IoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIChzZXMuY29uZmlnICYmIHNlcy5jb25maWcucmVnaW9uKSB8fCAndXMtZWFzdC0xJyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGdldFJlZ2lvbigoZXJyLCByZWdpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciB8fCAhcmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb24gPSAndXMtZWFzdC0xJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZW5kUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXMuc2VuZCA9PT0gJ2Z1bmN0aW9uJyAmJiBhd3MuU2VuZFJhd0VtYWlsQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdjMgQVBJXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kUHJvbWlzZSA9IHNlcy5zZW5kKG5ldyBhd3MuU2VuZFJhd0VtYWlsQ29tbWFuZChzZXNNZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2MiBBUElcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRQcm9taXNlID0gc2VzLnNlbmRSYXdFbWFpbChzZXNNZXNzYWdlKS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZW5kUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2lvbiA9PT0gJ3VzLWVhc3QtMScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uID0gJ2VtYWlsJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0T2JqZWN0LnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudmVsb3BlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBlbnZlbG9wZS5mcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGVudmVsb3BlLnRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogJzwnICsgZGF0YS5NZXNzYWdlSWQgKyAoIS9ALy50ZXN0KGRhdGEuTWVzc2FnZUlkKSA/ICdAJyArIHJlZ2lvbiArICcuYW1hem9uc2VzLmNvbScgOiAnJykgKyAnPicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBkYXRhLk1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3NlbmQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTZW5kIGVycm9yIGZvciAlczogJXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0T2JqZWN0LnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIFNFUyBjb25maWd1cmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIHZlcmlmeShjYWxsYmFjaykge1xuICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgbGV0IHNlcyA9ICh0aGlzLnNlcy5hd3MgPyB0aGlzLnNlcy5zZXMgOiB0aGlzLnNlcykgfHwge307XG4gICAgICAgIGxldCBhd3MgPSB0aGlzLnNlcy5hd3MgfHwge307XG5cbiAgICAgICAgY29uc3Qgc2VzTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIFJhd01lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICAgICAgICAgIERhdGE6ICdGcm9tOiBpbnZhbGlkQGludmFsaWRcXHJcXG5UbzogaW52YWxpZEBpbnZhbGlkXFxyXFxuIFN1YmplY3Q6IEludmFsaWRcXHJcXG5cXHJcXG5JbnZhbGlkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFNvdXJjZTogJ2ludmFsaWRAaW52YWxpZCcsXG4gICAgICAgICAgICBEZXN0aW5hdGlvbnM6IFsnaW52YWxpZEBpbnZhbGlkJ11cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gc2hhcmVkLmNhbGxiYWNrUHJvbWlzZShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2IgPSBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgfHwgZXJyLkNvZGUpICE9PSAnSW52YWxpZFBhcmFtZXRlclZhbHVlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VzLnNlbmQgPT09ICdmdW5jdGlvbicgJiYgYXdzLlNlbmRSYXdFbWFpbENvbW1hbmQpIHtcbiAgICAgICAgICAgIC8vIHYzIEFQSVxuICAgICAgICAgICAgc2VzTWVzc2FnZS5SYXdNZXNzYWdlLkRhdGEgPSBCdWZmZXIuZnJvbShzZXNNZXNzYWdlLlJhd01lc3NhZ2UuRGF0YSk7XG4gICAgICAgICAgICBzZXMuc2VuZChuZXcgYXdzLlNlbmRSYXdFbWFpbENvbW1hbmQoc2VzTWVzc2FnZSksIGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHYyIEFQSVxuICAgICAgICAgICAgc2VzLnNlbmRSYXdFbWFpbChzZXNNZXNzYWdlLCBjYik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU0VTVHJhbnNwb3J0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/ses-transport/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/shared/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/nodemailer/lib/shared/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-console: 0 */\n\n\n\nconst urllib = __webpack_require__(/*! url */ \"url\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst nmfetch = __webpack_require__(/*! ../fetch */ \"(rsc)/./node_modules/nodemailer/lib/fetch/index.js\");\nconst dns = __webpack_require__(/*! dns */ \"dns\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst os = __webpack_require__(/*! os */ \"os\");\n\nconst DNS_TTL = 5 * 60 * 1000;\n\nlet networkInterfaces;\ntry {\n    networkInterfaces = os.networkInterfaces();\n} catch (err) {\n    // fails on some systems\n}\n\nmodule.exports.networkInterfaces = networkInterfaces;\n\nconst isFamilySupported = (family, allowInternal) => {\n    let networkInterfaces = module.exports.networkInterfaces;\n    if (!networkInterfaces) {\n        // hope for the best\n        return true;\n    }\n\n    const familySupported =\n        // crux that replaces Object.values(networkInterfaces) as Object.values is not supported in nodejs v6\n        Object.keys(networkInterfaces)\n            .map(key => networkInterfaces[key])\n            // crux that replaces .flat() as it is not supported in older Node versions (v10 and older)\n            .reduce((acc, val) => acc.concat(val), [])\n            .filter(i => !i.internal || allowInternal)\n            .filter(i => i.family === 'IPv' + family || i.family === family).length > 0;\n\n    return familySupported;\n};\n\nconst resolver = (family, hostname, options, callback) => {\n    options = options || {};\n    const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);\n\n    if (!familySupported) {\n        return callback(null, []);\n    }\n\n    const resolver = dns.Resolver ? new dns.Resolver(options) : dns;\n    resolver['resolve' + family](hostname, (err, addresses) => {\n        if (err) {\n            switch (err.code) {\n                case dns.NODATA:\n                case dns.NOTFOUND:\n                case dns.NOTIMP:\n                case dns.SERVFAIL:\n                case dns.CONNREFUSED:\n                case dns.REFUSED:\n                case 'EAI_AGAIN':\n                    return callback(null, []);\n            }\n            return callback(err);\n        }\n        return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));\n    });\n};\n\nconst dnsCache = (module.exports.dnsCache = new Map());\n\nconst formatDNSValue = (value, extra) => {\n    if (!value) {\n        return Object.assign({}, extra || {});\n    }\n\n    return Object.assign(\n        {\n            servername: value.servername,\n            host:\n                !value.addresses || !value.addresses.length\n                    ? null\n                    : value.addresses.length === 1\n                    ? value.addresses[0]\n                    : value.addresses[Math.floor(Math.random() * value.addresses.length)]\n        },\n        extra || {}\n    );\n};\n\nmodule.exports.resolveHostname = (options, callback) => {\n    options = options || {};\n\n    if (!options.host && options.servername) {\n        options.host = options.servername;\n    }\n\n    if (!options.host || net.isIP(options.host)) {\n        // nothing to do here\n        let value = {\n            addresses: [options.host],\n            servername: options.servername || false\n        };\n        return callback(\n            null,\n            formatDNSValue(value, {\n                cached: false\n            })\n        );\n    }\n\n    let cached;\n    if (dnsCache.has(options.host)) {\n        cached = dnsCache.get(options.host);\n\n        if (!cached.expires || cached.expires >= Date.now()) {\n            return callback(\n                null,\n                formatDNSValue(cached.value, {\n                    cached: true\n                })\n            );\n        }\n    }\n\n    resolver(4, options.host, options, (err, addresses) => {\n        if (err) {\n            if (cached) {\n                // ignore error, use expired value\n                return callback(\n                    null,\n                    formatDNSValue(cached.value, {\n                        cached: true,\n                        error: err\n                    })\n                );\n            }\n            return callback(err);\n        }\n\n        if (addresses && addresses.length) {\n            let value = {\n                addresses,\n                servername: options.servername || options.host\n            };\n\n            dnsCache.set(options.host, {\n                value,\n                expires: Date.now() + (options.dnsTtl || DNS_TTL)\n            });\n\n            return callback(\n                null,\n                formatDNSValue(value, {\n                    cached: false\n                })\n            );\n        }\n\n        resolver(6, options.host, options, (err, addresses) => {\n            if (err) {\n                if (cached) {\n                    // ignore error, use expired value\n                    return callback(\n                        null,\n                        formatDNSValue(cached.value, {\n                            cached: true,\n                            error: err\n                        })\n                    );\n                }\n                return callback(err);\n            }\n\n            if (addresses && addresses.length) {\n                let value = {\n                    addresses,\n                    servername: options.servername || options.host\n                };\n\n                dnsCache.set(options.host, {\n                    value,\n                    expires: Date.now() + (options.dnsTtl || DNS_TTL)\n                });\n\n                return callback(\n                    null,\n                    formatDNSValue(value, {\n                        cached: false\n                    })\n                );\n            }\n\n            try {\n                dns.lookup(options.host, { all: true }, (err, addresses) => {\n                    if (err) {\n                        if (cached) {\n                            // ignore error, use expired value\n                            return callback(\n                                null,\n                                formatDNSValue(cached.value, {\n                                    cached: true,\n                                    error: err\n                                })\n                            );\n                        }\n                        return callback(err);\n                    }\n\n                    let address = addresses\n                        ? addresses\n                              .filter(addr => isFamilySupported(addr.family))\n                              .map(addr => addr.address)\n                              .shift()\n                        : false;\n\n                    if (addresses && addresses.length && !address) {\n                        // there are addresses but none can be used\n                        console.warn(`Failed to resolve IPv${addresses[0].family} addresses with current network`);\n                    }\n\n                    if (!address && cached) {\n                        // nothing was found, fallback to cached value\n                        return callback(\n                            null,\n                            formatDNSValue(cached.value, {\n                                cached: true\n                            })\n                        );\n                    }\n\n                    let value = {\n                        addresses: address ? [address] : [options.host],\n                        servername: options.servername || options.host\n                    };\n\n                    dnsCache.set(options.host, {\n                        value,\n                        expires: Date.now() + (options.dnsTtl || DNS_TTL)\n                    });\n\n                    return callback(\n                        null,\n                        formatDNSValue(value, {\n                            cached: false\n                        })\n                    );\n                });\n            } catch (err) {\n                if (cached) {\n                    // ignore error, use expired value\n                    return callback(\n                        null,\n                        formatDNSValue(cached.value, {\n                            cached: true,\n                            error: err\n                        })\n                    );\n                }\n                return callback(err);\n            }\n        });\n    });\n};\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\nmodule.exports.parseConnectionUrl = str => {\n    str = str || '';\n    let options = {};\n\n    [urllib.parse(str, true)].forEach(url => {\n        let auth;\n\n        switch (url.protocol) {\n            case 'smtp:':\n                options.secure = false;\n                break;\n            case 'smtps:':\n                options.secure = true;\n                break;\n            case 'direct:':\n                options.direct = true;\n                break;\n        }\n\n        if (!isNaN(url.port) && Number(url.port)) {\n            options.port = Number(url.port);\n        }\n\n        if (url.hostname) {\n            options.host = url.hostname;\n        }\n\n        if (url.auth) {\n            auth = url.auth.split(':');\n\n            if (!options.auth) {\n                options.auth = {};\n            }\n\n            options.auth.user = auth.shift();\n            options.auth.pass = auth.join(':');\n        }\n\n        Object.keys(url.query || {}).forEach(key => {\n            let obj = options;\n            let lKey = key;\n            let value = url.query[key];\n\n            if (!isNaN(value)) {\n                value = Number(value);\n            }\n\n            switch (value) {\n                case 'true':\n                    value = true;\n                    break;\n                case 'false':\n                    value = false;\n                    break;\n            }\n\n            // tls is nested object\n            if (key.indexOf('tls.') === 0) {\n                lKey = key.substr(4);\n                if (!options.tls) {\n                    options.tls = {};\n                }\n                obj = options.tls;\n            } else if (key.indexOf('.') >= 0) {\n                // ignore nested properties besides tls\n                return;\n            }\n\n            if (!(lKey in obj)) {\n                obj[lKey] = value;\n            }\n        });\n    });\n\n    return options;\n};\n\nmodule.exports._logFunc = (logger, level, defaults, data, message, ...args) => {\n    let entry = {};\n\n    Object.keys(defaults || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = defaults[key];\n        }\n    });\n\n    Object.keys(data || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = data[key];\n        }\n    });\n\n    logger[level](entry, message, ...args);\n};\n\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\nmodule.exports.getLogger = (options, defaults) => {\n    options = options || {};\n\n    let response = {};\n    let levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];\n\n    if (!options.logger) {\n        // use vanity logger\n        levels.forEach(level => {\n            response[level] = () => false;\n        });\n        return response;\n    }\n\n    let logger = options.logger;\n\n    if (options.logger === true) {\n        // create console logger\n        logger = createDefaultLogger(levels);\n    }\n\n    levels.forEach(level => {\n        response[level] = (data, message, ...args) => {\n            module.exports._logFunc(logger, level, defaults, data, message, ...args);\n        };\n    });\n\n    return response;\n};\n\n/**\n * Wrapper for creating a callback that either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\nmodule.exports.callbackPromise = (resolve, reject) =>\n    function () {\n        let args = Array.from(arguments);\n        let err = args.shift();\n        if (err) {\n            reject(err);\n        } else {\n            resolve(...args);\n        }\n    };\n\nmodule.exports.parseDataURI = uri => {\n    let input = uri;\n    let commaPos = input.indexOf(',');\n    if (!commaPos) {\n        return uri;\n    }\n\n    let data = input.substring(commaPos + 1);\n    let metaStr = input.substring('data:'.length, commaPos);\n\n    let encoding;\n\n    let metaEntries = metaStr.split(';');\n    let lastMetaEntry = metaEntries.length > 1 ? metaEntries[metaEntries.length - 1] : false;\n    if (lastMetaEntry && lastMetaEntry.indexOf('=') < 0) {\n        encoding = lastMetaEntry.toLowerCase();\n        metaEntries.pop();\n    }\n\n    let contentType = metaEntries.shift() || 'application/octet-stream';\n    let params = {};\n    for (let entry of metaEntries) {\n        let sep = entry.indexOf('=');\n        if (sep >= 0) {\n            let key = entry.substring(0, sep);\n            let value = entry.substring(sep + 1);\n            params[key] = value;\n        }\n    }\n\n    switch (encoding) {\n        case 'base64':\n            data = Buffer.from(data, 'base64');\n            break;\n        case 'utf8':\n            data = Buffer.from(data);\n            break;\n        default:\n            try {\n                data = Buffer.from(decodeURIComponent(data));\n            } catch (err) {\n                data = Buffer.from(data);\n            }\n            data = Buffer.from(data);\n    }\n\n    return { data, encoding, contentType, params };\n};\n\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\nmodule.exports.resolveContent = (data, key, callback) => {\n    let promise;\n\n    if (!callback) {\n        promise = new Promise((resolve, reject) => {\n            callback = module.exports.callbackPromise(resolve, reject);\n        });\n    }\n\n    let content = (data && data[key] && data[key].content) || data[key];\n    let contentStream;\n    let encoding = ((typeof data[key] === 'object' && data[key].encoding) || 'utf8')\n        .toString()\n        .toLowerCase()\n        .replace(/[-_\\s]/g, '');\n\n    if (!content) {\n        return callback(null, content);\n    }\n\n    if (typeof content === 'object') {\n        if (typeof content.pipe === 'function') {\n            return resolveStream(content, (err, value) => {\n                if (err) {\n                    return callback(err);\n                }\n                // we can't stream twice the same content, so we need\n                // to replace the stream object with the streaming result\n                if (data[key].content) {\n                    data[key].content = value;\n                } else {\n                    data[key] = value;\n                }\n                callback(null, value);\n            });\n        } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n            contentStream = nmfetch(content.path || content.href);\n            return resolveStream(contentStream, callback);\n        } else if (/^data:/i.test(content.path || content.href)) {\n            let parsedDataUri = module.exports.parseDataURI(content.path || content.href);\n\n            if (!parsedDataUri || !parsedDataUri.data) {\n                return callback(null, Buffer.from(0));\n            }\n            return callback(null, parsedDataUri.data);\n        } else if (content.path) {\n            return resolveStream(fs.createReadStream(content.path), callback);\n        }\n    }\n\n    if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n        content = Buffer.from(data[key].content, encoding);\n    }\n\n    // default action, return as is\n    setImmediate(() => callback(null, content));\n\n    return promise;\n};\n\n/**\n * Copies properties from source objects to target objects\n */\nmodule.exports.assign = function (/* target, ... sources */) {\n    let args = Array.from(arguments);\n    let target = args.shift() || {};\n\n    args.forEach(source => {\n        Object.keys(source || {}).forEach(key => {\n            if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {\n                // tls and auth are special keys that need to be enumerated separately\n                // other objects are passed as is\n                if (!target[key]) {\n                    // ensure that target has this key\n                    target[key] = {};\n                }\n                Object.keys(source[key]).forEach(subKey => {\n                    target[key][subKey] = source[key][subKey];\n                });\n            } else {\n                target[key] = source[key];\n            }\n        });\n    });\n    return target;\n};\n\nmodule.exports.encodeXText = str => {\n    // ! 0x21\n    // + 0x2B\n    // = 0x3D\n    // ~ 0x7E\n    if (!/[^\\x21-\\x2A\\x2C-\\x3C\\x3E-\\x7E]/.test(str)) {\n        return str;\n    }\n    let buf = Buffer.from(str);\n    let result = '';\n    for (let i = 0, len = buf.length; i < len; i++) {\n        let c = buf[i];\n        if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {\n            result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();\n        } else {\n            result += String.fromCharCode(c);\n        }\n    }\n    return result;\n};\n\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\nfunction resolveStream(stream, callback) {\n    let responded = false;\n    let chunks = [];\n    let chunklen = 0;\n\n    stream.on('error', err => {\n        if (responded) {\n            return;\n        }\n\n        responded = true;\n        callback(err);\n    });\n\n    stream.on('readable', () => {\n        let chunk;\n        while ((chunk = stream.read()) !== null) {\n            chunks.push(chunk);\n            chunklen += chunk.length;\n        }\n    });\n\n    stream.on('end', () => {\n        if (responded) {\n            return;\n        }\n        responded = true;\n\n        let value;\n\n        try {\n            value = Buffer.concat(chunks, chunklen);\n        } catch (E) {\n            return callback(E);\n        }\n        callback(null, value);\n    });\n}\n\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\nfunction createDefaultLogger(levels) {\n    let levelMaxLen = 0;\n    let levelNames = new Map();\n    levels.forEach(level => {\n        if (level.length > levelMaxLen) {\n            levelMaxLen = level.length;\n        }\n    });\n\n    levels.forEach(level => {\n        let levelName = level.toUpperCase();\n        if (levelName.length < levelMaxLen) {\n            levelName += ' '.repeat(levelMaxLen - levelName.length);\n        }\n        levelNames.set(level, levelName);\n    });\n\n    let print = (level, entry, message, ...args) => {\n        let prefix = '';\n        if (entry) {\n            if (entry.tnx === 'server') {\n                prefix = 'S: ';\n            } else if (entry.tnx === 'client') {\n                prefix = 'C: ';\n            }\n\n            if (entry.sid) {\n                prefix = '[' + entry.sid + '] ' + prefix;\n            }\n\n            if (entry.cid) {\n                prefix = '[#' + entry.cid + '] ' + prefix;\n            }\n        }\n\n        message = util.format(message, ...args);\n        message.split(/\\r?\\n/).forEach(line => {\n            console.log('[%s] %s %s', new Date().toISOString().substr(0, 19).replace(/T/, ' '), levelNames.get(level), prefix + line);\n        });\n    };\n\n    let logger = {};\n    levels.forEach(level => {\n        logger[level] = print.bind(null, level);\n    });\n\n    return logger;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc2hhcmVkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxnQkFBSztBQUM1QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQVU7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixXQUFXLG1CQUFPLENBQUMsY0FBSTs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsa0JBQWtCLHVCQUF1Qjs7QUFFekM7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RCxxQkFBcUI7QUFDbEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qjs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VtYXJrZXQvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc2hhcmVkL2luZGV4LmpzP2E4NWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLWNvbnNvbGU6IDAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1cmxsaWIgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBubWZldGNoID0gcmVxdWlyZSgnLi4vZmV0Y2gnKTtcbmNvbnN0IGRucyA9IHJlcXVpcmUoJ2RucycpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5cbmNvbnN0IEROU19UVEwgPSA1ICogNjAgKiAxMDAwO1xuXG5sZXQgbmV0d29ya0ludGVyZmFjZXM7XG50cnkge1xuICAgIG5ldHdvcmtJbnRlcmZhY2VzID0gb3MubmV0d29ya0ludGVyZmFjZXMoKTtcbn0gY2F0Y2ggKGVycikge1xuICAgIC8vIGZhaWxzIG9uIHNvbWUgc3lzdGVtc1xufVxuXG5tb2R1bGUuZXhwb3J0cy5uZXR3b3JrSW50ZXJmYWNlcyA9IG5ldHdvcmtJbnRlcmZhY2VzO1xuXG5jb25zdCBpc0ZhbWlseVN1cHBvcnRlZCA9IChmYW1pbHksIGFsbG93SW50ZXJuYWwpID0+IHtcbiAgICBsZXQgbmV0d29ya0ludGVyZmFjZXMgPSBtb2R1bGUuZXhwb3J0cy5uZXR3b3JrSW50ZXJmYWNlcztcbiAgICBpZiAoIW5ldHdvcmtJbnRlcmZhY2VzKSB7XG4gICAgICAgIC8vIGhvcGUgZm9yIHRoZSBiZXN0XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGZhbWlseVN1cHBvcnRlZCA9XG4gICAgICAgIC8vIGNydXggdGhhdCByZXBsYWNlcyBPYmplY3QudmFsdWVzKG5ldHdvcmtJbnRlcmZhY2VzKSBhcyBPYmplY3QudmFsdWVzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gbm9kZWpzIHY2XG4gICAgICAgIE9iamVjdC5rZXlzKG5ldHdvcmtJbnRlcmZhY2VzKVxuICAgICAgICAgICAgLm1hcChrZXkgPT4gbmV0d29ya0ludGVyZmFjZXNba2V5XSlcbiAgICAgICAgICAgIC8vIGNydXggdGhhdCByZXBsYWNlcyAuZmxhdCgpIGFzIGl0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gb2xkZXIgTm9kZSB2ZXJzaW9ucyAodjEwIGFuZCBvbGRlcilcbiAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCksIFtdKVxuICAgICAgICAgICAgLmZpbHRlcihpID0+ICFpLmludGVybmFsIHx8IGFsbG93SW50ZXJuYWwpXG4gICAgICAgICAgICAuZmlsdGVyKGkgPT4gaS5mYW1pbHkgPT09ICdJUHYnICsgZmFtaWx5IHx8IGkuZmFtaWx5ID09PSBmYW1pbHkpLmxlbmd0aCA+IDA7XG5cbiAgICByZXR1cm4gZmFtaWx5U3VwcG9ydGVkO1xufTtcblxuY29uc3QgcmVzb2x2ZXIgPSAoZmFtaWx5LCBob3N0bmFtZSwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBmYW1pbHlTdXBwb3J0ZWQgPSBpc0ZhbWlseVN1cHBvcnRlZChmYW1pbHksIG9wdGlvbnMuYWxsb3dJbnRlcm5hbE5ldHdvcmtJbnRlcmZhY2VzKTtcblxuICAgIGlmICghZmFtaWx5U3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzb2x2ZXIgPSBkbnMuUmVzb2x2ZXIgPyBuZXcgZG5zLlJlc29sdmVyKG9wdGlvbnMpIDogZG5zO1xuICAgIHJlc29sdmVyWydyZXNvbHZlJyArIGZhbWlseV0oaG9zdG5hbWUsIChlcnIsIGFkZHJlc3NlcykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBkbnMuTk9EQVRBOlxuICAgICAgICAgICAgICAgIGNhc2UgZG5zLk5PVEZPVU5EOlxuICAgICAgICAgICAgICAgIGNhc2UgZG5zLk5PVElNUDpcbiAgICAgICAgICAgICAgICBjYXNlIGRucy5TRVJWRkFJTDpcbiAgICAgICAgICAgICAgICBjYXNlIGRucy5DT05OUkVGVVNFRDpcbiAgICAgICAgICAgICAgICBjYXNlIGRucy5SRUZVU0VEOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0VBSV9BR0FJTic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgQXJyYXkuaXNBcnJheShhZGRyZXNzZXMpID8gYWRkcmVzc2VzIDogW10uY29uY2F0KGFkZHJlc3NlcyB8fCBbXSkpO1xuICAgIH0pO1xufTtcblxuY29uc3QgZG5zQ2FjaGUgPSAobW9kdWxlLmV4cG9ydHMuZG5zQ2FjaGUgPSBuZXcgTWFwKCkpO1xuXG5jb25zdCBmb3JtYXRETlNWYWx1ZSA9ICh2YWx1ZSwgZXh0cmEpID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBleHRyYSB8fCB7fSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNlcnZlcm5hbWU6IHZhbHVlLnNlcnZlcm5hbWUsXG4gICAgICAgICAgICBob3N0OlxuICAgICAgICAgICAgICAgICF2YWx1ZS5hZGRyZXNzZXMgfHwgIXZhbHVlLmFkZHJlc3Nlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdmFsdWUuYWRkcmVzc2VzLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlLmFkZHJlc3Nlc1swXVxuICAgICAgICAgICAgICAgICAgICA6IHZhbHVlLmFkZHJlc3Nlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB2YWx1ZS5hZGRyZXNzZXMubGVuZ3RoKV1cbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmEgfHwge31cbiAgICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMucmVzb2x2ZUhvc3RuYW1lID0gKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoIW9wdGlvbnMuaG9zdCAmJiBvcHRpb25zLnNlcnZlcm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5ob3N0ID0gb3B0aW9ucy5zZXJ2ZXJuYW1lO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5ob3N0IHx8IG5ldC5pc0lQKG9wdGlvbnMuaG9zdCkpIHtcbiAgICAgICAgLy8gbm90aGluZyB0byBkbyBoZXJlXG4gICAgICAgIGxldCB2YWx1ZSA9IHtcbiAgICAgICAgICAgIGFkZHJlc3NlczogW29wdGlvbnMuaG9zdF0sXG4gICAgICAgICAgICBzZXJ2ZXJuYW1lOiBvcHRpb25zLnNlcnZlcm5hbWUgfHwgZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGZvcm1hdEROU1ZhbHVlKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgY2FjaGVkOiBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgY2FjaGVkO1xuICAgIGlmIChkbnNDYWNoZS5oYXMob3B0aW9ucy5ob3N0KSkge1xuICAgICAgICBjYWNoZWQgPSBkbnNDYWNoZS5nZXQob3B0aW9ucy5ob3N0KTtcblxuICAgICAgICBpZiAoIWNhY2hlZC5leHBpcmVzIHx8IGNhY2hlZC5leHBpcmVzID49IERhdGUubm93KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGZvcm1hdEROU1ZhbHVlKGNhY2hlZC52YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc29sdmVyKDQsIG9wdGlvbnMuaG9zdCwgb3B0aW9ucywgKGVyciwgYWRkcmVzc2VzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3IsIHVzZSBleHBpcmVkIHZhbHVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRETlNWYWx1ZShjYWNoZWQudmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRkcmVzc2VzICYmIGFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXMsXG4gICAgICAgICAgICAgICAgc2VydmVybmFtZTogb3B0aW9ucy5zZXJ2ZXJuYW1lIHx8IG9wdGlvbnMuaG9zdFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZG5zQ2FjaGUuc2V0KG9wdGlvbnMuaG9zdCwge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cGlyZXM6IERhdGUubm93KCkgKyAob3B0aW9ucy5kbnNUdGwgfHwgRE5TX1RUTClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmb3JtYXRETlNWYWx1ZSh2YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlcig2LCBvcHRpb25zLmhvc3QsIG9wdGlvbnMsIChlcnIsIGFkZHJlc3NlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGVycm9yLCB1c2UgZXhwaXJlZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0RE5TVmFsdWUoY2FjaGVkLnZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWRkcmVzc2VzICYmIGFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVybmFtZTogb3B0aW9ucy5zZXJ2ZXJuYW1lIHx8IG9wdGlvbnMuaG9zdFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkbnNDYWNoZS5zZXQob3B0aW9ucy5ob3N0LCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzOiBEYXRlLm5vdygpICsgKG9wdGlvbnMuZG5zVHRsIHx8IEROU19UVEwpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdEROU1ZhbHVlKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkbnMubG9va3VwKG9wdGlvbnMuaG9zdCwgeyBhbGw6IHRydWUgfSwgKGVyciwgYWRkcmVzc2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3IsIHVzZSBleHBpcmVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRETlNWYWx1ZShjYWNoZWQudmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkcmVzcyA9IGFkZHJlc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBhZGRyZXNzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoYWRkciA9PiBpc0ZhbWlseVN1cHBvcnRlZChhZGRyLmZhbWlseSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGFkZHIgPT4gYWRkci5hZGRyZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNoaWZ0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3NlcyAmJiBhZGRyZXNzZXMubGVuZ3RoICYmICFhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBhcmUgYWRkcmVzc2VzIGJ1dCBub25lIGNhbiBiZSB1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byByZXNvbHZlIElQdiR7YWRkcmVzc2VzWzBdLmZhbWlseX0gYWRkcmVzc2VzIHdpdGggY3VycmVudCBuZXR3b3JrYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFkZHJlc3MgJiYgY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nIHdhcyBmb3VuZCwgZmFsbGJhY2sgdG8gY2FjaGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRETlNWYWx1ZShjYWNoZWQudmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IGFkZHJlc3MgPyBbYWRkcmVzc10gOiBbb3B0aW9ucy5ob3N0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlcm5hbWU6IG9wdGlvbnMuc2VydmVybmFtZSB8fCBvcHRpb25zLmhvc3RcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBkbnNDYWNoZS5zZXQob3B0aW9ucy5ob3N0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXM6IERhdGUubm93KCkgKyAob3B0aW9ucy5kbnNUdGwgfHwgRE5TX1RUTClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdEROU1ZhbHVlKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGVycm9yLCB1c2UgZXhwaXJlZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0RE5TVmFsdWUoY2FjaGVkLnZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vKipcbiAqIFBhcnNlcyBjb25uZWN0aW9uIHVybCB0byBhIHN0cnVjdHVyZWQgY29uZmlndXJhdGlvbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIENvbm5lY3Rpb24gdXJsXG4gKiBAcmV0dXJuIHtPYmplY3R9IENvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlQ29ubmVjdGlvblVybCA9IHN0ciA9PiB7XG4gICAgc3RyID0gc3RyIHx8ICcnO1xuICAgIGxldCBvcHRpb25zID0ge307XG5cbiAgICBbdXJsbGliLnBhcnNlKHN0ciwgdHJ1ZSldLmZvckVhY2godXJsID0+IHtcbiAgICAgICAgbGV0IGF1dGg7XG5cbiAgICAgICAgc3dpdGNoICh1cmwucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NtdHA6JzpcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlY3VyZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc210cHM6JzpcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlY3VyZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkaXJlY3Q6JzpcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRpcmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKHVybC5wb3J0KSAmJiBOdW1iZXIodXJsLnBvcnQpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvcnQgPSBOdW1iZXIodXJsLnBvcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVybC5ob3N0bmFtZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVybC5hdXRoKSB7XG4gICAgICAgICAgICBhdXRoID0gdXJsLmF1dGguc3BsaXQoJzonKTtcblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmF1dGgpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmF1dGggPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0aW9ucy5hdXRoLnVzZXIgPSBhdXRoLnNoaWZ0KCk7XG4gICAgICAgICAgICBvcHRpb25zLmF1dGgucGFzcyA9IGF1dGguam9pbignOicpO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXModXJsLnF1ZXJ5IHx8IHt9KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgb2JqID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxldCBsS2V5ID0ga2V5O1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdXJsLnF1ZXJ5W2tleV07XG5cbiAgICAgICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndHJ1ZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFsc2UnOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGxzIGlzIG5lc3RlZCBvYmplY3RcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZigndGxzLicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbEtleSA9IGtleS5zdWJzdHIoNCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnRscykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRscyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmogPSBvcHRpb25zLnRscztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5LmluZGV4T2YoJy4nKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIG5lc3RlZCBwcm9wZXJ0aWVzIGJlc2lkZXMgdGxzXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShsS2V5IGluIG9iaikpIHtcbiAgICAgICAgICAgICAgICBvYmpbbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbm1vZHVsZS5leHBvcnRzLl9sb2dGdW5jID0gKGxvZ2dlciwgbGV2ZWwsIGRlZmF1bHRzLCBkYXRhLCBtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gICAgbGV0IGVudHJ5ID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhkZWZhdWx0cyB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoa2V5ICE9PSAnbGV2ZWwnKSB7XG4gICAgICAgICAgICBlbnRyeVtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmtleXMoZGF0YSB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoa2V5ICE9PSAnbGV2ZWwnKSB7XG4gICAgICAgICAgICBlbnRyeVtrZXldID0gZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBsb2dnZXJbbGV2ZWxdKGVudHJ5LCBtZXNzYWdlLCAuLi5hcmdzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGJ1bnlhbi1jb21wYXRpYmxlIGxvZ2dlciBpbnRlcmZhY2UuIFVzZXMgZWl0aGVyIHByb3ZpZGVkIGxvZ2dlciBvclxuICogY3JlYXRlcyBhIGRlZmF1bHQgY29uc29sZSBsb2dnZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IHRoYXQgbWlnaHQgaW5jbHVkZSAnbG9nZ2VyJyB2YWx1ZVxuICogQHJldHVybiB7T2JqZWN0fSBidW55YW4gY29tcGF0aWJsZSBsb2dnZXJcbiAqL1xubW9kdWxlLmV4cG9ydHMuZ2V0TG9nZ2VyID0gKG9wdGlvbnMsIGRlZmF1bHRzKSA9PiB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBsZXQgcmVzcG9uc2UgPSB7fTtcbiAgICBsZXQgbGV2ZWxzID0gWyd0cmFjZScsICdkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InLCAnZmF0YWwnXTtcblxuICAgIGlmICghb3B0aW9ucy5sb2dnZXIpIHtcbiAgICAgICAgLy8gdXNlIHZhbml0eSBsb2dnZXJcbiAgICAgICAgbGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgICAgICAgcmVzcG9uc2VbbGV2ZWxdID0gKCkgPT4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgbGV0IGxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyO1xuXG4gICAgaWYgKG9wdGlvbnMubG9nZ2VyID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBjb25zb2xlIGxvZ2dlclxuICAgICAgICBsb2dnZXIgPSBjcmVhdGVEZWZhdWx0TG9nZ2VyKGxldmVscyk7XG4gICAgfVxuXG4gICAgbGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgICByZXNwb25zZVtsZXZlbF0gPSAoZGF0YSwgbWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuX2xvZ0Z1bmMobG9nZ2VyLCBsZXZlbCwgZGVmYXVsdHMsIGRhdGEsIG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufTtcblxuLyoqXG4gKiBXcmFwcGVyIGZvciBjcmVhdGluZyBhIGNhbGxiYWNrIHRoYXQgZWl0aGVyIHJlc29sdmVzIG9yIHJlamVjdHMgYSBwcm9taXNlXG4gKiBiYXNlZCBvbiBpbnB1dFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgRnVuY3Rpb24gdG8gcnVuIGlmIGNhbGxiYWNrIGlzIGNhbGxlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEZ1bmN0aW9uIHRvIHJ1biBpZiBjYWxsYmFjayBlbmRzIHdpdGggYW4gZXJyb3JcbiAqL1xubW9kdWxlLmV4cG9ydHMuY2FsbGJhY2tQcm9taXNlID0gKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgICBsZXQgZXJyID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cy5wYXJzZURhdGFVUkkgPSB1cmkgPT4ge1xuICAgIGxldCBpbnB1dCA9IHVyaTtcbiAgICBsZXQgY29tbWFQb3MgPSBpbnB1dC5pbmRleE9mKCcsJyk7XG4gICAgaWYgKCFjb21tYVBvcykge1xuICAgICAgICByZXR1cm4gdXJpO1xuICAgIH1cblxuICAgIGxldCBkYXRhID0gaW5wdXQuc3Vic3RyaW5nKGNvbW1hUG9zICsgMSk7XG4gICAgbGV0IG1ldGFTdHIgPSBpbnB1dC5zdWJzdHJpbmcoJ2RhdGE6Jy5sZW5ndGgsIGNvbW1hUG9zKTtcblxuICAgIGxldCBlbmNvZGluZztcblxuICAgIGxldCBtZXRhRW50cmllcyA9IG1ldGFTdHIuc3BsaXQoJzsnKTtcbiAgICBsZXQgbGFzdE1ldGFFbnRyeSA9IG1ldGFFbnRyaWVzLmxlbmd0aCA+IDEgPyBtZXRhRW50cmllc1ttZXRhRW50cmllcy5sZW5ndGggLSAxXSA6IGZhbHNlO1xuICAgIGlmIChsYXN0TWV0YUVudHJ5ICYmIGxhc3RNZXRhRW50cnkuaW5kZXhPZignPScpIDwgMCkge1xuICAgICAgICBlbmNvZGluZyA9IGxhc3RNZXRhRW50cnkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbWV0YUVudHJpZXMucG9wKCk7XG4gICAgfVxuXG4gICAgbGV0IGNvbnRlbnRUeXBlID0gbWV0YUVudHJpZXMuc2hpZnQoKSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICBsZXQgcGFyYW1zID0ge307XG4gICAgZm9yIChsZXQgZW50cnkgb2YgbWV0YUVudHJpZXMpIHtcbiAgICAgICAgbGV0IHNlcCA9IGVudHJ5LmluZGV4T2YoJz0nKTtcbiAgICAgICAgaWYgKHNlcCA+PSAwKSB7XG4gICAgICAgICAgICBsZXQga2V5ID0gZW50cnkuc3Vic3RyaW5nKDAsIHNlcCk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBlbnRyeS5zdWJzdHJpbmcoc2VwICsgMSk7XG4gICAgICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd1dGY4JzpcbiAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGVjb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBkYXRhLCBlbmNvZGluZywgY29udGVudFR5cGUsIHBhcmFtcyB9O1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyBhIFN0cmluZyBvciBhIEJ1ZmZlciB2YWx1ZSBmb3IgY29udGVudCB2YWx1ZS4gVXNlZnVsIGlmIHRoZSB2YWx1ZVxuICogaXMgYSBTdHJlYW0gb3IgYSBmaWxlIG9yIGFuIFVSTC4gSWYgdGhlIHZhbHVlIGlzIGEgU3RyZWFtLCBvdmVyd3JpdGVzXG4gKiB0aGUgc3RyZWFtIG9iamVjdCB3aXRoIHRoZSByZXNvbHZlZCB2YWx1ZSAoeW91IGNhbid0IHN0cmVhbSBhIHZhbHVlIHR3aWNlKS5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGNyZWF0ZSBhIHBsdWdpbiB0aGF0IG5lZWRzIGEgY29udGVudCB2YWx1ZSxcbiAqIGZvciBleGFtcGxlIHRoZSBgaHRtbGAgb3IgYHRleHRgIHZhbHVlIGFzIGEgU3RyaW5nIG9yIGEgQnVmZmVyIGJ1dCBub3QgYXNcbiAqIGEgZmlsZSBwYXRoIG9yIGFuIFVSTC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBbiBvYmplY3Qgb3IgYW4gQXJyYXkgeW91IHdhbnQgdG8gcmVzb2x2ZSBhbiBlbGVtZW50IGZvclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXkgUHJvcGVydHkgbmFtZSBvciBhbiBBcnJheSBpbmRleFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gd2l0aCAoZXJyLCB2YWx1ZSlcbiAqL1xubW9kdWxlLmV4cG9ydHMucmVzb2x2ZUNvbnRlbnQgPSAoZGF0YSwga2V5LCBjYWxsYmFjaykgPT4ge1xuICAgIGxldCBwcm9taXNlO1xuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBtb2R1bGUuZXhwb3J0cy5jYWxsYmFja1Byb21pc2UocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IGNvbnRlbnQgPSAoZGF0YSAmJiBkYXRhW2tleV0gJiYgZGF0YVtrZXldLmNvbnRlbnQpIHx8IGRhdGFba2V5XTtcbiAgICBsZXQgY29udGVudFN0cmVhbTtcbiAgICBsZXQgZW5jb2RpbmcgPSAoKHR5cGVvZiBkYXRhW2tleV0gPT09ICdvYmplY3QnICYmIGRhdGFba2V5XS5lbmNvZGluZykgfHwgJ3V0ZjgnKVxuICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAucmVwbGFjZSgvWy1fXFxzXS9nLCAnJyk7XG5cbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvbnRlbnQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50LnBpcGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlU3RyZWFtKGNvbnRlbnQsIChlcnIsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3Qgc3RyZWFtIHR3aWNlIHRoZSBzYW1lIGNvbnRlbnQsIHNvIHdlIG5lZWRcbiAgICAgICAgICAgICAgICAvLyB0byByZXBsYWNlIHRoZSBzdHJlYW0gb2JqZWN0IHdpdGggdGhlIHN0cmVhbWluZyByZXN1bHRcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtrZXldLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrZXldLmNvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoL15odHRwcz86XFwvXFwvL2kudGVzdChjb250ZW50LnBhdGggfHwgY29udGVudC5ocmVmKSkge1xuICAgICAgICAgICAgY29udGVudFN0cmVhbSA9IG5tZmV0Y2goY29udGVudC5wYXRoIHx8IGNvbnRlbnQuaHJlZik7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVN0cmVhbShjb250ZW50U3RyZWFtLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSBpZiAoL15kYXRhOi9pLnRlc3QoY29udGVudC5wYXRoIHx8IGNvbnRlbnQuaHJlZikpIHtcbiAgICAgICAgICAgIGxldCBwYXJzZWREYXRhVXJpID0gbW9kdWxlLmV4cG9ydHMucGFyc2VEYXRhVVJJKGNvbnRlbnQucGF0aCB8fCBjb250ZW50LmhyZWYpO1xuXG4gICAgICAgICAgICBpZiAoIXBhcnNlZERhdGFVcmkgfHwgIXBhcnNlZERhdGFVcmkuZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBCdWZmZXIuZnJvbSgwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcGFyc2VkRGF0YVVyaS5kYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZW50LnBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlU3RyZWFtKGZzLmNyZWF0ZVJlYWRTdHJlYW0oY29udGVudC5wYXRoKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhW2tleV0uY29udGVudCA9PT0gJ3N0cmluZycgJiYgIVsndXRmOCcsICd1c2FzY2lpJywgJ2FzY2lpJ10uaW5jbHVkZXMoZW5jb2RpbmcpKSB7XG4gICAgICAgIGNvbnRlbnQgPSBCdWZmZXIuZnJvbShkYXRhW2tleV0uY29udGVudCwgZW5jb2RpbmcpO1xuICAgIH1cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uLCByZXR1cm4gYXMgaXNcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwgY29udGVudCkpO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIGZyb20gc291cmNlIG9iamVjdHMgdG8gdGFyZ2V0IG9iamVjdHNcbiAqL1xubW9kdWxlLmV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gKC8qIHRhcmdldCwgLi4uIHNvdXJjZXMgKi8pIHtcbiAgICBsZXQgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgICBsZXQgdGFyZ2V0ID0gYXJncy5zaGlmdCgpIHx8IHt9O1xuXG4gICAgYXJncy5mb3JFYWNoKHNvdXJjZSA9PiB7XG4gICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKFsndGxzJywgJ2F1dGgnXS5pbmNsdWRlcyhrZXkpICYmIHNvdXJjZVtrZXldICYmIHR5cGVvZiBzb3VyY2Vba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyB0bHMgYW5kIGF1dGggYXJlIHNwZWNpYWwga2V5cyB0aGF0IG5lZWQgdG8gYmUgZW51bWVyYXRlZCBzZXBhcmF0ZWx5XG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgb2JqZWN0cyBhcmUgcGFzc2VkIGFzIGlzXG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB0YXJnZXQgaGFzIHRoaXMga2V5XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZVtrZXldKS5mb3JFYWNoKHN1YktleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldW3N1YktleV0gPSBzb3VyY2Vba2V5XVtzdWJLZXldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMuZW5jb2RlWFRleHQgPSBzdHIgPT4ge1xuICAgIC8vICEgMHgyMVxuICAgIC8vICsgMHgyQlxuICAgIC8vID0gMHgzRFxuICAgIC8vIH4gMHg3RVxuICAgIGlmICghL1teXFx4MjEtXFx4MkFcXHgyQy1cXHgzQ1xceDNFLVxceDdFXS8udGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGxldCBidWYgPSBCdWZmZXIuZnJvbShzdHIpO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCBjID0gYnVmW2ldO1xuICAgICAgICBpZiAoYyA8IDB4MjEgfHwgYyA+IDB4N2UgfHwgYyA9PT0gMHgyYiB8fCBjID09PSAweDNkKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJysnICsgKGMgPCAweDEwID8gJzAnIDogJycpICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFN0cmVhbXMgYSBzdHJlYW0gdmFsdWUgaW50byBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW0gUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB3aXRoIChlcnIsIHZhbHVlKVxuICovXG5mdW5jdGlvbiByZXNvbHZlU3RyZWFtKHN0cmVhbSwgY2FsbGJhY2spIHtcbiAgICBsZXQgcmVzcG9uZGVkID0gZmFsc2U7XG4gICAgbGV0IGNodW5rcyA9IFtdO1xuICAgIGxldCBjaHVua2xlbiA9IDA7XG5cbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzcG9uZGVkID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHN0cmVhbS5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgd2hpbGUgKChjaHVuayA9IHN0cmVhbS5yZWFkKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICBjaHVua2xlbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uZGVkID0gdHJ1ZTtcblxuICAgICAgICBsZXQgdmFsdWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gQnVmZmVyLmNvbmNhdChjaHVua3MsIGNodW5rbGVuKTtcbiAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEUpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHZhbHVlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBidW55YW4tbGlrZSBsb2dnZXIgdGhhdCBwcmludHMgdG8gY29uc29sZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IEJ1bnlhbiBsb2dnZXIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdExvZ2dlcihsZXZlbHMpIHtcbiAgICBsZXQgbGV2ZWxNYXhMZW4gPSAwO1xuICAgIGxldCBsZXZlbE5hbWVzID0gbmV3IE1hcCgpO1xuICAgIGxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgICAgaWYgKGxldmVsLmxlbmd0aCA+IGxldmVsTWF4TGVuKSB7XG4gICAgICAgICAgICBsZXZlbE1heExlbiA9IGxldmVsLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgICBsZXQgbGV2ZWxOYW1lID0gbGV2ZWwudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGxldmVsTmFtZS5sZW5ndGggPCBsZXZlbE1heExlbikge1xuICAgICAgICAgICAgbGV2ZWxOYW1lICs9ICcgJy5yZXBlYXQobGV2ZWxNYXhMZW4gLSBsZXZlbE5hbWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXZlbE5hbWVzLnNldChsZXZlbCwgbGV2ZWxOYW1lKTtcbiAgICB9KTtcblxuICAgIGxldCBwcmludCA9IChsZXZlbCwgZW50cnksIG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgbGV0IHByZWZpeCA9ICcnO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS50bnggPT09ICdzZXJ2ZXInKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJ1M6ICc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVudHJ5LnRueCA9PT0gJ2NsaWVudCcpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnQzogJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVudHJ5LnNpZCkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICdbJyArIGVudHJ5LnNpZCArICddICcgKyBwcmVmaXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbnRyeS5jaWQpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAnWyMnICsgZW50cnkuY2lkICsgJ10gJyArIHByZWZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lc3NhZ2UgPSB1dGlsLmZvcm1hdChtZXNzYWdlLCAuLi5hcmdzKTtcbiAgICAgICAgbWVzc2FnZS5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnWyVzXSAlcyAlcycsIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zdWJzdHIoMCwgMTkpLnJlcGxhY2UoL1QvLCAnICcpLCBsZXZlbE5hbWVzLmdldChsZXZlbCksIHByZWZpeCArIGxpbmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgbGV0IGxvZ2dlciA9IHt9O1xuICAgIGxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgICAgbG9nZ2VyW2xldmVsXSA9IHByaW50LmJpbmQobnVsbCwgbGV2ZWwpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxvZ2dlcjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/shared/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/smtp-connection/data-stream.js":
/*!********************************************************************!*\
  !*** ./node_modules/nodemailer/lib/smtp-connection/data-stream.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst Transform = stream.Transform;\n\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\nclass DataStream extends Transform {\n    constructor(options) {\n        super(options);\n        // init Transform\n        this.options = options || {};\n        this._curLine = '';\n\n        this.inByteCount = 0;\n        this.outByteCount = 0;\n        this.lastByte = false;\n    }\n\n    /**\n     * Escapes dots\n     */\n    _transform(chunk, encoding, done) {\n        let chunks = [];\n        let chunklen = 0;\n        let i,\n            len,\n            lastPos = 0;\n        let buf;\n\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk);\n        }\n\n        this.inByteCount += chunk.length;\n\n        for (i = 0, len = chunk.length; i < len; i++) {\n            if (chunk[i] === 0x2e) {\n                // .\n                if ((i && chunk[i - 1] === 0x0a) || (!i && (!this.lastByte || this.lastByte === 0x0a))) {\n                    buf = chunk.slice(lastPos, i + 1);\n                    chunks.push(buf);\n                    chunks.push(Buffer.from('.'));\n                    chunklen += buf.length + 1;\n                    lastPos = i + 1;\n                }\n            } else if (chunk[i] === 0x0a) {\n                // .\n                if ((i && chunk[i - 1] !== 0x0d) || (!i && this.lastByte !== 0x0d)) {\n                    if (i > lastPos) {\n                        buf = chunk.slice(lastPos, i);\n                        chunks.push(buf);\n                        chunklen += buf.length + 2;\n                    } else {\n                        chunklen += 2;\n                    }\n                    chunks.push(Buffer.from('\\r\\n'));\n                    lastPos = i + 1;\n                }\n            }\n        }\n\n        if (chunklen) {\n            // add last piece\n            if (lastPos < chunk.length) {\n                buf = chunk.slice(lastPos);\n                chunks.push(buf);\n                chunklen += buf.length;\n            }\n\n            this.outByteCount += chunklen;\n            this.push(Buffer.concat(chunks, chunklen));\n        } else {\n            this.outByteCount += chunk.length;\n            this.push(chunk);\n        }\n\n        this.lastByte = chunk[chunk.length - 1];\n        done();\n    }\n\n    /**\n     * Finalizes the stream with a dot on a single line\n     */\n    _flush(done) {\n        let buf;\n        if (this.lastByte === 0x0a) {\n            buf = Buffer.from('.\\r\\n');\n        } else if (this.lastByte === 0x0d) {\n            buf = Buffer.from('\\n.\\r\\n');\n        } else {\n            buf = Buffer.from('\\r\\n.\\r\\n');\n        }\n        this.outByteCount += buf.length;\n        this.push(buf);\n        done();\n    }\n}\n\nmodule.exports = DataStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc210cC1jb25uZWN0aW9uL2RhdGEtc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VtYXJrZXQvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc210cC1jb25uZWN0aW9uL2RhdGEtc3RyZWFtLmpzPzQzMjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IFRyYW5zZm9ybSA9IHN0cmVhbS5UcmFuc2Zvcm07XG5cbi8qKlxuICogRXNjYXBlcyBkb3RzIGluIHRoZSBiZWdpbm5pbmcgb2YgbGluZXMuIEVuZHMgdGhlIHN0cmVhbSB3aXRoIDxDUj48TEY+LjxDUj48TEY+XG4gKiBBbHNvIG1ha2VzIHN1cmUgdGhhdCBvbmx5IDxDUj48TEY+IHNlcXVlbmNlcyBhcmUgdXNlZCBmb3IgbGluZWJyZWFrc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFN0cmVhbSBvcHRpb25zXG4gKi9cbmNsYXNzIERhdGFTdHJlYW0gZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIC8vIGluaXQgVHJhbnNmb3JtXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuX2N1ckxpbmUgPSAnJztcblxuICAgICAgICB0aGlzLmluQnl0ZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5vdXRCeXRlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RCeXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlcyBkb3RzXG4gICAgICovXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICAgICAgbGV0IGNodW5rcyA9IFtdO1xuICAgICAgICBsZXQgY2h1bmtsZW4gPSAwO1xuICAgICAgICBsZXQgaSxcbiAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgIGxhc3RQb3MgPSAwO1xuICAgICAgICBsZXQgYnVmO1xuXG4gICAgICAgIGlmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5CeXRlQ291bnQgKz0gY2h1bmsubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNodW5rLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmtbaV0gPT09IDB4MmUpIHtcbiAgICAgICAgICAgICAgICAvLyAuXG4gICAgICAgICAgICAgICAgaWYgKChpICYmIGNodW5rW2kgLSAxXSA9PT0gMHgwYSkgfHwgKCFpICYmICghdGhpcy5sYXN0Qnl0ZSB8fCB0aGlzLmxhc3RCeXRlID09PSAweDBhKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmID0gY2h1bmsuc2xpY2UobGFzdFBvcywgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChidWYpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChCdWZmZXIuZnJvbSgnLicpKTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtsZW4gKz0gYnVmLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNodW5rW2ldID09PSAweDBhKSB7XG4gICAgICAgICAgICAgICAgLy8gLlxuICAgICAgICAgICAgICAgIGlmICgoaSAmJiBjaHVua1tpIC0gMV0gIT09IDB4MGQpIHx8ICghaSAmJiB0aGlzLmxhc3RCeXRlICE9PSAweDBkKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IGxhc3RQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGNodW5rLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goYnVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rbGVuICs9IGJ1Zi5sZW5ndGggKyAyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtsZW4gKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChCdWZmZXIuZnJvbSgnXFxyXFxuJykpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNodW5rbGVuKSB7XG4gICAgICAgICAgICAvLyBhZGQgbGFzdCBwaWVjZVxuICAgICAgICAgICAgaWYgKGxhc3RQb3MgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBidWYgPSBjaHVuay5zbGljZShsYXN0UG9zKTtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChidWYpO1xuICAgICAgICAgICAgICAgIGNodW5rbGVuICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub3V0Qnl0ZUNvdW50ICs9IGNodW5rbGVuO1xuICAgICAgICAgICAgdGhpcy5wdXNoKEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBjaHVua2xlbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vdXRCeXRlQ291bnQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5wdXNoKGNodW5rKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdEJ5dGUgPSBjaHVua1tjaHVuay5sZW5ndGggLSAxXTtcbiAgICAgICAgZG9uZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmFsaXplcyB0aGUgc3RyZWFtIHdpdGggYSBkb3Qgb24gYSBzaW5nbGUgbGluZVxuICAgICAqL1xuICAgIF9mbHVzaChkb25lKSB7XG4gICAgICAgIGxldCBidWY7XG4gICAgICAgIGlmICh0aGlzLmxhc3RCeXRlID09PSAweDBhKSB7XG4gICAgICAgICAgICBidWYgPSBCdWZmZXIuZnJvbSgnLlxcclxcbicpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFzdEJ5dGUgPT09IDB4MGQpIHtcbiAgICAgICAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKCdcXG4uXFxyXFxuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWYgPSBCdWZmZXIuZnJvbSgnXFxyXFxuLlxcclxcbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0Qnl0ZUNvdW50ICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaChidWYpO1xuICAgICAgICBkb25lKCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTdHJlYW07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/smtp-connection/data-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js":
/*!**************************************************************************!*\
  !*** ./node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/**\n * Minimal HTTP/S proxy client\n */\n\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst urllib = __webpack_require__(/*! url */ \"url\");\n\n/**\n * Establishes proxied connection to destinationPort\n *\n * httpProxyClient(\"http://localhost:3128/\", 80, \"google.com\", function(err, socket){\n *     socket.write(\"GET / HTTP/1.0\\r\\n\\r\\n\");\n * });\n *\n * @param {String} proxyUrl proxy configuration, etg \"http://proxy.host:3128/\"\n * @param {Number} destinationPort Port to open in destination host\n * @param {String} destinationHost Destination hostname\n * @param {Function} callback Callback to run with the rocket object once connection is established\n */\nfunction httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {\n    let proxy = urllib.parse(proxyUrl);\n\n    // create a socket connection to the proxy server\n    let options;\n    let connect;\n    let socket;\n\n    options = {\n        host: proxy.hostname,\n        port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === 'https:' ? 443 : 80\n    };\n\n    if (proxy.protocol === 'https:') {\n        // we can use untrusted proxies as long as we verify actual SMTP certificates\n        options.rejectUnauthorized = false;\n        connect = tls.connect.bind(tls);\n    } else {\n        connect = net.connect.bind(net);\n    }\n\n    // Error harness for initial connection. Once connection is established, the responsibility\n    // to handle errors is passed to whoever uses this socket\n    let finished = false;\n    let tempSocketErr = err => {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        try {\n            socket.destroy();\n        } catch (E) {\n            // ignore\n        }\n        callback(err);\n    };\n\n    let timeoutErr = () => {\n        let err = new Error('Proxy socket timed out');\n        err.code = 'ETIMEDOUT';\n        tempSocketErr(err);\n    };\n\n    socket = connect(options, () => {\n        if (finished) {\n            return;\n        }\n\n        let reqHeaders = {\n            Host: destinationHost + ':' + destinationPort,\n            Connection: 'close'\n        };\n        if (proxy.auth) {\n            reqHeaders['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');\n        }\n\n        socket.write(\n            // HTTP method\n            'CONNECT ' +\n                destinationHost +\n                ':' +\n                destinationPort +\n                ' HTTP/1.1\\r\\n' +\n                // HTTP request headers\n                Object.keys(reqHeaders)\n                    .map(key => key + ': ' + reqHeaders[key])\n                    .join('\\r\\n') +\n                // End request\n                '\\r\\n\\r\\n'\n        );\n\n        let headers = '';\n        let onSocketData = chunk => {\n            let match;\n            let remainder;\n\n            if (finished) {\n                return;\n            }\n\n            headers += chunk.toString('binary');\n            if ((match = headers.match(/\\r\\n\\r\\n/))) {\n                socket.removeListener('data', onSocketData);\n\n                remainder = headers.substr(match.index + match[0].length);\n                headers = headers.substr(0, match.index);\n                if (remainder) {\n                    socket.unshift(Buffer.from(remainder, 'binary'));\n                }\n\n                // proxy connection is now established\n                finished = true;\n\n                // check response code\n                match = headers.match(/^HTTP\\/\\d+\\.\\d+ (\\d+)/i);\n                if (!match || (match[1] || '').charAt(0) !== '2') {\n                    try {\n                        socket.destroy();\n                    } catch (E) {\n                        // ignore\n                    }\n                    return callback(new Error('Invalid response from proxy' + ((match && ': ' + match[1]) || '')));\n                }\n\n                socket.removeListener('error', tempSocketErr);\n                socket.removeListener('timeout', timeoutErr);\n                socket.setTimeout(0);\n\n                return callback(null, socket);\n            }\n        };\n        socket.on('data', onSocketData);\n    });\n\n    socket.setTimeout(httpProxyClient.timeout || 30 * 1000);\n    socket.on('timeout', timeoutErr);\n\n    socket.once('error', tempSocketErr);\n}\n\nmodule.exports = httpProxyClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc210cC1jb25uZWN0aW9uL2h0dHAtcHJveHktY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGVBQWUsbUJBQU8sQ0FBQyxnQkFBSzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlbWFya2V0Ly4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL3NtdHAtY29ubmVjdGlvbi9odHRwLXByb3h5LWNsaWVudC5qcz8yMzBiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNaW5pbWFsIEhUVFAvUyBwcm94eSBjbGllbnRcbiAqL1xuXG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgdXJsbGliID0gcmVxdWlyZSgndXJsJyk7XG5cbi8qKlxuICogRXN0YWJsaXNoZXMgcHJveGllZCBjb25uZWN0aW9uIHRvIGRlc3RpbmF0aW9uUG9ydFxuICpcbiAqIGh0dHBQcm94eUNsaWVudChcImh0dHA6Ly9sb2NhbGhvc3Q6MzEyOC9cIiwgODAsIFwiZ29vZ2xlLmNvbVwiLCBmdW5jdGlvbihlcnIsIHNvY2tldCl7XG4gKiAgICAgc29ja2V0LndyaXRlKFwiR0VUIC8gSFRUUC8xLjBcXHJcXG5cXHJcXG5cIik7XG4gKiB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJveHlVcmwgcHJveHkgY29uZmlndXJhdGlvbiwgZXRnIFwiaHR0cDovL3Byb3h5Lmhvc3Q6MzEyOC9cIlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlc3RpbmF0aW9uUG9ydCBQb3J0IHRvIG9wZW4gaW4gZGVzdGluYXRpb24gaG9zdFxuICogQHBhcmFtIHtTdHJpbmd9IGRlc3RpbmF0aW9uSG9zdCBEZXN0aW5hdGlvbiBob3N0bmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuIHdpdGggdGhlIHJvY2tldCBvYmplY3Qgb25jZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkXG4gKi9cbmZ1bmN0aW9uIGh0dHBQcm94eUNsaWVudChwcm94eVVybCwgZGVzdGluYXRpb25Qb3J0LCBkZXN0aW5hdGlvbkhvc3QsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHByb3h5ID0gdXJsbGliLnBhcnNlKHByb3h5VXJsKTtcblxuICAgIC8vIGNyZWF0ZSBhIHNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBwcm94eSBzZXJ2ZXJcbiAgICBsZXQgb3B0aW9ucztcbiAgICBsZXQgY29ubmVjdDtcbiAgICBsZXQgc29ja2V0O1xuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgICAgaG9zdDogcHJveHkuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IE51bWJlcihwcm94eS5wb3J0KSA/IE51bWJlcihwcm94eS5wb3J0KSA6IHByb3h5LnByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwXG4gICAgfTtcblxuICAgIGlmIChwcm94eS5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgLy8gd2UgY2FuIHVzZSB1bnRydXN0ZWQgcHJveGllcyBhcyBsb25nIGFzIHdlIHZlcmlmeSBhY3R1YWwgU01UUCBjZXJ0aWZpY2F0ZXNcbiAgICAgICAgb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgPSBmYWxzZTtcbiAgICAgICAgY29ubmVjdCA9IHRscy5jb25uZWN0LmJpbmQodGxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25uZWN0ID0gbmV0LmNvbm5lY3QuYmluZChuZXQpO1xuICAgIH1cblxuICAgIC8vIEVycm9yIGhhcm5lc3MgZm9yIGluaXRpYWwgY29ubmVjdGlvbi4gT25jZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCB0aGUgcmVzcG9uc2liaWxpdHlcbiAgICAvLyB0byBoYW5kbGUgZXJyb3JzIGlzIHBhc3NlZCB0byB3aG9ldmVyIHVzZXMgdGhpcyBzb2NrZXRcbiAgICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcbiAgICBsZXQgdGVtcFNvY2tldEVyciA9IGVyciA9PiB7XG4gICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfTtcblxuICAgIGxldCB0aW1lb3V0RXJyID0gKCkgPT4ge1xuICAgICAgICBsZXQgZXJyID0gbmV3IEVycm9yKCdQcm94eSBzb2NrZXQgdGltZWQgb3V0Jyk7XG4gICAgICAgIGVyci5jb2RlID0gJ0VUSU1FRE9VVCc7XG4gICAgICAgIHRlbXBTb2NrZXRFcnIoZXJyKTtcbiAgICB9O1xuXG4gICAgc29ja2V0ID0gY29ubmVjdChvcHRpb25zLCAoKSA9PiB7XG4gICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlcUhlYWRlcnMgPSB7XG4gICAgICAgICAgICBIb3N0OiBkZXN0aW5hdGlvbkhvc3QgKyAnOicgKyBkZXN0aW5hdGlvblBvcnQsXG4gICAgICAgICAgICBDb25uZWN0aW9uOiAnY2xvc2UnXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm94eS5hdXRoKSB7XG4gICAgICAgICAgICByZXFIZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPSAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKHByb3h5LmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvY2tldC53cml0ZShcbiAgICAgICAgICAgIC8vIEhUVFAgbWV0aG9kXG4gICAgICAgICAgICAnQ09OTkVDVCAnICtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkhvc3QgK1xuICAgICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25Qb3J0ICtcbiAgICAgICAgICAgICAgICAnIEhUVFAvMS4xXFxyXFxuJyArXG4gICAgICAgICAgICAgICAgLy8gSFRUUCByZXF1ZXN0IGhlYWRlcnNcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyZXFIZWFkZXJzKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGtleSA9PiBrZXkgKyAnOiAnICsgcmVxSGVhZGVyc1trZXldKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignXFxyXFxuJykgK1xuICAgICAgICAgICAgICAgIC8vIEVuZCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgJ1xcclxcblxcclxcbidcbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgaGVhZGVycyA9ICcnO1xuICAgICAgICBsZXQgb25Tb2NrZXREYXRhID0gY2h1bmsgPT4ge1xuICAgICAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICAgICAgbGV0IHJlbWFpbmRlcjtcblxuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoZWFkZXJzICs9IGNodW5rLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgICAgICAgIGlmICgobWF0Y2ggPSBoZWFkZXJzLm1hdGNoKC9cXHJcXG5cXHJcXG4vKSkpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvblNvY2tldERhdGEpO1xuXG4gICAgICAgICAgICAgICAgcmVtYWluZGVyID0gaGVhZGVycy5zdWJzdHIobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBoZWFkZXJzLnN1YnN0cigwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbWFpbmRlcikge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQudW5zaGlmdChCdWZmZXIuZnJvbShyZW1haW5kZXIsICdiaW5hcnknKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcHJveHkgY29ubmVjdGlvbiBpcyBub3cgZXN0YWJsaXNoZWRcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayByZXNwb25zZSBjb2RlXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBoZWFkZXJzLm1hdGNoKC9eSFRUUFxcL1xcZCtcXC5cXGQrIChcXGQrKS9pKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoIHx8IChtYXRjaFsxXSB8fCAnJykuY2hhckF0KDApICE9PSAnMicpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0ludmFsaWQgcmVzcG9uc2UgZnJvbSBwcm94eScgKyAoKG1hdGNoICYmICc6ICcgKyBtYXRjaFsxXSkgfHwgJycpKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHRlbXBTb2NrZXRFcnIpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcigndGltZW91dCcsIHRpbWVvdXRFcnIpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHNvY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNvY2tldC5vbignZGF0YScsIG9uU29ja2V0RGF0YSk7XG4gICAgfSk7XG5cbiAgICBzb2NrZXQuc2V0VGltZW91dChodHRwUHJveHlDbGllbnQudGltZW91dCB8fCAzMCAqIDEwMDApO1xuICAgIHNvY2tldC5vbigndGltZW91dCcsIHRpbWVvdXRFcnIpO1xuXG4gICAgc29ja2V0Lm9uY2UoJ2Vycm9yJywgdGVtcFNvY2tldEVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHR0cFByb3h5Q2xpZW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/smtp-connection/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/nodemailer/lib/smtp-connection/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst packageInfo = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/nodemailer/package.json\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst DataStream = __webpack_require__(/*! ./data-stream */ \"(rsc)/./node_modules/nodemailer/lib/smtp-connection/data-stream.js\");\nconst PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nconst shared = __webpack_require__(/*! ../shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\");\n\n// default timeout values in ms\nconst CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\nconst SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\nconst GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\nconst DNS_TIMEOUT = 30 * 1000; // how much to wait for resolveHostname\n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **dnsTimeout** - Time to wait in ms for the DNS requests to be resolved (defaults to 30 seconds)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\nclass SMTPConnection extends EventEmitter {\n    constructor(options) {\n        super(options);\n\n        this.id = crypto.randomBytes(8).toString('base64').replace(/\\W/g, '');\n        this.stage = 'init';\n\n        this.options = options || {};\n\n        this.secureConnection = !!this.options.secure;\n        this.alreadySecured = !!this.options.secured;\n\n        this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);\n        this.host = this.options.host || 'localhost';\n\n        this.servername = this.options.servername ? this.options.servername : !net.isIP(this.host) ? this.host : false;\n\n        this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;\n\n        if (typeof this.options.secure === 'undefined' && this.port === 465) {\n            // if secure option is not set but port is 465, then default to secure\n            this.secureConnection = true;\n        }\n\n        this.name = this.options.name || this._getHostname();\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-connection',\n            sid: this.id\n        });\n\n        this.customAuth = new Map();\n        Object.keys(this.options.customAuth || {}).forEach(key => {\n            let mapKey = (key || '').toString().trim().toUpperCase();\n            if (!mapKey) {\n                return;\n            }\n            this.customAuth.set(mapKey, this.options.customAuth[key]);\n        });\n\n        /**\n         * Expose version nr, just for the reference\n         * @type {String}\n         */\n        this.version = packageInfo.version;\n\n        /**\n         * If true, then the user is authenticated\n         * @type {Boolean}\n         */\n        this.authenticated = false;\n\n        /**\n         * If set to true, this instance is no longer active\n         * @private\n         */\n        this.destroyed = false;\n\n        /**\n         * Defines if the current connection is secure or not. If not,\n         * STARTTLS can be used if available\n         * @private\n         */\n        this.secure = !!this.secureConnection;\n\n        /**\n         * Store incomplete messages coming from the server\n         * @private\n         */\n        this._remainder = '';\n\n        /**\n         * Unprocessed responses from the server\n         * @type {Array}\n         */\n        this._responseQueue = [];\n\n        this.lastServerResponse = false;\n\n        /**\n         * The socket connecting to the server\n         * @publick\n         */\n        this._socket = false;\n\n        /**\n         * Lists supported auth mechanisms\n         * @private\n         */\n        this._supportedAuth = [];\n\n        /**\n         * Set to true, if EHLO response includes \"AUTH\".\n         * If false then authentication is not tried\n         */\n        this.allowsAuth = false;\n\n        /**\n         * Includes current envelope (from, to)\n         * @private\n         */\n        this._envelope = false;\n\n        /**\n         * Lists supported extensions\n         * @private\n         */\n        this._supportedExtensions = [];\n\n        /**\n         * Defines the maximum allowed size for a single message\n         * @private\n         */\n        this._maxAllowedSize = 0;\n\n        /**\n         * Function queue to run if a data chunk comes from the server\n         * @private\n         */\n        this._responseActions = [];\n        this._recipientQueue = [];\n\n        /**\n         * Timeout variable for waiting the greeting\n         * @private\n         */\n        this._greetingTimeout = false;\n\n        /**\n         * Timeout variable for waiting the connection to start\n         * @private\n         */\n        this._connectionTimeout = false;\n\n        /**\n         * If the socket is deemed already closed\n         * @private\n         */\n        this._destroyed = false;\n\n        /**\n         * If the socket is already being closed\n         * @private\n         */\n        this._closing = false;\n\n        /**\n         * Callbacks for socket's listeners\n         */\n        this._onSocketData = chunk => this._onData(chunk);\n        this._onSocketError = error => this._onError(error, 'ESOCKET', false, 'CONN');\n        this._onSocketClose = () => this._onClose();\n        this._onSocketEnd = () => this._onEnd();\n        this._onSocketTimeout = () => this._onTimeout();\n    }\n\n    /**\n     * Creates a connection to a SMTP server and sets up connection\n     * listener\n     */\n    connect(connectCallback) {\n        if (typeof connectCallback === 'function') {\n            this.once('connect', () => {\n                this.logger.debug(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'SMTP handshake finished'\n                );\n                connectCallback();\n            });\n\n            const isDestroyedMessage = this._isDestroyedMessage('connect');\n            if (isDestroyedMessage) {\n                return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));\n            }\n        }\n\n        let opts = {\n            port: this.port,\n            host: this.host,\n            allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,\n            timeout: this.options.dnsTimeout || DNS_TIMEOUT\n        };\n\n        if (this.options.localAddress) {\n            opts.localAddress = this.options.localAddress;\n        }\n\n        let setupConnectionHandlers = () => {\n            this._connectionTimeout = setTimeout(() => {\n                this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n            }, this.options.connectionTimeout || CONNECTION_TIMEOUT);\n\n            this._socket.on('error', this._onSocketError);\n        };\n\n        if (this.options.connection) {\n            // connection is already opened\n            this._socket = this.options.connection;\n            if (this.secureConnection && !this.alreadySecured) {\n                setImmediate(() =>\n                    this._upgradeConnection(err => {\n                        if (err) {\n                            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n                            return;\n                        }\n                        this._onConnect();\n                    })\n                );\n            } else {\n                setImmediate(() => this._onConnect());\n            }\n            return;\n        } else if (this.options.socket) {\n            // socket object is set up but not yet connected\n            this._socket = this.options.socket;\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved.cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved.cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket.connect(this.port, this.host, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        } else if (this.secureConnection) {\n            // connect using tls\n            if (this.options.tls) {\n                Object.keys(this.options.tls).forEach(key => {\n                    opts[key] = this.options.tls[key];\n                });\n            }\n\n            // ensure servername for SNI\n            if (this.servername && !opts.servername) {\n                opts.servername = this.servername;\n            }\n\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved.cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved.cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket = tls.connect(opts, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        } else {\n            // connect using plaintext\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved.cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved.cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket = net.connect(opts, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        }\n    }\n\n    /**\n     * Sends QUIT\n     */\n    quit() {\n        this._sendCommand('QUIT');\n        this._responseActions.push(this.close);\n    }\n\n    /**\n     * Closes the connection to the server\n     */\n    close() {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n        this._responseActions = [];\n\n        // allow to run this function only once\n        if (this._closing) {\n            return;\n        }\n        this._closing = true;\n\n        let closeMethod = 'end';\n\n        if (this.stage === 'init') {\n            // Close the socket immediately when connection timed out\n            closeMethod = 'destroy';\n        }\n\n        this.logger.debug(\n            {\n                tnx: 'smtp'\n            },\n            'Closing connection to the server using \"%s\"',\n            closeMethod\n        );\n\n        let socket = (this._socket && this._socket.socket) || this._socket;\n\n        if (socket && !socket.destroyed) {\n            try {\n                this._socket[closeMethod]();\n            } catch (E) {\n                // just ignore\n            }\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * Authenticate user\n     */\n    login(authData, callback) {\n        const isDestroyedMessage = this._isDestroyedMessage('login');\n        if (isDestroyedMessage) {\n            return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        this._auth = authData || {};\n        // Select SASL authentication method\n        this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;\n\n        if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n            this._authMethod = 'XOAUTH2';\n        } else if (!this._authMethod || (this._authMethod === 'XOAUTH2' && !this._auth.oauth2)) {\n            // use first supported\n            this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n        }\n\n        if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {\n            if ((this._auth.user && this._auth.pass) || this.customAuth.has(this._authMethod)) {\n                this._auth.credentials = {\n                    user: this._auth.user,\n                    pass: this._auth.pass,\n                    options: this._auth.options\n                };\n            } else {\n                return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n            }\n        }\n\n        if (this.customAuth.has(this._authMethod)) {\n            let handler = this.customAuth.get(this._authMethod);\n            let lastResponse;\n            let returned = false;\n\n            let resolve = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                this.logger.info(\n                    {\n                        tnx: 'smtp',\n                        username: this._auth.user,\n                        action: 'authenticated',\n                        method: this._authMethod\n                    },\n                    'User %s authenticated',\n                    JSON.stringify(this._auth.user)\n                );\n                this.authenticated = true;\n                callback(null, true);\n            };\n\n            let reject = err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                callback(this._formatError(err, 'EAUTH', lastResponse, 'AUTH ' + this._authMethod));\n            };\n\n            let handlerResponse = handler({\n                auth: this._auth,\n                method: this._authMethod,\n\n                extensions: [].concat(this._supportedExtensions),\n                authMethods: [].concat(this._supportedAuth),\n                maxAllowedSize: this._maxAllowedSize || false,\n\n                sendCommand: (cmd, done) => {\n                    let promise;\n\n                    if (!done) {\n                        promise = new Promise((resolve, reject) => {\n                            done = shared.callbackPromise(resolve, reject);\n                        });\n                    }\n\n                    this._responseActions.push(str => {\n                        lastResponse = str;\n\n                        let codes = str.match(/^(\\d+)(?:\\s(\\d+\\.\\d+\\.\\d+))?\\s/);\n                        let data = {\n                            command: cmd,\n                            response: str\n                        };\n                        if (codes) {\n                            data.status = Number(codes[1]) || 0;\n                            if (codes[2]) {\n                                data.code = codes[2];\n                            }\n                            data.text = str.substr(codes[0].length);\n                        } else {\n                            data.text = str;\n                            data.status = 0; // just in case we need to perform numeric comparisons\n                        }\n                        done(null, data);\n                    });\n                    setImmediate(() => this._sendCommand(cmd));\n\n                    return promise;\n                },\n\n                resolve,\n                reject\n            });\n\n            if (handlerResponse && typeof handlerResponse.catch === 'function') {\n                // a promise was returned\n                handlerResponse.then(resolve).catch(reject);\n            }\n\n            return;\n        }\n\n        switch (this._authMethod) {\n            case 'XOAUTH2':\n                this._handleXOauth2Token(false, callback);\n                return;\n            case 'LOGIN':\n                this._responseActions.push(str => {\n                    this._actionAUTH_LOGIN_USER(str, callback);\n                });\n                this._sendCommand('AUTH LOGIN');\n                return;\n            case 'PLAIN':\n                this._responseActions.push(str => {\n                    this._actionAUTHComplete(str, callback);\n                });\n                this._sendCommand(\n                    'AUTH PLAIN ' +\n                        Buffer.from(\n                            //this._auth.user+'\\u0000'+\n                            '\\u0000' + // skip authorization identity as it causes problems with some servers\n                                this._auth.credentials.user +\n                                '\\u0000' +\n                                this._auth.credentials.pass,\n                            'utf-8'\n                        ).toString('base64'),\n                    // log entry without passwords\n                    'AUTH PLAIN ' +\n                        Buffer.from(\n                            //this._auth.user+'\\u0000'+\n                            '\\u0000' + // skip authorization identity as it causes problems with some servers\n                                this._auth.credentials.user +\n                                '\\u0000' +\n                                '/* secret */',\n                            'utf-8'\n                        ).toString('base64')\n                );\n                return;\n            case 'CRAM-MD5':\n                this._responseActions.push(str => {\n                    this._actionAUTH_CRAM_MD5(str, callback);\n                });\n                this._sendCommand('AUTH CRAM-MD5');\n                return;\n        }\n\n        return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n    }\n\n    /**\n     * Sends a message\n     *\n     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n     * @param {Object} message String, Buffer or a Stream\n     * @param {Function} callback Callback to return once sending is completed\n     */\n    send(envelope, message, done) {\n        if (!message) {\n            return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n        }\n\n        const isDestroyedMessage = this._isDestroyedMessage('send message');\n        if (isDestroyedMessage) {\n            return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        // reject larger messages than allowed\n        if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n            return setImmediate(() => {\n                done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n            });\n        }\n\n        // ensure that callback is only called once\n        let returned = false;\n        let callback = function () {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            done(...arguments);\n        };\n\n        if (typeof message.on === 'function') {\n            message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));\n        }\n\n        let startTime = Date.now();\n        this._setEnvelope(envelope, (err, info) => {\n            if (err) {\n                return callback(err);\n            }\n            let envelopeTime = Date.now();\n            let stream = this._createSendStream((err, str) => {\n                if (err) {\n                    return callback(err);\n                }\n\n                info.envelopeTime = envelopeTime - startTime;\n                info.messageTime = Date.now() - envelopeTime;\n                info.messageSize = stream.outByteCount;\n                info.response = str;\n\n                return callback(null, info);\n            });\n            if (typeof message.pipe === 'function') {\n                message.pipe(stream);\n            } else {\n                stream.write(message);\n                stream.end();\n            }\n        });\n    }\n\n    /**\n     * Resets connection state\n     *\n     * @param {Function} callback Callback to return once connection is reset\n     */\n    reset(callback) {\n        this._sendCommand('RSET');\n        this._responseActions.push(str => {\n            if (str.charAt(0) !== '2') {\n                return callback(this._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));\n            }\n            this._envelope = false;\n            return callback(null, true);\n        });\n    }\n\n    /**\n     * Connection listener that is run when the connection to\n     * the server is opened\n     *\n     * @event\n     */\n    _onConnect() {\n        clearTimeout(this._connectionTimeout);\n\n        this.logger.info(\n            {\n                tnx: 'network',\n                localAddress: this._socket.localAddress,\n                localPort: this._socket.localPort,\n                remoteAddress: this._socket.remoteAddress,\n                remotePort: this._socket.remotePort\n            },\n            '%s established to %s:%s',\n            this.secure ? 'Secure connection' : 'Connection',\n            this._socket.remoteAddress,\n            this._socket.remotePort\n        );\n\n        if (this._destroyed) {\n            // Connection was established after we already had canceled it\n            this.close();\n            return;\n        }\n\n        this.stage = 'connected';\n\n        // clear existing listeners for the socket\n        this._socket.removeListener('data', this._onSocketData);\n        this._socket.removeListener('timeout', this._onSocketTimeout);\n        this._socket.removeListener('close', this._onSocketClose);\n        this._socket.removeListener('end', this._onSocketEnd);\n\n        this._socket.on('data', this._onSocketData);\n        this._socket.once('close', this._onSocketClose);\n        this._socket.once('end', this._onSocketEnd);\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n        this._socket.on('timeout', this._onSocketTimeout);\n\n        this._greetingTimeout = setTimeout(() => {\n            // if still waiting for greeting, give up\n            if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {\n                this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n            }\n        }, this.options.greetingTimeout || GREETING_TIMEOUT);\n\n        this._responseActions.push(this._actionGreeting);\n\n        // we have a 'data' listener set up so resume socket if it was paused\n        this._socket.resume();\n    }\n\n    /**\n     * 'data' listener for data coming from the server\n     *\n     * @event\n     * @param {Buffer} chunk Data chunk coming from the server\n     */\n    _onData(chunk) {\n        if (this._destroyed || !chunk || !chunk.length) {\n            return;\n        }\n\n        let data = (chunk || '').toString('binary');\n        let lines = (this._remainder + data).split(/\\r?\\n/);\n        let lastline;\n\n        this._remainder = lines.pop();\n\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (this._responseQueue.length) {\n                lastline = this._responseQueue[this._responseQueue.length - 1];\n                if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n                    this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n                    continue;\n                }\n            }\n            this._responseQueue.push(lines[i]);\n        }\n\n        if (this._responseQueue.length) {\n            lastline = this._responseQueue[this._responseQueue.length - 1];\n            if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n                return;\n            }\n        }\n\n        this._processResponse();\n    }\n\n    /**\n     * 'error' listener for the socket\n     *\n     * @event\n     * @param {Error} err Error object\n     * @param {String} type Error name\n     */\n    _onError(err, type, data, command) {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n\n        if (this._destroyed) {\n            // just ignore, already closed\n            // this might happen when a socket is canceled because of reached timeout\n            // but the socket timeout error itself receives only after\n            return;\n        }\n\n        err = this._formatError(err, type, data, command);\n\n        this.logger.error(data, err.message);\n\n        this.emit('error', err);\n        this.close();\n    }\n\n    _formatError(message, type, response, command) {\n        let err;\n\n        if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n            err = message;\n        } else {\n            err = new Error(message);\n        }\n\n        if (type && type !== 'Error') {\n            err.code = type;\n        }\n\n        if (response) {\n            err.response = response;\n            err.message += ': ' + response;\n        }\n\n        let responseCode = (typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0])) || false;\n        if (responseCode) {\n            err.responseCode = responseCode;\n        }\n\n        if (command) {\n            err.command = command;\n        }\n\n        return err;\n    }\n\n    /**\n     * 'close' listener for the socket\n     *\n     * @event\n     */\n    _onClose() {\n        let serverResponse = false;\n\n        if (this._remainder && this._remainder.trim()) {\n            if (this.options.debug || this.options.transactionLog) {\n                this.logger.debug(\n                    {\n                        tnx: 'server'\n                    },\n                    this._remainder.replace(/\\r?\\n$/, '')\n                );\n            }\n            this.lastServerResponse = serverResponse = this._remainder.trim();\n        }\n\n        this.logger.info(\n            {\n                tnx: 'network'\n            },\n            'Connection closed'\n        );\n\n        if (this.upgrading && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', serverResponse, 'CONN');\n        } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', serverResponse, 'CONN');\n        } else if (/^[45]\\d{2}\\b/.test(serverResponse)) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', serverResponse, 'CONN');\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * 'end' listener for the socket\n     *\n     * @event\n     */\n    _onEnd() {\n        if (this._socket && !this._socket.destroyed) {\n            this._socket.destroy();\n        }\n    }\n\n    /**\n     * 'timeout' listener for the socket\n     *\n     * @event\n     */\n    _onTimeout() {\n        return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n    }\n\n    /**\n     * Destroys the client, emits 'end'\n     */\n    _destroy() {\n        if (this._destroyed) {\n            return;\n        }\n        this._destroyed = true;\n        this.emit('end');\n    }\n\n    /**\n     * Upgrades the connection to TLS\n     *\n     * @param {Function} callback Callback function to run when the connection\n     *        has been secured\n     */\n    _upgradeConnection(callback) {\n        // do not remove all listeners or it breaks node v0.10 as there's\n        // apparently a 'finish' event set that would be cleared as well\n\n        // we can safely keep 'error', 'end', 'close' etc. events\n        this._socket.removeListener('data', this._onSocketData); // incoming data is going to be gibberish from this point onwards\n        this._socket.removeListener('timeout', this._onSocketTimeout); // timeout will be re-set for the new socket object\n\n        let socketPlain = this._socket;\n        let opts = {\n            socket: this._socket,\n            host: this.host\n        };\n\n        Object.keys(this.options.tls || {}).forEach(key => {\n            opts[key] = this.options.tls[key];\n        });\n\n        // ensure servername for SNI\n        if (this.servername && !opts.servername) {\n            opts.servername = this.servername;\n        }\n\n        this.upgrading = true;\n        // tls.connect is not an asynchronous function however it may still throw errors and requires to be wrapped with try/catch\n        try {\n            this._socket = tls.connect(opts, () => {\n                this.secure = true;\n                this.upgrading = false;\n                this._socket.on('data', this._onSocketData);\n\n                socketPlain.removeListener('close', this._onSocketClose);\n                socketPlain.removeListener('end', this._onSocketEnd);\n\n                return callback(null, true);\n            });\n        } catch (err) {\n            return callback(err);\n        }\n\n        this._socket.on('error', this._onSocketError);\n        this._socket.once('close', this._onSocketClose);\n        this._socket.once('end', this._onSocketEnd);\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n        this._socket.on('timeout', this._onSocketTimeout);\n\n        // resume in case the socket was paused\n        socketPlain.resume();\n    }\n\n    /**\n     * Processes queued responses from the server\n     *\n     * @param {Boolean} force If true, ignores _processing flag\n     */\n    _processResponse() {\n        if (!this._responseQueue.length) {\n            return false;\n        }\n\n        let str = (this.lastServerResponse = (this._responseQueue.shift() || '').toString());\n\n        if (/^\\d+-/.test(str.split('\\n').pop())) {\n            // keep waiting for the final part of multiline response\n            return;\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'server'\n                },\n                str.replace(/\\r?\\n$/, '')\n            );\n        }\n\n        if (!str.trim()) {\n            // skip unexpected empty lines\n            setImmediate(() => this._processResponse());\n        }\n\n        let action = this._responseActions.shift();\n\n        if (typeof action === 'function') {\n            action.call(this, str);\n            setImmediate(() => this._processResponse());\n        } else {\n            return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n        }\n    }\n\n    /**\n     * Send a command to the server, append \\r\\n\n     *\n     * @param {String} str String to be sent to the server\n     * @param {String} logStr Optional string to be used for logging instead of the actual string\n     */\n    _sendCommand(str, logStr) {\n        if (this._destroyed) {\n            // Connection already closed, can't send any more data\n            return;\n        }\n\n        if (this._socket.destroyed) {\n            return this.close();\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'client'\n                },\n                (logStr || str || '').toString().replace(/\\r?\\n$/, '')\n            );\n        }\n\n        this._socket.write(Buffer.from(str + '\\r\\n', 'utf-8'));\n    }\n\n    /**\n     * Initiates a new message by submitting envelope data, starting with\n     * MAIL FROM: command\n     *\n     * @param {Object} envelope Envelope object in the form of\n     *        {from:'...', to:['...']}\n     *        or\n     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n     */\n    _setEnvelope(envelope, callback) {\n        let args = [];\n        let useSmtpUtf8 = false;\n\n        this._envelope = envelope || {};\n        this._envelope.from = ((this._envelope.from && this._envelope.from.address) || this._envelope.from || '').toString().trim();\n\n        this._envelope.to = [].concat(this._envelope.to || []).map(to => ((to && to.address) || to || '').toString().trim());\n\n        if (!this._envelope.to.length) {\n            return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n        }\n\n        if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n            return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n        }\n\n        // check if the sender address uses only ASCII characters,\n        // otherwise require usage of SMTPUTF8 extension\n        if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n            useSmtpUtf8 = true;\n        }\n\n        for (let i = 0, len = this._envelope.to.length; i < len; i++) {\n            if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n                return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n            }\n\n            // check if the recipients addresses use only ASCII characters,\n            // otherwise require usage of SMTPUTF8 extension\n            if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n                useSmtpUtf8 = true;\n            }\n        }\n\n        // clone the recipients array for latter manipulation\n        this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n        this._envelope.rejected = [];\n        this._envelope.rejectedErrors = [];\n        this._envelope.accepted = [];\n\n        if (this._envelope.dsn) {\n            try {\n                this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n            } catch (err) {\n                return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n            }\n        }\n\n        this._responseActions.push(str => {\n            this._actionMAIL(str, callback);\n        });\n\n        // If the server supports SMTPUTF8 and the envelope includes an internationalized\n        // email address then append SMTPUTF8 keyword to the MAIL FROM command\n        if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n            args.push('SMTPUTF8');\n            this._usingSmtpUtf8 = true;\n        }\n\n        // If the server supports 8BITMIME and the message might contain non-ascii bytes\n        // then append the 8BITMIME keyword to the MAIL FROM command\n        if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n            args.push('BODY=8BITMIME');\n            this._using8BitMime = true;\n        }\n\n        if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n            args.push('SIZE=' + this._envelope.size);\n        }\n\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the MAIL FROM command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.ret) {\n                args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n            }\n            if (this._envelope.dsn.envid) {\n                args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n            }\n        }\n\n        this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));\n    }\n\n    _setDsnEnvelope(params) {\n        let ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n        if (ret) {\n            switch (ret) {\n                case 'HDRS':\n                case 'HEADERS':\n                    ret = 'HDRS';\n                    break;\n                case 'FULL':\n                case 'BODY':\n                    ret = 'FULL';\n                    break;\n            }\n        }\n\n        if (ret && !['FULL', 'HDRS'].includes(ret)) {\n            throw new Error('ret: ' + JSON.stringify(ret));\n        }\n\n        let envid = (params.envid || params.id || '').toString() || null;\n\n        let notify = params.notify || null;\n        if (notify) {\n            if (typeof notify === 'string') {\n                notify = notify.split(',');\n            }\n            notify = notify.map(n => n.trim().toUpperCase());\n            let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n            let invaliNotify = notify.filter(n => !validNotify.includes(n));\n            if (invaliNotify.length || (notify.length > 1 && notify.includes('NEVER'))) {\n                throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n            }\n            notify = notify.join(',');\n        }\n\n        let orcpt = (params.recipient || params.orcpt || '').toString() || null;\n        if (orcpt && orcpt.indexOf(';') < 0) {\n            orcpt = 'rfc822;' + orcpt;\n        }\n\n        return {\n            ret,\n            envid,\n            notify,\n            orcpt\n        };\n    }\n\n    _getDsnRcptToArgs() {\n        let args = [];\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the RCPT TO command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.notify) {\n                args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n            }\n            if (this._envelope.dsn.orcpt) {\n                args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n            }\n        }\n        return args.length ? ' ' + args.join(' ') : '';\n    }\n\n    _createSendStream(callback) {\n        let dataStream = new DataStream();\n        let logStream;\n\n        if (this.options.lmtp) {\n            this._envelope.accepted.forEach((recipient, i) => {\n                let final = i === this._envelope.accepted.length - 1;\n                this._responseActions.push(str => {\n                    this._actionLMTPStream(recipient, final, str, callback);\n                });\n            });\n        } else {\n            this._responseActions.push(str => {\n                this._actionSMTPStream(str, callback);\n            });\n        }\n\n        dataStream.pipe(this._socket, {\n            end: false\n        });\n\n        if (this.options.debug) {\n            logStream = new PassThrough();\n            logStream.on('readable', () => {\n                let chunk;\n                while ((chunk = logStream.read())) {\n                    this.logger.debug(\n                        {\n                            tnx: 'message'\n                        },\n                        chunk.toString('binary').replace(/\\r?\\n$/, '')\n                    );\n                }\n            });\n            dataStream.pipe(logStream);\n        }\n\n        dataStream.once('end', () => {\n            this.logger.info(\n                {\n                    tnx: 'message',\n                    inByteCount: dataStream.inByteCount,\n                    outByteCount: dataStream.outByteCount\n                },\n                '<%s bytes encoded mime message (source size %s bytes)>',\n                dataStream.outByteCount,\n                dataStream.inByteCount\n            );\n        });\n\n        return dataStream;\n    }\n\n    /** ACTIONS **/\n\n    /**\n     * Will be run after the connection is created and the server sends\n     * a greeting. If the incoming message starts with 220 initiate\n     * SMTP session by sending EHLO command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionGreeting(str) {\n        clearTimeout(this._greetingTimeout);\n\n        if (str.substr(0, 3) !== '220') {\n            this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');\n            return;\n        }\n\n        if (this.options.lmtp) {\n            this._responseActions.push(this._actionLHLO);\n            this._sendCommand('LHLO ' + this.name);\n        } else {\n            this._responseActions.push(this._actionEHLO);\n            this._sendCommand('EHLO ' + this.name);\n        }\n    }\n\n    /**\n     * Handles server response for LHLO command. If it yielded in\n     * error, emit 'error', otherwise treat this as an EHLO response\n     *\n     * @param {String} str Message from the server\n     */\n    _actionLHLO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');\n            return;\n        }\n\n        this._actionEHLO(str);\n    }\n\n    /**\n     * Handles server response for EHLO command. If it yielded in\n     * error, try HELO instead, otherwise initiate TLS negotiation\n     * if STARTTLS is supported by the server or move into the\n     * authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionEHLO(str) {\n        let match;\n\n        if (str.substr(0, 3) === '421') {\n            this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            if (this.options.requireTLS) {\n                this._onError(new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str), 'ECONNECTION', str, 'EHLO');\n                return;\n            }\n\n            // Try HELO instead\n            this._responseActions.push(this._actionHELO);\n            this._sendCommand('HELO ' + this.name);\n            return;\n        }\n\n        this._ehloLines = str\n            .split(/\\r?\\n/)\n            .map(line => line.replace(/^\\d+[ -]/, '').trim())\n            .filter(line => line)\n            .slice(1);\n\n        // Detect if the server supports STARTTLS\n        if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\\b/im.test(str) || this.options.requireTLS)) {\n            this._sendCommand('STARTTLS');\n            this._responseActions.push(this._actionSTARTTLS);\n            return;\n        }\n\n        // Detect if the server supports SMTPUTF8\n        if (/[ -]SMTPUTF8\\b/im.test(str)) {\n            this._supportedExtensions.push('SMTPUTF8');\n        }\n\n        // Detect if the server supports DSN\n        if (/[ -]DSN\\b/im.test(str)) {\n            this._supportedExtensions.push('DSN');\n        }\n\n        // Detect if the server supports 8BITMIME\n        if (/[ -]8BITMIME\\b/im.test(str)) {\n            this._supportedExtensions.push('8BITMIME');\n        }\n\n        // Detect if the server supports PIPELINING\n        if (/[ -]PIPELINING\\b/im.test(str)) {\n            this._supportedExtensions.push('PIPELINING');\n        }\n\n        // Detect if the server supports AUTH\n        if (/[ -]AUTH\\b/i.test(str)) {\n            this.allowsAuth = true;\n        }\n\n        // Detect if the server supports PLAIN auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n            this._supportedAuth.push('PLAIN');\n        }\n\n        // Detect if the server supports LOGIN auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n            this._supportedAuth.push('LOGIN');\n        }\n\n        // Detect if the server supports CRAM-MD5 auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n            this._supportedAuth.push('CRAM-MD5');\n        }\n\n        // Detect if the server supports XOAUTH2 auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n            this._supportedAuth.push('XOAUTH2');\n        }\n\n        // Detect if the server supports SIZE extensions (and the max allowed size)\n        if ((match = str.match(/[ -]SIZE(?:[ \\t]+(\\d+))?/im))) {\n            this._supportedExtensions.push('SIZE');\n            this._maxAllowedSize = Number(match[1]) || 0;\n        }\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for HELO command. If it yielded in\n     * error, emit 'error', otherwise move into the authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionHELO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');\n            return;\n        }\n\n        // assume that authentication is enabled (most probably is not though)\n        this.allowsAuth = true;\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for STARTTLS command. If there's an error\n     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n     * succeedes restart the EHLO\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSTARTTLS(str) {\n        if (str.charAt(0) !== '2') {\n            if (this.options.opportunisticTLS) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'Failed STARTTLS upgrade, continuing unencrypted'\n                );\n                return this.emit('connect');\n            }\n            this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n            return;\n        }\n\n        this._upgradeConnection((err, secured) => {\n            if (err) {\n                this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n                return;\n            }\n\n            this.logger.info(\n                {\n                    tnx: 'smtp'\n                },\n                'Connection upgraded with STARTTLS'\n            );\n\n            if (secured) {\n                // restart session\n                if (this.options.lmtp) {\n                    this._responseActions.push(this._actionLHLO);\n                    this._sendCommand('LHLO ' + this.name);\n                } else {\n                    this._responseActions.push(this._actionEHLO);\n                    this._sendCommand('EHLO ' + this.name);\n                }\n            } else {\n                this.emit('connect');\n            }\n        });\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n     * response needs to be base64 encoded username. We do not need\n     * exact match but settle with 334 response in general as some\n     * hosts invalidly use a longer message than VXNlcm5hbWU6\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_USER(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 VXNlcm5hbWU6'\n            callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n            return;\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTH_LOGIN_PASS(str, callback);\n        });\n\n        this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handle the response for AUTH CRAM-MD5 command. We are expecting\n     * '334 <challenge string>'. Data to be sent as response needs to be\n     * base64 decoded challenge string, MD5 hashed using the password as\n     * a HMAC key, prefixed by the username and a space, and finally all\n     * base64 encoded again.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5(str, callback) {\n        let challengeMatch = str.match(/^334\\s+(.+)$/);\n        let challengeString = '';\n\n        if (!challengeMatch) {\n            return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        } else {\n            challengeString = challengeMatch[1];\n        }\n\n        // Decode from base64\n        let base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),\n            hmacMD5 = crypto.createHmac('md5', this._auth.credentials.pass);\n\n        hmacMD5.update(base64decoded);\n\n        let prepended = this._auth.credentials.user + ' ' + hmacMD5.digest('hex');\n\n        this._responseActions.push(str => {\n            this._actionAUTH_CRAM_MD5_PASS(str, callback);\n        });\n\n        this._sendCommand(\n            Buffer.from(prepended).toString('base64'),\n            // hidden hash for logs\n            Buffer.from(this._auth.credentials.user + ' /* secret */').toString('base64')\n        );\n    }\n\n    /**\n     * Handles the response to CRAM-MD5 authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5_PASS(str, callback) {\n        if (!str.match(/^235\\s+/)) {\n            return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n     * response needs to be base64 encoded password.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_PASS(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 UGFzc3dvcmQ6'\n            return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTHComplete(str, callback);\n        });\n\n        this._sendCommand(\n            Buffer.from((this._auth.credentials.pass || '').toString(), 'utf-8').toString('base64'),\n            // Hidden pass for logs\n            Buffer.from('/* secret */', 'utf-8').toString('base64')\n        );\n    }\n\n    /**\n     * Handles the response for authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTHComplete(str, isRetry, callback) {\n        if (!callback && typeof isRetry === 'function') {\n            callback = isRetry;\n            isRetry = false;\n        }\n\n        if (str.substr(0, 3) === '334') {\n            this._responseActions.push(str => {\n                if (isRetry || this._authMethod !== 'XOAUTH2') {\n                    this._actionAUTHComplete(str, true, callback);\n                } else {\n                    // fetch a new OAuth2 access token\n                    setImmediate(() => this._handleXOauth2Token(true, callback));\n                }\n            });\n            this._sendCommand('');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            this.logger.info(\n                {\n                    tnx: 'smtp',\n                    username: this._auth.user,\n                    action: 'authfail',\n                    method: this._authMethod\n                },\n                'User %s failed to authenticate',\n                JSON.stringify(this._auth.user)\n            );\n            return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle response for a MAIL FROM: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionMAIL(str, callback) {\n        let message, curRecipient;\n        if (Number(str.charAt(0)) !== 2) {\n            if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Mail command failed';\n            }\n            return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n        }\n\n        if (!this._envelope.rcptQueue.length) {\n            return callback(this._formatError('Can\\x27t send mail - no recipients defined', 'EENVELOPE', false, 'API'));\n        } else {\n            this._recipientQueue = [];\n\n            if (this._supportedExtensions.includes('PIPELINING')) {\n                while (this._envelope.rcptQueue.length) {\n                    curRecipient = this._envelope.rcptQueue.shift();\n                    this._recipientQueue.push(curRecipient);\n                    this._responseActions.push(str => {\n                        this._actionRCPT(str, callback);\n                    });\n                    this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n                }\n            } else {\n                curRecipient = this._envelope.rcptQueue.shift();\n                this._recipientQueue.push(curRecipient);\n                this._responseActions.push(str => {\n                    this._actionRCPT(str, callback);\n                });\n                this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n            }\n        }\n    }\n\n    /**\n     * Handle response for a RCPT TO: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionRCPT(str, callback) {\n        let message,\n            err,\n            curRecipient = this._recipientQueue.shift();\n        if (Number(str.charAt(0)) !== 2) {\n            // this is a soft error\n            if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Recipient command failed';\n            }\n            this._envelope.rejected.push(curRecipient);\n            // store error for the failed recipient\n            err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n            err.recipient = curRecipient;\n            this._envelope.rejectedErrors.push(err);\n        } else {\n            this._envelope.accepted.push(curRecipient);\n        }\n\n        if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n            if (this._envelope.rejected.length < this._envelope.to.length) {\n                this._responseActions.push(str => {\n                    this._actionDATA(str, callback);\n                });\n                this._sendCommand('DATA');\n            } else {\n                err = this._formatError('Can\\x27t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');\n                err.rejected = this._envelope.rejected;\n                err.rejectedErrors = this._envelope.rejectedErrors;\n                return callback(err);\n            }\n        } else if (this._envelope.rcptQueue.length) {\n            curRecipient = this._envelope.rcptQueue.shift();\n            this._recipientQueue.push(curRecipient);\n            this._responseActions.push(str => {\n                this._actionRCPT(str, callback);\n            });\n            this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n    }\n\n    /**\n     * Handle response for a DATA command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionDATA(str, callback) {\n        // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n        // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n        if (!/^[23]/.test(str)) {\n            return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n        }\n\n        let response = {\n            accepted: this._envelope.accepted,\n            rejected: this._envelope.rejected\n        };\n\n        if (this._ehloLines && this._ehloLines.length) {\n            response.ehlo = this._ehloLines;\n        }\n\n        if (this._envelope.rejectedErrors.length) {\n            response.rejectedErrors = this._envelope.rejectedErrors;\n        }\n\n        callback(null, response);\n    }\n\n    /**\n     * Handle response for a DATA stream when using SMTP\n     * We expect a single response that defines if the sending succeeded or failed\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSMTPStream(str, callback) {\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n        } else {\n            // Message sent succesfully\n            return callback(null, str);\n        }\n    }\n\n    /**\n     * Handle response for a DATA stream\n     * We expect a separate response for every recipient. All recipients can either\n     * succeed or fail separately\n     *\n     * @param {String} recipient The recipient this response applies to\n     * @param {Boolean} final Is this the final recipient?\n     * @param {String} str Message from the server\n     */\n    _actionLMTPStream(recipient, final, str, callback) {\n        let err;\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n            err.recipient = recipient;\n            this._envelope.rejected.push(recipient);\n            this._envelope.rejectedErrors.push(err);\n            for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {\n                if (this._envelope.accepted[i] === recipient) {\n                    this._envelope.accepted.splice(i, 1);\n                }\n            }\n        }\n        if (final) {\n            return callback(null, str);\n        }\n    }\n\n    _handleXOauth2Token(isRetry, callback) {\n        this._auth.oauth2.getToken(isRetry, (err, accessToken) => {\n            if (err) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp',\n                        username: this._auth.user,\n                        action: 'authfail',\n                        method: this._authMethod\n                    },\n                    'User %s failed to authenticate',\n                    JSON.stringify(this._auth.user)\n                );\n                return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n            }\n            this._responseActions.push(str => {\n                this._actionAUTHComplete(str, isRetry, callback);\n            });\n            this._sendCommand(\n                'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken),\n                //  Hidden for logs\n                'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token('/* secret */')\n            );\n        });\n    }\n\n    /**\n     *\n     * @param {string} command\n     * @private\n     */\n    _isDestroyedMessage(command) {\n        if (this._destroyed) {\n            return 'Cannot ' + command + ' - smtp connection is already destroyed.';\n        }\n\n        if (this._socket) {\n            if (this._socket.destroyed) {\n                return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';\n            }\n\n            if (!this._socket.writable) {\n                return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';\n            }\n        }\n    }\n\n    _getHostname() {\n        // defaul hostname is machine hostname or [IP]\n        let defaultHostname;\n        try {\n            defaultHostname = os.hostname() || '';\n        } catch (err) {\n            // fails on windows 7\n            defaultHostname = 'localhost';\n        }\n\n        // ignore if not FQDN\n        if (!defaultHostname || defaultHostname.indexOf('.') < 0) {\n            defaultHostname = '[127.0.0.1]';\n        }\n\n        // IP should be enclosed in []\n        if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n            defaultHostname = '[' + defaultHostname + ']';\n        }\n\n        return defaultHostname;\n    }\n}\n\nmodule.exports = SMTPConnection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc210cC1jb25uZWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLHdFQUFvQjtBQUNoRCxxQkFBcUIsMERBQThCO0FBQ25ELFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFlO0FBQzFDLG9CQUFvQix5REFBNkI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLHNFQUFXOztBQUVsQztBQUNBLDBDQUEwQztBQUMxQyx1Q0FBdUM7QUFDdkMsb0NBQW9DO0FBQ3BDLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsMkJBQTJCO0FBQ2xELGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVLGtCQUFrQixFQUFFO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFO0FBQ2pFLHVFQUF1RTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtFQUErRTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBLGVBQWUsTUFBTSx5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdELFNBQVM7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQyw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLElBQUksS0FBSyxJQUFJLEtBQUssSUFBSSxLQUFLLElBQUk7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9zbXRwLWNvbm5lY3Rpb24vaW5kZXguanM/YzY4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhY2thZ2VJbmZvID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBEYXRhU3RyZWFtID0gcmVxdWlyZSgnLi9kYXRhLXN0cmVhbScpO1xuY29uc3QgUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdzdHJlYW0nKS5QYXNzVGhyb3VnaDtcbmNvbnN0IHNoYXJlZCA9IHJlcXVpcmUoJy4uL3NoYXJlZCcpO1xuXG4vLyBkZWZhdWx0IHRpbWVvdXQgdmFsdWVzIGluIG1zXG5jb25zdCBDT05ORUNUSU9OX1RJTUVPVVQgPSAyICogNjAgKiAxMDAwOyAvLyBob3cgbXVjaCB0byB3YWl0IGZvciB0aGUgY29ubmVjdGlvbiB0byBiZSBlc3RhYmxpc2hlZFxuY29uc3QgU09DS0VUX1RJTUVPVVQgPSAxMCAqIDYwICogMTAwMDsgLy8gaG93IG11Y2ggdG8gd2FpdCBmb3Igc29ja2V0IGluYWN0aXZpdHkgYmVmb3JlIGRpc2Nvbm5lY3RpbmcgdGhlIGNsaWVudFxuY29uc3QgR1JFRVRJTkdfVElNRU9VVCA9IDMwICogMTAwMDsgLy8gaG93IG11Y2ggdG8gd2FpdCBhZnRlciBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIGJ1dCBTTVRQIGdyZWV0aW5nIGlzIG5vdCByZWNlaWV2ZWRcbmNvbnN0IEROU19USU1FT1VUID0gMzAgKiAxMDAwOyAvLyBob3cgbXVjaCB0byB3YWl0IGZvciByZXNvbHZlSG9zdG5hbWVcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBTTVRQIGNvbm5lY3Rpb24gb2JqZWN0XG4gKlxuICogT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGFrZXMgdGhlIGZvbGxvd2luZyBwb3NzaWJsZSBwcm9wZXJ0aWVzOlxuICpcbiAqICAqICoqcG9ydCoqIC0gaXMgdGhlIHBvcnQgdG8gY29ubmVjdCB0byAoZGVmYXVsdHMgdG8gNTg3IG9yIDQ2NSlcbiAqICAqICoqaG9zdCoqIC0gaXMgdGhlIGhvc3RuYW1lIG9yIElQIGFkZHJlc3MgdG8gY29ubmVjdCB0byAoZGVmYXVsdHMgdG8gJ2xvY2FsaG9zdCcpXG4gKiAgKiAqKnNlY3VyZSoqIC0gdXNlIFNTTFxuICogICogKippZ25vcmVUTFMqKiAtIGlnbm9yZSBzZXJ2ZXIgc3VwcG9ydCBmb3IgU1RBUlRUTFNcbiAqICAqICoqcmVxdWlyZVRMUyoqIC0gZm9yY2VzIHRoZSBjbGllbnQgdG8gdXNlIFNUQVJUVExTXG4gKiAgKiAqKm5hbWUqKiAtIHRoZSBuYW1lIG9mIHRoZSBjbGllbnQgc2VydmVyXG4gKiAgKiAqKmxvY2FsQWRkcmVzcyoqIC0gb3V0Ym91bmQgYWRkcmVzcyB0byBiaW5kIHRvIChzZWU6IGh0dHA6Ly9ub2RlanMub3JnL2FwaS9uZXQuaHRtbCNuZXRfbmV0X2Nvbm5lY3Rfb3B0aW9uc19jb25uZWN0aW9ubGlzdGVuZXIpXG4gKiAgKiAqKmdyZWV0aW5nVGltZW91dCoqIC0gVGltZSB0byB3YWl0IGluIG1zIHVudGlsIGdyZWV0aW5nIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIChkZWZhdWx0cyB0byAxMDAwMClcbiAqICAqICoqY29ubmVjdGlvblRpbWVvdXQqKiAtIGhvdyBtYW55IG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciB0aGUgY29ubmVjdGlvbiB0byBlc3RhYmxpc2hcbiAqICAqICoqc29ja2V0VGltZW91dCoqIC0gVGltZSBvZiBpbmFjdGl2aXR5IHVudGlsIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCAoZGVmYXVsdHMgdG8gMSBob3VyKVxuICogICogKipkbnNUaW1lb3V0KiogLSBUaW1lIHRvIHdhaXQgaW4gbXMgZm9yIHRoZSBETlMgcmVxdWVzdHMgdG8gYmUgcmVzb2x2ZWQgKGRlZmF1bHRzIHRvIDMwIHNlY29uZHMpXG4gKiAgKiAqKmxtdHAqKiAtIGlmIHRydWUsIHVzZXMgTE1UUCBpbnN0ZWFkIG9mIFNNVFAgcHJvdG9jb2xcbiAqICAqICoqbG9nZ2VyKiogLSBidW55YW4gY29tcGF0aWJsZSBsb2dnZXIgaW50ZXJmYWNlXG4gKiAgKiAqKmRlYnVnKiogLSBpZiB0cnVlIHBhc3MgU01UUCB0cmFmZmljIHRvIHRoZSBsb2dnZXJcbiAqICAqICoqdGxzKiogLSBvcHRpb25zIGZvciBjcmVhdGVDcmVkZW50aWFsc1xuICogICogKipzb2NrZXQqKiAtIGV4aXN0aW5nIHNvY2tldCB0byB1c2UgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvbmUgKHNlZTogaHR0cDovL25vZGVqcy5vcmcvYXBpL25ldC5odG1sI25ldF9jbGFzc19uZXRfc29ja2V0KVxuICogICogKipzZWN1cmVkKiogLSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBwcm92aWRlZCBzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiB1cGdyYWRlZCB0byB0bHNcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBuYW1lc3BhY2UgU01UUCBDbGllbnQgbW9kdWxlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbiBwcm9wZXJ0aWVzXG4gKi9cbmNsYXNzIFNNVFBDb25uZWN0aW9uIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuaWQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoOCkudG9TdHJpbmcoJ2Jhc2U2NCcpLnJlcGxhY2UoL1xcVy9nLCAnJyk7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSAnaW5pdCc7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLnNlY3VyZUNvbm5lY3Rpb24gPSAhIXRoaXMub3B0aW9ucy5zZWN1cmU7XG4gICAgICAgIHRoaXMuYWxyZWFkeVNlY3VyZWQgPSAhIXRoaXMub3B0aW9ucy5zZWN1cmVkO1xuXG4gICAgICAgIHRoaXMucG9ydCA9IE51bWJlcih0aGlzLm9wdGlvbnMucG9ydCkgfHwgKHRoaXMuc2VjdXJlQ29ubmVjdGlvbiA/IDQ2NSA6IDU4Nyk7XG4gICAgICAgIHRoaXMuaG9zdCA9IHRoaXMub3B0aW9ucy5ob3N0IHx8ICdsb2NhbGhvc3QnO1xuXG4gICAgICAgIHRoaXMuc2VydmVybmFtZSA9IHRoaXMub3B0aW9ucy5zZXJ2ZXJuYW1lID8gdGhpcy5vcHRpb25zLnNlcnZlcm5hbWUgOiAhbmV0LmlzSVAodGhpcy5ob3N0KSA/IHRoaXMuaG9zdCA6IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuYWxsb3dJbnRlcm5hbE5ldHdvcmtJbnRlcmZhY2VzID0gdGhpcy5vcHRpb25zLmFsbG93SW50ZXJuYWxOZXR3b3JrSW50ZXJmYWNlcyB8fCBmYWxzZTtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zZWN1cmUgPT09ICd1bmRlZmluZWQnICYmIHRoaXMucG9ydCA9PT0gNDY1KSB7XG4gICAgICAgICAgICAvLyBpZiBzZWN1cmUgb3B0aW9uIGlzIG5vdCBzZXQgYnV0IHBvcnQgaXMgNDY1LCB0aGVuIGRlZmF1bHQgdG8gc2VjdXJlXG4gICAgICAgICAgICB0aGlzLnNlY3VyZUNvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5vcHRpb25zLm5hbWUgfHwgdGhpcy5fZ2V0SG9zdG5hbWUoKTtcblxuICAgICAgICB0aGlzLmxvZ2dlciA9IHNoYXJlZC5nZXRMb2dnZXIodGhpcy5vcHRpb25zLCB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMub3B0aW9ucy5jb21wb25lbnQgfHwgJ3NtdHAtY29ubmVjdGlvbicsXG4gICAgICAgICAgICBzaWQ6IHRoaXMuaWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jdXN0b21BdXRoID0gbmV3IE1hcCgpO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuY3VzdG9tQXV0aCB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IG1hcEtleSA9IChrZXkgfHwgJycpLnRvU3RyaW5nKCkudHJpbSgpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoIW1hcEtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQXV0aC5zZXQobWFwS2V5LCB0aGlzLm9wdGlvbnMuY3VzdG9tQXV0aFtrZXldKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cG9zZSB2ZXJzaW9uIG5yLCBqdXN0IGZvciB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBwYWNrYWdlSW5mby52ZXJzaW9uO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGVuIHRoZSB1c2VyIGlzIGF1dGhlbnRpY2F0ZWRcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIHRoaXMgaW5zdGFuY2UgaXMgbm8gbG9uZ2VyIGFjdGl2ZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBpZiB0aGUgY3VycmVudCBjb25uZWN0aW9uIGlzIHNlY3VyZSBvciBub3QuIElmIG5vdCxcbiAgICAgICAgICogU1RBUlRUTFMgY2FuIGJlIHVzZWQgaWYgYXZhaWxhYmxlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlY3VyZSA9ICEhdGhpcy5zZWN1cmVDb25uZWN0aW9uO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZSBpbmNvbXBsZXRlIG1lc3NhZ2VzIGNvbWluZyBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JlbWFpbmRlciA9ICcnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnByb2Nlc3NlZCByZXNwb25zZXMgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlUXVldWUgPSBbXTtcblxuICAgICAgICB0aGlzLmxhc3RTZXJ2ZXJSZXNwb25zZSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc29ja2V0IGNvbm5lY3RpbmcgdG8gdGhlIHNlcnZlclxuICAgICAgICAgKiBAcHVibGlja1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc29ja2V0ID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIHN1cHBvcnRlZCBhdXRoIG1lY2hhbmlzbXNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3N1cHBvcnRlZEF1dGggPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIHRydWUsIGlmIEVITE8gcmVzcG9uc2UgaW5jbHVkZXMgXCJBVVRIXCIuXG4gICAgICAgICAqIElmIGZhbHNlIHRoZW4gYXV0aGVudGljYXRpb24gaXMgbm90IHRyaWVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsbG93c0F1dGggPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5jbHVkZXMgY3VycmVudCBlbnZlbG9wZSAoZnJvbSwgdG8pXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9lbnZlbG9wZSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyBzdXBwb3J0ZWQgZXh0ZW5zaW9uc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBmb3IgYSBzaW5nbGUgbWVzc2FnZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWF4QWxsb3dlZFNpemUgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGdW5jdGlvbiBxdWV1ZSB0byBydW4gaWYgYSBkYXRhIGNodW5rIGNvbWVzIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMuX3JlY2lwaWVudFF1ZXVlID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbWVvdXQgdmFyaWFibGUgZm9yIHdhaXRpbmcgdGhlIGdyZWV0aW5nXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ncmVldGluZ1RpbWVvdXQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGltZW91dCB2YXJpYWJsZSBmb3Igd2FpdGluZyB0aGUgY29ubmVjdGlvbiB0byBzdGFydFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblRpbWVvdXQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHNvY2tldCBpcyBkZWVtZWQgYWxyZWFkeSBjbG9zZWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgc29ja2V0IGlzIGFscmVhZHkgYmVpbmcgY2xvc2VkXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jbG9zaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrcyBmb3Igc29ja2V0J3MgbGlzdGVuZXJzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vblNvY2tldERhdGEgPSBjaHVuayA9PiB0aGlzLl9vbkRhdGEoY2h1bmspO1xuICAgICAgICB0aGlzLl9vblNvY2tldEVycm9yID0gZXJyb3IgPT4gdGhpcy5fb25FcnJvcihlcnJvciwgJ0VTT0NLRVQnLCBmYWxzZSwgJ0NPTk4nKTtcbiAgICAgICAgdGhpcy5fb25Tb2NrZXRDbG9zZSA9ICgpID0+IHRoaXMuX29uQ2xvc2UoKTtcbiAgICAgICAgdGhpcy5fb25Tb2NrZXRFbmQgPSAoKSA9PiB0aGlzLl9vbkVuZCgpO1xuICAgICAgICB0aGlzLl9vblNvY2tldFRpbWVvdXQgPSAoKSA9PiB0aGlzLl9vblRpbWVvdXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29ubmVjdGlvbiB0byBhIFNNVFAgc2VydmVyIGFuZCBzZXRzIHVwIGNvbm5lY3Rpb25cbiAgICAgKiBsaXN0ZW5lclxuICAgICAqL1xuICAgIGNvbm5lY3QoY29ubmVjdENhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29ubmVjdENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uY2UoJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3NtdHAnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdTTVRQIGhhbmRzaGFrZSBmaW5pc2hlZCdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbm5lY3RDYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzRGVzdHJveWVkTWVzc2FnZSA9IHRoaXMuX2lzRGVzdHJveWVkTWVzc2FnZSgnY29ubmVjdCcpO1xuICAgICAgICAgICAgaWYgKGlzRGVzdHJveWVkTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0Q2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoaXNEZXN0cm95ZWRNZXNzYWdlLCAnRUNPTk5FQ1RJT04nLCBmYWxzZSwgJ0NPTk4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3B0cyA9IHtcbiAgICAgICAgICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICAgICAgICAgIGhvc3Q6IHRoaXMuaG9zdCxcbiAgICAgICAgICAgIGFsbG93SW50ZXJuYWxOZXR3b3JrSW50ZXJmYWNlczogdGhpcy5hbGxvd0ludGVybmFsTmV0d29ya0ludGVyZmFjZXMsXG4gICAgICAgICAgICB0aW1lb3V0OiB0aGlzLm9wdGlvbnMuZG5zVGltZW91dCB8fCBETlNfVElNRU9VVFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYWxBZGRyZXNzKSB7XG4gICAgICAgICAgICBvcHRzLmxvY2FsQWRkcmVzcyA9IHRoaXMub3B0aW9ucy5sb2NhbEFkZHJlc3M7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2V0dXBDb25uZWN0aW9uSGFuZGxlcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoJ0Nvbm5lY3Rpb24gdGltZW91dCcsICdFVElNRURPVVQnLCBmYWxzZSwgJ0NPTk4nKTtcbiAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5jb25uZWN0aW9uVGltZW91dCB8fCBDT05ORUNUSU9OX1RJTUVPVVQpO1xuXG4gICAgICAgICAgICB0aGlzLl9zb2NrZXQub24oJ2Vycm9yJywgdGhpcy5fb25Tb2NrZXRFcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBjb25uZWN0aW9uIGlzIGFscmVhZHkgb3BlbmVkXG4gICAgICAgICAgICB0aGlzLl9zb2NrZXQgPSB0aGlzLm9wdGlvbnMuY29ubmVjdGlvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlY3VyZUNvbm5lY3Rpb24gJiYgIXRoaXMuYWxyZWFkeVNlY3VyZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBncmFkZUNvbm5lY3Rpb24oZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkVycm9yKG5ldyBFcnJvcignRXJyb3IgaW5pdGlhdGluZyBUTFMgLSAnICsgKGVyci5tZXNzYWdlIHx8IGVycikpLCAnRVRMUycsIGZhbHNlLCAnQ09OTicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9vbkNvbm5lY3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNvY2tldCkge1xuICAgICAgICAgICAgLy8gc29ja2V0IG9iamVjdCBpcyBzZXQgdXAgYnV0IG5vdCB5ZXQgY29ubmVjdGVkXG4gICAgICAgICAgICB0aGlzLl9zb2NrZXQgPSB0aGlzLm9wdGlvbnMuc29ja2V0O1xuICAgICAgICAgICAgcmV0dXJuIHNoYXJlZC5yZXNvbHZlSG9zdG5hbWUob3B0cywgKGVyciwgcmVzb2x2ZWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fb25FcnJvcihlcnIsICdFRE5TJywgZmFsc2UsICdDT05OJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG54OiAnZG5zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogb3B0cy5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQ6IHJlc29sdmVkLmhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWQ6ICEhcmVzb2x2ZWQuY2FjaGVkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdSZXNvbHZlZCAlcyBhcyAlcyBbY2FjaGUgJXNdJyxcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5ob3N0LFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZC5ob3N0LFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZC5jYWNoZWQgPyAnaGl0JyA6ICdtaXNzJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmVzb2x2ZWQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5jaGFyQXQoMCkgIT09ICdfJyAmJiByZXNvbHZlZFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzW2tleV0gPSByZXNvbHZlZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc29ja2V0LmNvbm5lY3QodGhpcy5wb3J0LCB0aGlzLmhvc3QsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NvY2tldC5zZXRLZWVwQWxpdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldHVwQ29ubmVjdGlvbkhhbmRsZXJzKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX29uRXJyb3IoRSwgJ0VDT05ORUNUSU9OJywgZmFsc2UsICdDT05OJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VjdXJlQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgLy8gY29ubmVjdCB1c2luZyB0bHNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGxzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5vcHRpb25zLnRscykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcHRzW2tleV0gPSB0aGlzLm9wdGlvbnMudGxzW2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSBzZXJ2ZXJuYW1lIGZvciBTTklcbiAgICAgICAgICAgIGlmICh0aGlzLnNlcnZlcm5hbWUgJiYgIW9wdHMuc2VydmVybmFtZSkge1xuICAgICAgICAgICAgICAgIG9wdHMuc2VydmVybmFtZSA9IHRoaXMuc2VydmVybmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNoYXJlZC5yZXNvbHZlSG9zdG5hbWUob3B0cywgKGVyciwgcmVzb2x2ZWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fb25FcnJvcihlcnIsICdFRE5TJywgZmFsc2UsICdDT05OJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG54OiAnZG5zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogb3B0cy5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQ6IHJlc29sdmVkLmhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWQ6ICEhcmVzb2x2ZWQuY2FjaGVkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdSZXNvbHZlZCAlcyBhcyAlcyBbY2FjaGUgJXNdJyxcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5ob3N0LFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZC5ob3N0LFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZC5jYWNoZWQgPyAnaGl0JyA6ICdtaXNzJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmVzb2x2ZWQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5jaGFyQXQoMCkgIT09ICdfJyAmJiByZXNvbHZlZFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzW2tleV0gPSByZXNvbHZlZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc29ja2V0ID0gdGxzLmNvbm5lY3Qob3B0cywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc29ja2V0LnNldEtlZXBBbGl2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBDb25uZWN0aW9uSGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fb25FcnJvcihFLCAnRUNPTk5FQ1RJT04nLCBmYWxzZSwgJ0NPTk4nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb25uZWN0IHVzaW5nIHBsYWludGV4dFxuICAgICAgICAgICAgcmV0dXJuIHNoYXJlZC5yZXNvbHZlSG9zdG5hbWUob3B0cywgKGVyciwgcmVzb2x2ZWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fb25FcnJvcihlcnIsICdFRE5TJywgZmFsc2UsICdDT05OJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG54OiAnZG5zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogb3B0cy5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQ6IHJlc29sdmVkLmhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWQ6ICEhcmVzb2x2ZWQuY2FjaGVkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdSZXNvbHZlZCAlcyBhcyAlcyBbY2FjaGUgJXNdJyxcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5ob3N0LFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZC5ob3N0LFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZC5jYWNoZWQgPyAnaGl0JyA6ICdtaXNzJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmVzb2x2ZWQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5jaGFyQXQoMCkgIT09ICdfJyAmJiByZXNvbHZlZFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzW2tleV0gPSByZXNvbHZlZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc29ja2V0ID0gbmV0LmNvbm5lY3Qob3B0cywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc29ja2V0LnNldEtlZXBBbGl2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBDb25uZWN0aW9uSGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fb25FcnJvcihFLCAnRUNPTk5FQ1RJT04nLCBmYWxzZSwgJ0NPTk4nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyBRVUlUXG4gICAgICovXG4gICAgcXVpdCgpIHtcbiAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoJ1FVSVQnKTtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2godGhpcy5jbG9zZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Nvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2dyZWV0aW5nVGltZW91dCk7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucyA9IFtdO1xuXG4gICAgICAgIC8vIGFsbG93IHRvIHJ1biB0aGlzIGZ1bmN0aW9uIG9ubHkgb25jZVxuICAgICAgICBpZiAodGhpcy5fY2xvc2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nsb3NpbmcgPSB0cnVlO1xuXG4gICAgICAgIGxldCBjbG9zZU1ldGhvZCA9ICdlbmQnO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YWdlID09PSAnaW5pdCcpIHtcbiAgICAgICAgICAgIC8vIENsb3NlIHRoZSBzb2NrZXQgaW1tZWRpYXRlbHkgd2hlbiBjb25uZWN0aW9uIHRpbWVkIG91dFxuICAgICAgICAgICAgY2xvc2VNZXRob2QgPSAnZGVzdHJveSc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0bng6ICdzbXRwJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdDbG9zaW5nIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciB1c2luZyBcIiVzXCInLFxuICAgICAgICAgICAgY2xvc2VNZXRob2RcbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgc29ja2V0ID0gKHRoaXMuX3NvY2tldCAmJiB0aGlzLl9zb2NrZXQuc29ja2V0KSB8fCB0aGlzLl9zb2NrZXQ7XG5cbiAgICAgICAgaWYgKHNvY2tldCAmJiAhc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb2NrZXRbY2xvc2VNZXRob2RdKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgLy8ganVzdCBpZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdXRoZW50aWNhdGUgdXNlclxuICAgICAqL1xuICAgIGxvZ2luKGF1dGhEYXRhLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBpc0Rlc3Ryb3llZE1lc3NhZ2UgPSB0aGlzLl9pc0Rlc3Ryb3llZE1lc3NhZ2UoJ2xvZ2luJyk7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcihpc0Rlc3Ryb3llZE1lc3NhZ2UsICdFQ09OTkVDVElPTicsIGZhbHNlLCAnQVBJJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXV0aCA9IGF1dGhEYXRhIHx8IHt9O1xuICAgICAgICAvLyBTZWxlY3QgU0FTTCBhdXRoZW50aWNhdGlvbiBtZXRob2RcbiAgICAgICAgdGhpcy5fYXV0aE1ldGhvZCA9ICh0aGlzLl9hdXRoLm1ldGhvZCB8fCAnJykudG9TdHJpbmcoKS50cmltKCkudG9VcHBlckNhc2UoKSB8fCBmYWxzZTtcblxuICAgICAgICBpZiAoIXRoaXMuX2F1dGhNZXRob2QgJiYgdGhpcy5fYXV0aC5vYXV0aDIgJiYgIXRoaXMuX2F1dGguY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1dGhNZXRob2QgPSAnWE9BVVRIMic7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2F1dGhNZXRob2QgfHwgKHRoaXMuX2F1dGhNZXRob2QgPT09ICdYT0FVVEgyJyAmJiAhdGhpcy5fYXV0aC5vYXV0aDIpKSB7XG4gICAgICAgICAgICAvLyB1c2UgZmlyc3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICB0aGlzLl9hdXRoTWV0aG9kID0gKHRoaXMuX3N1cHBvcnRlZEF1dGhbMF0gfHwgJ1BMQUlOJykudG9VcHBlckNhc2UoKS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYXV0aE1ldGhvZCAhPT0gJ1hPQVVUSDInICYmICghdGhpcy5fYXV0aC5jcmVkZW50aWFscyB8fCAhdGhpcy5fYXV0aC5jcmVkZW50aWFscy51c2VyIHx8ICF0aGlzLl9hdXRoLmNyZWRlbnRpYWxzLnBhc3MpKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuX2F1dGgudXNlciAmJiB0aGlzLl9hdXRoLnBhc3MpIHx8IHRoaXMuY3VzdG9tQXV0aC5oYXModGhpcy5fYXV0aE1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRoLmNyZWRlbnRpYWxzID0ge1xuICAgICAgICAgICAgICAgICAgICB1c2VyOiB0aGlzLl9hdXRoLnVzZXIsXG4gICAgICAgICAgICAgICAgICAgIHBhc3M6IHRoaXMuX2F1dGgucGFzcyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogdGhpcy5fYXV0aC5vcHRpb25zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdNaXNzaW5nIGNyZWRlbnRpYWxzIGZvciBcIicgKyB0aGlzLl9hdXRoTWV0aG9kICsgJ1wiJywgJ0VBVVRIJywgZmFsc2UsICdBUEknKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jdXN0b21BdXRoLmhhcyh0aGlzLl9hdXRoTWV0aG9kKSkge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSB0aGlzLmN1c3RvbUF1dGguZ2V0KHRoaXMuX2F1dGhNZXRob2QpO1xuICAgICAgICAgICAgbGV0IGxhc3RSZXNwb25zZTtcbiAgICAgICAgICAgIGxldCByZXR1cm5lZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG54OiAnc210cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogdGhpcy5fYXV0aC51c2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnYXV0aGVudGljYXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMuX2F1dGhNZXRob2RcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ1VzZXIgJXMgYXV0aGVudGljYXRlZCcsXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMuX2F1dGgudXNlcilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsZXQgcmVqZWN0ID0gZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoZXJyLCAnRUFVVEgnLCBsYXN0UmVzcG9uc2UsICdBVVRIICcgKyB0aGlzLl9hdXRoTWV0aG9kKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsZXQgaGFuZGxlclJlc3BvbnNlID0gaGFuZGxlcih7XG4gICAgICAgICAgICAgICAgYXV0aDogdGhpcy5fYXV0aCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMuX2F1dGhNZXRob2QsXG5cbiAgICAgICAgICAgICAgICBleHRlbnNpb25zOiBbXS5jb25jYXQodGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucyksXG4gICAgICAgICAgICAgICAgYXV0aE1ldGhvZHM6IFtdLmNvbmNhdCh0aGlzLl9zdXBwb3J0ZWRBdXRoKSxcbiAgICAgICAgICAgICAgICBtYXhBbGxvd2VkU2l6ZTogdGhpcy5fbWF4QWxsb3dlZFNpemUgfHwgZmFsc2UsXG5cbiAgICAgICAgICAgICAgICBzZW5kQ29tbWFuZDogKGNtZCwgZG9uZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJvbWlzZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHNoYXJlZC5jYWxsYmFja1Byb21pc2UocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2goc3RyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZXNwb25zZSA9IHN0cjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGVzID0gc3RyLm1hdGNoKC9eKFxcZCspKD86XFxzKFxcZCtcXC5cXGQrXFwuXFxkKykpP1xccy8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogY21kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBzdHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXR1cyA9IE51bWJlcihjb2Rlc1sxXSkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jb2RlID0gY29kZXNbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudGV4dCA9IHN0ci5zdWJzdHIoY29kZXNbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50ZXh0ID0gc3RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3RhdHVzID0gMDsgLy8ganVzdCBpbiBjYXNlIHdlIG5lZWQgdG8gcGVyZm9ybSBudW1lcmljIGNvbXBhcmlzb25zXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKG51bGwsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3NlbmRDb21tYW5kKGNtZCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyUmVzcG9uc2UgJiYgdHlwZW9mIGhhbmRsZXJSZXNwb25zZS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIGEgcHJvbWlzZSB3YXMgcmV0dXJuZWRcbiAgICAgICAgICAgICAgICBoYW5kbGVyUmVzcG9uc2UudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRoaXMuX2F1dGhNZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ1hPQVVUSDInOlxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVhPYXV0aDJUb2tlbihmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ0xPR0lOJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25zZUFjdGlvbnMucHVzaChzdHIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25BVVRIX0xPR0lOX1VTRVIoc3RyLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoJ0FVVEggTE9HSU4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdQTEFJTic6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2goc3RyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uQVVUSENvbXBsZXRlKHN0ciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKFxuICAgICAgICAgICAgICAgICAgICAnQVVUSCBQTEFJTiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5fYXV0aC51c2VyKydcXHUwMDAwJytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFx1MDAwMCcgKyAvLyBza2lwIGF1dGhvcml6YXRpb24gaWRlbnRpdHkgYXMgaXQgY2F1c2VzIHByb2JsZW1zIHdpdGggc29tZSBzZXJ2ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGguY3JlZGVudGlhbHMudXNlciArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXHUwMDAwJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGguY3JlZGVudGlhbHMucGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndXRmLTgnXG4gICAgICAgICAgICAgICAgICAgICAgICApLnRvU3RyaW5nKCdiYXNlNjQnKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nIGVudHJ5IHdpdGhvdXQgcGFzc3dvcmRzXG4gICAgICAgICAgICAgICAgICAgICdBVVRIIFBMQUlOICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmZyb20oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLl9hdXRoLnVzZXIrJ1xcdTAwMDAnK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXHUwMDAwJyArIC8vIHNraXAgYXV0aG9yaXphdGlvbiBpZGVudGl0eSBhcyBpdCBjYXVzZXMgcHJvYmxlbXMgd2l0aCBzb21lIHNlcnZlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aC5jcmVkZW50aWFscy51c2VyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcdTAwMDAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy8qIHNlY3JldCAqLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3V0Zi04J1xuICAgICAgICAgICAgICAgICAgICAgICAgKS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ0NSQU0tTUQ1JzpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25zZUFjdGlvbnMucHVzaChzdHIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25BVVRIX0NSQU1fTUQ1KHN0ciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdBVVRIIENSQU0tTUQ1Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdVbmtub3duIGF1dGhlbnRpY2F0aW9uIG1ldGhvZCBcIicgKyB0aGlzLl9hdXRoTWV0aG9kICsgJ1wiJywgJ0VBVVRIJywgZmFsc2UsICdBUEknKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52ZWxvcGUgRW52ZWxvcGUgb2JqZWN0LCB7ZnJvbTogYWRkciwgdG86IFthZGRyXX1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZSBTdHJpbmcsIEJ1ZmZlciBvciBhIFN0cmVhbVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJldHVybiBvbmNlIHNlbmRpbmcgaXMgY29tcGxldGVkXG4gICAgICovXG4gICAgc2VuZChlbnZlbG9wZSwgbWVzc2FnZSwgZG9uZSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKHRoaXMuX2Zvcm1hdEVycm9yKCdFbXB0eSBtZXNzYWdlJywgJ0VNRVNTQUdFJywgZmFsc2UsICdBUEknKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0Rlc3Ryb3llZE1lc3NhZ2UgPSB0aGlzLl9pc0Rlc3Ryb3llZE1lc3NhZ2UoJ3NlbmQgbWVzc2FnZScpO1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSh0aGlzLl9mb3JtYXRFcnJvcihpc0Rlc3Ryb3llZE1lc3NhZ2UsICdFQ09OTkVDVElPTicsIGZhbHNlLCAnQVBJJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVqZWN0IGxhcmdlciBtZXNzYWdlcyB0aGFuIGFsbG93ZWRcbiAgICAgICAgaWYgKHRoaXMuX21heEFsbG93ZWRTaXplICYmIGVudmVsb3BlLnNpemUgPiB0aGlzLl9tYXhBbGxvd2VkU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9uZSh0aGlzLl9mb3JtYXRFcnJvcignTWVzc2FnZSBzaXplIGxhcmdlciB0aGFuIGFsbG93ZWQgJyArIHRoaXMuX21heEFsbG93ZWRTaXplLCAnRU1FU1NBR0UnLCBmYWxzZSwgJ01BSUwgRlJPTScpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgY2FsbGJhY2sgaXMgb25seSBjYWxsZWQgb25jZVxuICAgICAgICBsZXQgcmV0dXJuZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBkb25lKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtZXNzYWdlLm9uKCdlcnJvcicsIGVyciA9PiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcihlcnIsICdFU1RSRUFNJywgZmFsc2UsICdBUEknKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuX3NldEVudmVsb3BlKGVudmVsb3BlLCAoZXJyLCBpbmZvKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZW52ZWxvcGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGxldCBzdHJlYW0gPSB0aGlzLl9jcmVhdGVTZW5kU3RyZWFtKChlcnIsIHN0cikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5mby5lbnZlbG9wZVRpbWUgPSBlbnZlbG9wZVRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgaW5mby5tZXNzYWdlVGltZSA9IERhdGUubm93KCkgLSBlbnZlbG9wZVRpbWU7XG4gICAgICAgICAgICAgICAgaW5mby5tZXNzYWdlU2l6ZSA9IHN0cmVhbS5vdXRCeXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgaW5mby5yZXNwb25zZSA9IHN0cjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnBpcGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnBpcGUoc3RyZWFtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLndyaXRlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIGNvbm5lY3Rpb24gc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJldHVybiBvbmNlIGNvbm5lY3Rpb24gaXMgcmVzZXRcbiAgICAgKi9cbiAgICByZXNldChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnUlNFVCcpO1xuICAgICAgICB0aGlzLl9yZXNwb25zZUFjdGlvbnMucHVzaChzdHIgPT4ge1xuICAgICAgICAgICAgaWYgKHN0ci5jaGFyQXQoMCkgIT09ICcyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcignQ291bGQgbm90IHJlc2V0IHNlc3Npb24gc3RhdGUuIHJlc3BvbnNlPScgKyBzdHIsICdFUFJPVE9DT0wnLCBzdHIsICdSU0VUJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZW52ZWxvcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29ubmVjdGlvbiBsaXN0ZW5lciB0aGF0IGlzIHJ1biB3aGVuIHRoZSBjb25uZWN0aW9uIHRvXG4gICAgICogdGhlIHNlcnZlciBpcyBvcGVuZWRcbiAgICAgKlxuICAgICAqIEBldmVudFxuICAgICAqL1xuICAgIF9vbkNvbm5lY3QoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jb25uZWN0aW9uVGltZW91dCk7XG5cbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0bng6ICduZXR3b3JrJyxcbiAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IHRoaXMuX3NvY2tldC5sb2NhbEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgbG9jYWxQb3J0OiB0aGlzLl9zb2NrZXQubG9jYWxQb3J0LFxuICAgICAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IHRoaXMuX3NvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgICAgIHJlbW90ZVBvcnQ6IHRoaXMuX3NvY2tldC5yZW1vdGVQb3J0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyVzIGVzdGFibGlzaGVkIHRvICVzOiVzJyxcbiAgICAgICAgICAgIHRoaXMuc2VjdXJlID8gJ1NlY3VyZSBjb25uZWN0aW9uJyA6ICdDb25uZWN0aW9uJyxcbiAgICAgICAgICAgIHRoaXMuX3NvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgdGhpcy5fc29ja2V0LnJlbW90ZVBvcnRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAvLyBDb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCBhZnRlciB3ZSBhbHJlYWR5IGhhZCBjYW5jZWxlZCBpdFxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGFnZSA9ICdjb25uZWN0ZWQnO1xuXG4gICAgICAgIC8vIGNsZWFyIGV4aXN0aW5nIGxpc3RlbmVycyBmb3IgdGhlIHNvY2tldFxuICAgICAgICB0aGlzLl9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCB0aGlzLl9vblNvY2tldERhdGEpO1xuICAgICAgICB0aGlzLl9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ3RpbWVvdXQnLCB0aGlzLl9vblNvY2tldFRpbWVvdXQpO1xuICAgICAgICB0aGlzLl9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy5fb25Tb2NrZXRDbG9zZSk7XG4gICAgICAgIHRoaXMuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZW5kJywgdGhpcy5fb25Tb2NrZXRFbmQpO1xuXG4gICAgICAgIHRoaXMuX3NvY2tldC5vbignZGF0YScsIHRoaXMuX29uU29ja2V0RGF0YSk7XG4gICAgICAgIHRoaXMuX3NvY2tldC5vbmNlKCdjbG9zZScsIHRoaXMuX29uU29ja2V0Q2xvc2UpO1xuICAgICAgICB0aGlzLl9zb2NrZXQub25jZSgnZW5kJywgdGhpcy5fb25Tb2NrZXRFbmQpO1xuXG4gICAgICAgIHRoaXMuX3NvY2tldC5zZXRUaW1lb3V0KHRoaXMub3B0aW9ucy5zb2NrZXRUaW1lb3V0IHx8IFNPQ0tFVF9USU1FT1VUKTtcbiAgICAgICAgdGhpcy5fc29ja2V0Lm9uKCd0aW1lb3V0JywgdGhpcy5fb25Tb2NrZXRUaW1lb3V0KTtcblxuICAgICAgICB0aGlzLl9ncmVldGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIHN0aWxsIHdhaXRpbmcgZm9yIGdyZWV0aW5nLCBnaXZlIHVwXG4gICAgICAgICAgICBpZiAodGhpcy5fc29ja2V0ICYmICF0aGlzLl9kZXN0cm95ZWQgJiYgdGhpcy5fcmVzcG9uc2VBY3Rpb25zWzBdID09PSB0aGlzLl9hY3Rpb25HcmVldGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoJ0dyZWV0aW5nIG5ldmVyIHJlY2VpdmVkJywgJ0VUSU1FRE9VVCcsIGZhbHNlLCAnQ09OTicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuZ3JlZXRpbmdUaW1lb3V0IHx8IEdSRUVUSU5HX1RJTUVPVVQpO1xuXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKHRoaXMuX2FjdGlvbkdyZWV0aW5nKTtcblxuICAgICAgICAvLyB3ZSBoYXZlIGEgJ2RhdGEnIGxpc3RlbmVyIHNldCB1cCBzbyByZXN1bWUgc29ja2V0IGlmIGl0IHdhcyBwYXVzZWRcbiAgICAgICAgdGhpcy5fc29ja2V0LnJlc3VtZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICdkYXRhJyBsaXN0ZW5lciBmb3IgZGF0YSBjb21pbmcgZnJvbSB0aGUgc2VydmVyXG4gICAgICpcbiAgICAgKiBAZXZlbnRcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgRGF0YSBjaHVuayBjb21pbmcgZnJvbSB0aGUgc2VydmVyXG4gICAgICovXG4gICAgX29uRGF0YShjaHVuaykge1xuICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkIHx8ICFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGF0YSA9IChjaHVuayB8fCAnJykudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgICBsZXQgbGluZXMgPSAodGhpcy5fcmVtYWluZGVyICsgZGF0YSkuc3BsaXQoL1xccj9cXG4vKTtcbiAgICAgICAgbGV0IGxhc3RsaW5lO1xuXG4gICAgICAgIHRoaXMuX3JlbWFpbmRlciA9IGxpbmVzLnBvcCgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc3BvbnNlUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGFzdGxpbmUgPSB0aGlzLl9yZXNwb25zZVF1ZXVlW3RoaXMuX3Jlc3BvbnNlUXVldWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKC9eXFxkKy0vLnRlc3QobGFzdGxpbmUuc3BsaXQoJ1xcbicpLnBvcCgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25zZVF1ZXVlW3RoaXMuX3Jlc3BvbnNlUXVldWUubGVuZ3RoIC0gMV0gKz0gJ1xcbicgKyBsaW5lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VRdWV1ZS5wdXNoKGxpbmVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9yZXNwb25zZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGFzdGxpbmUgPSB0aGlzLl9yZXNwb25zZVF1ZXVlW3RoaXMuX3Jlc3BvbnNlUXVldWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoL15cXGQrLS8udGVzdChsYXN0bGluZS5zcGxpdCgnXFxuJykucG9wKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHJvY2Vzc1Jlc3BvbnNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogJ2Vycm9yJyBsaXN0ZW5lciBmb3IgdGhlIHNvY2tldFxuICAgICAqXG4gICAgICogQGV2ZW50XG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyIEVycm9yIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEVycm9yIG5hbWVcbiAgICAgKi9cbiAgICBfb25FcnJvcihlcnIsIHR5cGUsIGRhdGEsIGNvbW1hbmQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Nvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2dyZWV0aW5nVGltZW91dCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgLy8ganVzdCBpZ25vcmUsIGFscmVhZHkgY2xvc2VkXG4gICAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGhhcHBlbiB3aGVuIGEgc29ja2V0IGlzIGNhbmNlbGVkIGJlY2F1c2Ugb2YgcmVhY2hlZCB0aW1lb3V0XG4gICAgICAgICAgICAvLyBidXQgdGhlIHNvY2tldCB0aW1lb3V0IGVycm9yIGl0c2VsZiByZWNlaXZlcyBvbmx5IGFmdGVyXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlcnIgPSB0aGlzLl9mb3JtYXRFcnJvcihlcnIsIHR5cGUsIGRhdGEsIGNvbW1hbmQpO1xuXG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGRhdGEsIGVyci5tZXNzYWdlKTtcblxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cblxuICAgIF9mb3JtYXRFcnJvcihtZXNzYWdlLCB0eXBlLCByZXNwb25zZSwgY29tbWFuZCkge1xuICAgICAgICBsZXQgZXJyO1xuXG4gICAgICAgIGlmICgvRXJyb3JcXF0kL2kudGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZSkpKSB7XG4gICAgICAgICAgICBlcnIgPSBtZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgJiYgdHlwZSAhPT0gJ0Vycm9yJykge1xuICAgICAgICAgICAgZXJyLmNvZGUgPSB0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBlcnIucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgIGVyci5tZXNzYWdlICs9ICc6ICcgKyByZXNwb25zZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXNwb25zZUNvZGUgPSAodHlwZW9mIHJlc3BvbnNlID09PSAnc3RyaW5nJyAmJiBOdW1iZXIoKHJlc3BvbnNlLm1hdGNoKC9eXFxkKy8pIHx8IFtdKVswXSkpIHx8IGZhbHNlO1xuICAgICAgICBpZiAocmVzcG9uc2VDb2RlKSB7XG4gICAgICAgICAgICBlcnIucmVzcG9uc2VDb2RlID0gcmVzcG9uc2VDb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGVyci5jb21tYW5kID0gY29tbWFuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogJ2Nsb3NlJyBsaXN0ZW5lciBmb3IgdGhlIHNvY2tldFxuICAgICAqXG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgX29uQ2xvc2UoKSB7XG4gICAgICAgIGxldCBzZXJ2ZXJSZXNwb25zZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLl9yZW1haW5kZXIgJiYgdGhpcy5fcmVtYWluZGVyLnRyaW0oKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1ZyB8fCB0aGlzLm9wdGlvbnMudHJhbnNhY3Rpb25Mb2cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG54OiAnc2VydmVyJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1haW5kZXIucmVwbGFjZSgvXFxyP1xcbiQvLCAnJylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXN0U2VydmVyUmVzcG9uc2UgPSBzZXJ2ZXJSZXNwb25zZSA9IHRoaXMuX3JlbWFpbmRlci50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRueDogJ25ldHdvcmsnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ0Nvbm5lY3Rpb24gY2xvc2VkJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZyAmJiAhdGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25FcnJvcihuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gY2xvc2VkIHVuZXhwZWN0ZWRseScpLCAnRVRMUycsIHNlcnZlclJlc3BvbnNlLCAnQ09OTicpO1xuICAgICAgICB9IGVsc2UgaWYgKCFbdGhpcy5fYWN0aW9uR3JlZXRpbmcsIHRoaXMuY2xvc2VdLmluY2x1ZGVzKHRoaXMuX3Jlc3BvbnNlQWN0aW9uc1swXSkgJiYgIXRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdDb25uZWN0aW9uIGNsb3NlZCB1bmV4cGVjdGVkbHknKSwgJ0VDT05ORUNUSU9OJywgc2VydmVyUmVzcG9uc2UsICdDT05OJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoL15bNDVdXFxkezJ9XFxiLy50ZXN0KHNlcnZlclJlc3BvbnNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdDb25uZWN0aW9uIGNsb3NlZCB1bmV4cGVjdGVkbHknKSwgJ0VDT05ORUNUSU9OJywgc2VydmVyUmVzcG9uc2UsICdDT05OJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogJ2VuZCcgbGlzdGVuZXIgZm9yIHRoZSBzb2NrZXRcbiAgICAgKlxuICAgICAqIEBldmVudFxuICAgICAqL1xuICAgIF9vbkVuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2tldCAmJiAhdGhpcy5fc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICd0aW1lb3V0JyBsaXN0ZW5lciBmb3IgdGhlIHNvY2tldFxuICAgICAqXG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgX29uVGltZW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdUaW1lb3V0JyksICdFVElNRURPVVQnLCBmYWxzZSwgJ0NPTk4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgY2xpZW50LCBlbWl0cyAnZW5kJ1xuICAgICAqL1xuICAgIF9kZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGdyYWRlcyB0aGUgY29ubmVjdGlvbiB0byBUTFNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSBjb25uZWN0aW9uXG4gICAgICogICAgICAgIGhhcyBiZWVuIHNlY3VyZWRcbiAgICAgKi9cbiAgICBfdXBncmFkZUNvbm5lY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgLy8gZG8gbm90IHJlbW92ZSBhbGwgbGlzdGVuZXJzIG9yIGl0IGJyZWFrcyBub2RlIHYwLjEwIGFzIHRoZXJlJ3NcbiAgICAgICAgLy8gYXBwYXJlbnRseSBhICdmaW5pc2gnIGV2ZW50IHNldCB0aGF0IHdvdWxkIGJlIGNsZWFyZWQgYXMgd2VsbFxuXG4gICAgICAgIC8vIHdlIGNhbiBzYWZlbHkga2VlcCAnZXJyb3InLCAnZW5kJywgJ2Nsb3NlJyBldGMuIGV2ZW50c1xuICAgICAgICB0aGlzLl9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCB0aGlzLl9vblNvY2tldERhdGEpOyAvLyBpbmNvbWluZyBkYXRhIGlzIGdvaW5nIHRvIGJlIGdpYmJlcmlzaCBmcm9tIHRoaXMgcG9pbnQgb253YXJkc1xuICAgICAgICB0aGlzLl9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ3RpbWVvdXQnLCB0aGlzLl9vblNvY2tldFRpbWVvdXQpOyAvLyB0aW1lb3V0IHdpbGwgYmUgcmUtc2V0IGZvciB0aGUgbmV3IHNvY2tldCBvYmplY3RcblxuICAgICAgICBsZXQgc29ja2V0UGxhaW4gPSB0aGlzLl9zb2NrZXQ7XG4gICAgICAgIGxldCBvcHRzID0ge1xuICAgICAgICAgICAgc29ja2V0OiB0aGlzLl9zb2NrZXQsXG4gICAgICAgICAgICBob3N0OiB0aGlzLmhvc3RcbiAgICAgICAgfTtcblxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMudGxzIHx8IHt9KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBvcHRzW2tleV0gPSB0aGlzLm9wdGlvbnMudGxzW2tleV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGVuc3VyZSBzZXJ2ZXJuYW1lIGZvciBTTklcbiAgICAgICAgaWYgKHRoaXMuc2VydmVybmFtZSAmJiAhb3B0cy5zZXJ2ZXJuYW1lKSB7XG4gICAgICAgICAgICBvcHRzLnNlcnZlcm5hbWUgPSB0aGlzLnNlcnZlcm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIC8vIHRscy5jb25uZWN0IGlzIG5vdCBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gaG93ZXZlciBpdCBtYXkgc3RpbGwgdGhyb3cgZXJyb3JzIGFuZCByZXF1aXJlcyB0byBiZSB3cmFwcGVkIHdpdGggdHJ5L2NhdGNoXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXQgPSB0bHMuY29ubmVjdChvcHRzLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fc29ja2V0Lm9uKCdkYXRhJywgdGhpcy5fb25Tb2NrZXREYXRhKTtcblxuICAgICAgICAgICAgICAgIHNvY2tldFBsYWluLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHRoaXMuX29uU29ja2V0Q2xvc2UpO1xuICAgICAgICAgICAgICAgIHNvY2tldFBsYWluLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB0aGlzLl9vblNvY2tldEVuZCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NvY2tldC5vbignZXJyb3InLCB0aGlzLl9vblNvY2tldEVycm9yKTtcbiAgICAgICAgdGhpcy5fc29ja2V0Lm9uY2UoJ2Nsb3NlJywgdGhpcy5fb25Tb2NrZXRDbG9zZSk7XG4gICAgICAgIHRoaXMuX3NvY2tldC5vbmNlKCdlbmQnLCB0aGlzLl9vblNvY2tldEVuZCk7XG5cbiAgICAgICAgdGhpcy5fc29ja2V0LnNldFRpbWVvdXQodGhpcy5vcHRpb25zLnNvY2tldFRpbWVvdXQgfHwgU09DS0VUX1RJTUVPVVQpOyAvLyAxMCBtaW4uXG4gICAgICAgIHRoaXMuX3NvY2tldC5vbigndGltZW91dCcsIHRoaXMuX29uU29ja2V0VGltZW91dCk7XG5cbiAgICAgICAgLy8gcmVzdW1lIGluIGNhc2UgdGhlIHNvY2tldCB3YXMgcGF1c2VkXG4gICAgICAgIHNvY2tldFBsYWluLnJlc3VtZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBxdWV1ZWQgcmVzcG9uc2VzIGZyb20gdGhlIHNlcnZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSBJZiB0cnVlLCBpZ25vcmVzIF9wcm9jZXNzaW5nIGZsYWdcbiAgICAgKi9cbiAgICBfcHJvY2Vzc1Jlc3BvbnNlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc3BvbnNlUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RyID0gKHRoaXMubGFzdFNlcnZlclJlc3BvbnNlID0gKHRoaXMuX3Jlc3BvbnNlUXVldWUuc2hpZnQoKSB8fCAnJykudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgaWYgKC9eXFxkKy0vLnRlc3Qoc3RyLnNwbGl0KCdcXG4nKS5wb3AoKSkpIHtcbiAgICAgICAgICAgIC8vIGtlZXAgd2FpdGluZyBmb3IgdGhlIGZpbmFsIHBhcnQgb2YgbXVsdGlsaW5lIHJlc3BvbnNlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnIHx8IHRoaXMub3B0aW9ucy50cmFuc2FjdGlvbkxvZykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0bng6ICdzZXJ2ZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHIucmVwbGFjZSgvXFxyP1xcbiQvLCAnJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0ci50cmltKCkpIHtcbiAgICAgICAgICAgIC8vIHNraXAgdW5leHBlY3RlZCBlbXB0eSBsaW5lc1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3Byb2Nlc3NSZXNwb25zZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLl9yZXNwb25zZUFjdGlvbnMuc2hpZnQoKTtcblxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYWN0aW9uLmNhbGwodGhpcywgc3RyKTtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9wcm9jZXNzUmVzcG9uc2UoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25FcnJvcihuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgUmVzcG9uc2UnKSwgJ0VQUk9UT0NPTCcsIHN0ciwgJ0NPTk4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBjb21tYW5kIHRvIHRoZSBzZXJ2ZXIsIGFwcGVuZCBcXHJcXG5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2dTdHIgT3B0aW9uYWwgc3RyaW5nIHRvIGJlIHVzZWQgZm9yIGxvZ2dpbmcgaW5zdGVhZCBvZiB0aGUgYWN0dWFsIHN0cmluZ1xuICAgICAqL1xuICAgIF9zZW5kQ29tbWFuZChzdHIsIGxvZ1N0cikge1xuICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAvLyBDb25uZWN0aW9uIGFscmVhZHkgY2xvc2VkLCBjYW4ndCBzZW5kIGFueSBtb3JlIGRhdGFcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1ZyB8fCB0aGlzLm9wdGlvbnMudHJhbnNhY3Rpb25Mb2cpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG54OiAnY2xpZW50J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGxvZ1N0ciB8fCBzdHIgfHwgJycpLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxyP1xcbiQvLCAnJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zb2NrZXQud3JpdGUoQnVmZmVyLmZyb20oc3RyICsgJ1xcclxcbicsICd1dGYtOCcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgYSBuZXcgbWVzc2FnZSBieSBzdWJtaXR0aW5nIGVudmVsb3BlIGRhdGEsIHN0YXJ0aW5nIHdpdGhcbiAgICAgKiBNQUlMIEZST006IGNvbW1hbmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZlbG9wZSBFbnZlbG9wZSBvYmplY3QgaW4gdGhlIGZvcm0gb2ZcbiAgICAgKiAgICAgICAge2Zyb206Jy4uLicsIHRvOlsnLi4uJ119XG4gICAgICogICAgICAgIG9yXG4gICAgICogICAgICAgIHtmcm9tOnthZGRyZXNzOicuLi4nLG5hbWU6Jy4uLid9LCB0bzpbYWRkcmVzczonLi4uJyxuYW1lOicuLi4nXX1cbiAgICAgKi9cbiAgICBfc2V0RW52ZWxvcGUoZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBhcmdzID0gW107XG4gICAgICAgIGxldCB1c2VTbXRwVXRmOCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2VudmVsb3BlID0gZW52ZWxvcGUgfHwge307XG4gICAgICAgIHRoaXMuX2VudmVsb3BlLmZyb20gPSAoKHRoaXMuX2VudmVsb3BlLmZyb20gJiYgdGhpcy5fZW52ZWxvcGUuZnJvbS5hZGRyZXNzKSB8fCB0aGlzLl9lbnZlbG9wZS5mcm9tIHx8ICcnKS50b1N0cmluZygpLnRyaW0oKTtcblxuICAgICAgICB0aGlzLl9lbnZlbG9wZS50byA9IFtdLmNvbmNhdCh0aGlzLl9lbnZlbG9wZS50byB8fCBbXSkubWFwKHRvID0+ICgodG8gJiYgdG8uYWRkcmVzcykgfHwgdG8gfHwgJycpLnRvU3RyaW5nKCkudHJpbSgpKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2VudmVsb3BlLnRvLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdObyByZWNpcGllbnRzIGRlZmluZWQnLCAnRUVOVkVMT1BFJywgZmFsc2UsICdBUEknKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZW52ZWxvcGUuZnJvbSAmJiAvW1xcclxcbjw+XS8udGVzdCh0aGlzLl9lbnZlbG9wZS5mcm9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdJbnZhbGlkIHNlbmRlciAnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5fZW52ZWxvcGUuZnJvbSksICdFRU5WRUxPUEUnLCBmYWxzZSwgJ0FQSScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzZW5kZXIgYWRkcmVzcyB1c2VzIG9ubHkgQVNDSUkgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHJlcXVpcmUgdXNhZ2Ugb2YgU01UUFVURjggZXh0ZW5zaW9uXG4gICAgICAgIGlmICgvW1xceDgwLVxcdUZGRkZdLy50ZXN0KHRoaXMuX2VudmVsb3BlLmZyb20pKSB7XG4gICAgICAgICAgICB1c2VTbXRwVXRmOCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fZW52ZWxvcGUudG8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZW52ZWxvcGUudG9baV0gfHwgL1tcXHJcXG48Pl0vLnRlc3QodGhpcy5fZW52ZWxvcGUudG9baV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdJbnZhbGlkIHJlY2lwaWVudCAnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5fZW52ZWxvcGUudG9baV0pLCAnRUVOVkVMT1BFJywgZmFsc2UsICdBUEknKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSByZWNpcGllbnRzIGFkZHJlc3NlcyB1c2Ugb25seSBBU0NJSSBjaGFyYWN0ZXJzLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHJlcXVpcmUgdXNhZ2Ugb2YgU01UUFVURjggZXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAoL1tcXHg4MC1cXHVGRkZGXS8udGVzdCh0aGlzLl9lbnZlbG9wZS50b1tpXSkpIHtcbiAgICAgICAgICAgICAgICB1c2VTbXRwVXRmOCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbG9uZSB0aGUgcmVjaXBpZW50cyBhcnJheSBmb3IgbGF0dGVyIG1hbmlwdWxhdGlvblxuICAgICAgICB0aGlzLl9lbnZlbG9wZS5yY3B0UXVldWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX2VudmVsb3BlLnRvIHx8IFtdKSk7XG4gICAgICAgIHRoaXMuX2VudmVsb3BlLnJlamVjdGVkID0gW107XG4gICAgICAgIHRoaXMuX2VudmVsb3BlLnJlamVjdGVkRXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuX2VudmVsb3BlLmFjY2VwdGVkID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuX2VudmVsb3BlLmRzbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnZlbG9wZS5kc24gPSB0aGlzLl9zZXREc25FbnZlbG9wZSh0aGlzLl9lbnZlbG9wZS5kc24pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdJbnZhbGlkIERTTiAnICsgZXJyLm1lc3NhZ2UsICdFRU5WRUxPUEUnLCBmYWxzZSwgJ0FQSScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKHN0ciA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25NQUlMKHN0ciwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJZiB0aGUgc2VydmVyIHN1cHBvcnRzIFNNVFBVVEY4IGFuZCB0aGUgZW52ZWxvcGUgaW5jbHVkZXMgYW4gaW50ZXJuYXRpb25hbGl6ZWRcbiAgICAgICAgLy8gZW1haWwgYWRkcmVzcyB0aGVuIGFwcGVuZCBTTVRQVVRGOCBrZXl3b3JkIHRvIHRoZSBNQUlMIEZST00gY29tbWFuZFxuICAgICAgICBpZiAodXNlU210cFV0ZjggJiYgdGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucy5pbmNsdWRlcygnU01UUFVURjgnKSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKCdTTVRQVVRGOCcpO1xuICAgICAgICAgICAgdGhpcy5fdXNpbmdTbXRwVXRmOCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgc2VydmVyIHN1cHBvcnRzIDhCSVRNSU1FIGFuZCB0aGUgbWVzc2FnZSBtaWdodCBjb250YWluIG5vbi1hc2NpaSBieXRlc1xuICAgICAgICAvLyB0aGVuIGFwcGVuZCB0aGUgOEJJVE1JTUUga2V5d29yZCB0byB0aGUgTUFJTCBGUk9NIGNvbW1hbmRcbiAgICAgICAgaWYgKHRoaXMuX2VudmVsb3BlLnVzZThCaXRNaW1lICYmIHRoaXMuX3N1cHBvcnRlZEV4dGVuc2lvbnMuaW5jbHVkZXMoJzhCSVRNSU1FJykpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaCgnQk9EWT04QklUTUlNRScpO1xuICAgICAgICAgICAgdGhpcy5fdXNpbmc4Qml0TWltZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZW52ZWxvcGUuc2l6ZSAmJiB0aGlzLl9zdXBwb3J0ZWRFeHRlbnNpb25zLmluY2x1ZGVzKCdTSVpFJykpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaCgnU0laRT0nICsgdGhpcy5fZW52ZWxvcGUuc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgc2VydmVyIHN1cHBvcnRzIERTTiBhbmQgdGhlIGVudmVsb3BlIGluY2x1ZGVzIGFuIERTTiBwcm9wXG4gICAgICAgIC8vIHRoZW4gYXBwZW5kIERTTiBwYXJhbXMgdG8gdGhlIE1BSUwgRlJPTSBjb21tYW5kXG4gICAgICAgIGlmICh0aGlzLl9lbnZlbG9wZS5kc24gJiYgdGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucy5pbmNsdWRlcygnRFNOJykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbnZlbG9wZS5kc24ucmV0KSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKCdSRVQ9JyArIHNoYXJlZC5lbmNvZGVYVGV4dCh0aGlzLl9lbnZlbG9wZS5kc24ucmV0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fZW52ZWxvcGUuZHNuLmVudmlkKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKCdFTlZJRD0nICsgc2hhcmVkLmVuY29kZVhUZXh0KHRoaXMuX2VudmVsb3BlLmRzbi5lbnZpZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoJ01BSUwgRlJPTTo8JyArIHRoaXMuX2VudmVsb3BlLmZyb20gKyAnPicgKyAoYXJncy5sZW5ndGggPyAnICcgKyBhcmdzLmpvaW4oJyAnKSA6ICcnKSk7XG4gICAgfVxuXG4gICAgX3NldERzbkVudmVsb3BlKHBhcmFtcykge1xuICAgICAgICBsZXQgcmV0ID0gKHBhcmFtcy5yZXQgfHwgcGFyYW1zLnJldHVybiB8fCAnJykudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpIHx8IG51bGw7XG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmV0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnSERSUyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnSEVBREVSUyc6XG4gICAgICAgICAgICAgICAgICAgIHJldCA9ICdIRFJTJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRlVMTCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnQk9EWSc6XG4gICAgICAgICAgICAgICAgICAgIHJldCA9ICdGVUxMJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0ICYmICFbJ0ZVTEwnLCAnSERSUyddLmluY2x1ZGVzKHJldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0OiAnICsgSlNPTi5zdHJpbmdpZnkocmV0KSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZW52aWQgPSAocGFyYW1zLmVudmlkIHx8IHBhcmFtcy5pZCB8fCAnJykudG9TdHJpbmcoKSB8fCBudWxsO1xuXG4gICAgICAgIGxldCBub3RpZnkgPSBwYXJhbXMubm90aWZ5IHx8IG51bGw7XG4gICAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm90aWZ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG5vdGlmeSA9IG5vdGlmeS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm90aWZ5ID0gbm90aWZ5Lm1hcChuID0+IG4udHJpbSgpLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgICAgbGV0IHZhbGlkTm90aWZ5ID0gWydORVZFUicsICdTVUNDRVNTJywgJ0ZBSUxVUkUnLCAnREVMQVknXTtcbiAgICAgICAgICAgIGxldCBpbnZhbGlOb3RpZnkgPSBub3RpZnkuZmlsdGVyKG4gPT4gIXZhbGlkTm90aWZ5LmluY2x1ZGVzKG4pKTtcbiAgICAgICAgICAgIGlmIChpbnZhbGlOb3RpZnkubGVuZ3RoIHx8IChub3RpZnkubGVuZ3RoID4gMSAmJiBub3RpZnkuaW5jbHVkZXMoJ05FVkVSJykpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3RpZnk6ICcgKyBKU09OLnN0cmluZ2lmeShub3RpZnkuam9pbignLCcpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3RpZnkgPSBub3RpZnkuam9pbignLCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9yY3B0ID0gKHBhcmFtcy5yZWNpcGllbnQgfHwgcGFyYW1zLm9yY3B0IHx8ICcnKS50b1N0cmluZygpIHx8IG51bGw7XG4gICAgICAgIGlmIChvcmNwdCAmJiBvcmNwdC5pbmRleE9mKCc7JykgPCAwKSB7XG4gICAgICAgICAgICBvcmNwdCA9ICdyZmM4MjI7JyArIG9yY3B0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGVudmlkLFxuICAgICAgICAgICAgbm90aWZ5LFxuICAgICAgICAgICAgb3JjcHRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfZ2V0RHNuUmNwdFRvQXJncygpIHtcbiAgICAgICAgbGV0IGFyZ3MgPSBbXTtcbiAgICAgICAgLy8gSWYgdGhlIHNlcnZlciBzdXBwb3J0cyBEU04gYW5kIHRoZSBlbnZlbG9wZSBpbmNsdWRlcyBhbiBEU04gcHJvcFxuICAgICAgICAvLyB0aGVuIGFwcGVuZCBEU04gcGFyYW1zIHRvIHRoZSBSQ1BUIFRPIGNvbW1hbmRcbiAgICAgICAgaWYgKHRoaXMuX2VudmVsb3BlLmRzbiAmJiB0aGlzLl9zdXBwb3J0ZWRFeHRlbnNpb25zLmluY2x1ZGVzKCdEU04nKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VudmVsb3BlLmRzbi5ub3RpZnkpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ05PVElGWT0nICsgc2hhcmVkLmVuY29kZVhUZXh0KHRoaXMuX2VudmVsb3BlLmRzbi5ub3RpZnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9lbnZlbG9wZS5kc24ub3JjcHQpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ09SQ1BUPScgKyBzaGFyZWQuZW5jb2RlWFRleHQodGhpcy5fZW52ZWxvcGUuZHNuLm9yY3B0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoID8gJyAnICsgYXJncy5qb2luKCcgJykgOiAnJztcbiAgICB9XG5cbiAgICBfY3JlYXRlU2VuZFN0cmVhbShjYWxsYmFjaykge1xuICAgICAgICBsZXQgZGF0YVN0cmVhbSA9IG5ldyBEYXRhU3RyZWFtKCk7XG4gICAgICAgIGxldCBsb2dTdHJlYW07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sbXRwKSB7XG4gICAgICAgICAgICB0aGlzLl9lbnZlbG9wZS5hY2NlcHRlZC5mb3JFYWNoKChyZWNpcGllbnQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZmluYWwgPSBpID09PSB0aGlzLl9lbnZlbG9wZS5hY2NlcHRlZC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKHN0ciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbkxNVFBTdHJlYW0ocmVjaXBpZW50LCBmaW5hbCwgc3RyLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKHN0ciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uU01UUFN0cmVhbShzdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVN0cmVhbS5waXBlKHRoaXMuX3NvY2tldCwge1xuICAgICAgICAgICAgZW5kOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICBsb2dTdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goKTtcbiAgICAgICAgICAgIGxvZ1N0cmVhbS5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNodW5rO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoY2h1bmsgPSBsb2dTdHJlYW0ucmVhZCgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bng6ICdtZXNzYWdlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnRvU3RyaW5nKCdiaW5hcnknKS5yZXBsYWNlKC9cXHI/XFxuJC8sICcnKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YVN0cmVhbS5waXBlKGxvZ1N0cmVhbSk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhU3RyZWFtLm9uY2UoJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0bng6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgaW5CeXRlQ291bnQ6IGRhdGFTdHJlYW0uaW5CeXRlQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIG91dEJ5dGVDb3VudDogZGF0YVN0cmVhbS5vdXRCeXRlQ291bnRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICc8JXMgYnl0ZXMgZW5jb2RlZCBtaW1lIG1lc3NhZ2UgKHNvdXJjZSBzaXplICVzIGJ5dGVzKT4nLFxuICAgICAgICAgICAgICAgIGRhdGFTdHJlYW0ub3V0Qnl0ZUNvdW50LFxuICAgICAgICAgICAgICAgIGRhdGFTdHJlYW0uaW5CeXRlQ291bnRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkYXRhU3RyZWFtO1xuICAgIH1cblxuICAgIC8qKiBBQ1RJT05TICoqL1xuXG4gICAgLyoqXG4gICAgICogV2lsbCBiZSBydW4gYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gaXMgY3JlYXRlZCBhbmQgdGhlIHNlcnZlciBzZW5kc1xuICAgICAqIGEgZ3JlZXRpbmcuIElmIHRoZSBpbmNvbWluZyBtZXNzYWdlIHN0YXJ0cyB3aXRoIDIyMCBpbml0aWF0ZVxuICAgICAqIFNNVFAgc2Vzc2lvbiBieSBzZW5kaW5nIEVITE8gY29tbWFuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICAgICAqL1xuICAgIF9hY3Rpb25HcmVldGluZyhzdHIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2dyZWV0aW5nVGltZW91dCk7XG5cbiAgICAgICAgaWYgKHN0ci5zdWJzdHIoMCwgMykgIT09ICcyMjAnKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKG5ldyBFcnJvcignSW52YWxpZCBncmVldGluZy4gcmVzcG9uc2U9JyArIHN0ciksICdFUFJPVE9DT0wnLCBzdHIsICdDT05OJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxtdHApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKHRoaXMuX2FjdGlvbkxITE8pO1xuICAgICAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoJ0xITE8gJyArIHRoaXMubmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25zZUFjdGlvbnMucHVzaCh0aGlzLl9hY3Rpb25FSExPKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdFSExPICcgKyB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBzZXJ2ZXIgcmVzcG9uc2UgZm9yIExITE8gY29tbWFuZC4gSWYgaXQgeWllbGRlZCBpblxuICAgICAqIGVycm9yLCBlbWl0ICdlcnJvcicsIG90aGVyd2lzZSB0cmVhdCB0aGlzIGFzIGFuIEVITE8gcmVzcG9uc2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgTWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBfYWN0aW9uTEhMTyhzdHIpIHtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMCkgIT09ICcyJykge1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgTEhMTy4gcmVzcG9uc2U9JyArIHN0ciksICdFUFJPVE9DT0wnLCBzdHIsICdMSExPJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hY3Rpb25FSExPKHN0cik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBzZXJ2ZXIgcmVzcG9uc2UgZm9yIEVITE8gY29tbWFuZC4gSWYgaXQgeWllbGRlZCBpblxuICAgICAqIGVycm9yLCB0cnkgSEVMTyBpbnN0ZWFkLCBvdGhlcndpc2UgaW5pdGlhdGUgVExTIG5lZ290aWF0aW9uXG4gICAgICogaWYgU1RBUlRUTFMgaXMgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXIgb3IgbW92ZSBpbnRvIHRoZVxuICAgICAqIGF1dGhlbnRpY2F0aW9uIHBoYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICAgICAqL1xuICAgIF9hY3Rpb25FSExPKHN0cikge1xuICAgICAgICBsZXQgbWF0Y2g7XG5cbiAgICAgICAgaWYgKHN0ci5zdWJzdHIoMCwgMykgPT09ICc0MjEnKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKG5ldyBFcnJvcignU2VydmVyIHRlcm1pbmF0ZXMgY29ubmVjdGlvbi4gcmVzcG9uc2U9JyArIHN0ciksICdFQ09OTkVDVElPTicsIHN0ciwgJ0VITE8nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHIuY2hhckF0KDApICE9PSAnMicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVxdWlyZVRMUykge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdFSExPIGZhaWxlZCBidXQgSEVMTyBkb2VzIG5vdCBzdXBwb3J0IHJlcXVpcmVkIFNUQVJUVExTLiByZXNwb25zZT0nICsgc3RyKSwgJ0VDT05ORUNUSU9OJywgc3RyLCAnRUhMTycpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVHJ5IEhFTE8gaW5zdGVhZFxuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2godGhpcy5fYWN0aW9uSEVMTyk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnSEVMTyAnICsgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VobG9MaW5lcyA9IHN0clxuICAgICAgICAgICAgLnNwbGl0KC9cXHI/XFxuLylcbiAgICAgICAgICAgIC5tYXAobGluZSA9PiBsaW5lLnJlcGxhY2UoL15cXGQrWyAtXS8sICcnKS50cmltKCkpXG4gICAgICAgICAgICAuZmlsdGVyKGxpbmUgPT4gbGluZSlcbiAgICAgICAgICAgIC5zbGljZSgxKTtcblxuICAgICAgICAvLyBEZXRlY3QgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBTVEFSVFRMU1xuICAgICAgICBpZiAoIXRoaXMuc2VjdXJlICYmICF0aGlzLm9wdGlvbnMuaWdub3JlVExTICYmICgvWyAtXVNUQVJUVExTXFxiL2ltLnRlc3Qoc3RyKSB8fCB0aGlzLm9wdGlvbnMucmVxdWlyZVRMUykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdTVEFSVFRMUycpO1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2godGhpcy5fYWN0aW9uU1RBUlRUTFMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZWN0IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgU01UUFVURjhcbiAgICAgICAgaWYgKC9bIC1dU01UUFVURjhcXGIvaW0udGVzdChzdHIpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdXBwb3J0ZWRFeHRlbnNpb25zLnB1c2goJ1NNVFBVVEY4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlY3QgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBEU05cbiAgICAgICAgaWYgKC9bIC1dRFNOXFxiL2ltLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgdGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucy5wdXNoKCdEU04nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVjdCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIDhCSVRNSU1FXG4gICAgICAgIGlmICgvWyAtXThCSVRNSU1FXFxiL2ltLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgdGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucy5wdXNoKCc4QklUTUlNRScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZWN0IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgUElQRUxJTklOR1xuICAgICAgICBpZiAoL1sgLV1QSVBFTElOSU5HXFxiL2ltLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgdGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucy5wdXNoKCdQSVBFTElOSU5HJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlY3QgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBBVVRIXG4gICAgICAgIGlmICgvWyAtXUFVVEhcXGIvaS50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dzQXV0aCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlY3QgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBQTEFJTiBhdXRoXG4gICAgICAgIGlmICgvWyAtXUFVVEgoPzooXFxzK3w9KVteXFxuXSpcXHMrfFxccyt8PSlQTEFJTi9pLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgdGhpcy5fc3VwcG9ydGVkQXV0aC5wdXNoKCdQTEFJTicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZWN0IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgTE9HSU4gYXV0aFxuICAgICAgICBpZiAoL1sgLV1BVVRIKD86KFxccyt8PSlbXlxcbl0qXFxzK3xcXHMrfD0pTE9HSU4vaS50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1cHBvcnRlZEF1dGgucHVzaCgnTE9HSU4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVjdCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIENSQU0tTUQ1IGF1dGhcbiAgICAgICAgaWYgKC9bIC1dQVVUSCg/OihcXHMrfD0pW15cXG5dKlxccyt8XFxzK3w9KUNSQU0tTUQ1L2kudGVzdChzdHIpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdXBwb3J0ZWRBdXRoLnB1c2goJ0NSQU0tTUQ1Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlY3QgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBYT0FVVEgyIGF1dGhcbiAgICAgICAgaWYgKC9bIC1dQVVUSCg/OihcXHMrfD0pW15cXG5dKlxccyt8XFxzK3w9KVhPQVVUSDIvaS50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1cHBvcnRlZEF1dGgucHVzaCgnWE9BVVRIMicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZWN0IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgU0laRSBleHRlbnNpb25zIChhbmQgdGhlIG1heCBhbGxvd2VkIHNpemUpXG4gICAgICAgIGlmICgobWF0Y2ggPSBzdHIubWF0Y2goL1sgLV1TSVpFKD86WyBcXHRdKyhcXGQrKSk/L2ltKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1cHBvcnRlZEV4dGVuc2lvbnMucHVzaCgnU0laRScpO1xuICAgICAgICAgICAgdGhpcy5fbWF4QWxsb3dlZFNpemUgPSBOdW1iZXIobWF0Y2hbMV0pIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHNlcnZlciByZXNwb25zZSBmb3IgSEVMTyBjb21tYW5kLiBJZiBpdCB5aWVsZGVkIGluXG4gICAgICogZXJyb3IsIGVtaXQgJ2Vycm9yJywgb3RoZXJ3aXNlIG1vdmUgaW50byB0aGUgYXV0aGVudGljYXRpb24gcGhhc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gICAgICovXG4gICAgX2FjdGlvbkhFTE8oc3RyKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KDApICE9PSAnMicpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdJbnZhbGlkIEhFTE8uIHJlc3BvbnNlPScgKyBzdHIpLCAnRVBST1RPQ09MJywgc3RyLCAnSEVMTycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXNzdW1lIHRoYXQgYXV0aGVudGljYXRpb24gaXMgZW5hYmxlZCAobW9zdCBwcm9iYWJseSBpcyBub3QgdGhvdWdoKVxuICAgICAgICB0aGlzLmFsbG93c0F1dGggPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc2VydmVyIHJlc3BvbnNlIGZvciBTVEFSVFRMUyBjb21tYW5kLiBJZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICogdHJ5IEhFTE8gaW5zdGVhZCwgb3RoZXJ3aXNlIGluaXRpYXRlIFRMUyB1cGdyYWRlLiBJZiB0aGUgdXBncmFkZVxuICAgICAqIHN1Y2NlZWRlcyByZXN0YXJ0IHRoZSBFSExPXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gICAgICovXG4gICAgX2FjdGlvblNUQVJUVExTKHN0cikge1xuICAgICAgICBpZiAoc3RyLmNoYXJBdCgwKSAhPT0gJzInKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9wcG9ydHVuaXN0aWNUTFMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bng6ICdzbXRwJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIFNUQVJUVExTIHVwZ3JhZGUsIGNvbnRpbnVpbmcgdW5lbmNyeXB0ZWQnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKG5ldyBFcnJvcignRXJyb3IgdXBncmFkaW5nIGNvbm5lY3Rpb24gd2l0aCBTVEFSVFRMUycpLCAnRVRMUycsIHN0ciwgJ1NUQVJUVExTJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGdyYWRlQ29ubmVjdGlvbigoZXJyLCBzZWN1cmVkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25FcnJvcihuZXcgRXJyb3IoJ0Vycm9yIGluaXRpYXRpbmcgVExTIC0gJyArIChlcnIubWVzc2FnZSB8fCBlcnIpKSwgJ0VUTFMnLCBmYWxzZSwgJ1NUQVJUVExTJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG54OiAnc210cCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdDb25uZWN0aW9uIHVwZ3JhZGVkIHdpdGggU1RBUlRUTFMnXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoc2VjdXJlZCkge1xuICAgICAgICAgICAgICAgIC8vIHJlc3RhcnQgc2Vzc2lvblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG10cCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25zZUFjdGlvbnMucHVzaCh0aGlzLl9hY3Rpb25MSExPKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoJ0xITE8gJyArIHRoaXMubmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2godGhpcy5fYWN0aW9uRUhMTyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdFSExPICcgKyB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgcmVzcG9uc2UgZm9yIEFVVEggTE9HSU4gY29tbWFuZC4gV2UgYXJlIGV4cGVjdGluZ1xuICAgICAqICczMzQgVlhObGNtNWhiV1U2JyAoYmFzZTY0IGZvciAnVXNlcm5hbWU6JykuIERhdGEgdG8gYmUgc2VudCBhc1xuICAgICAqIHJlc3BvbnNlIG5lZWRzIHRvIGJlIGJhc2U2NCBlbmNvZGVkIHVzZXJuYW1lLiBXZSBkbyBub3QgbmVlZFxuICAgICAqIGV4YWN0IG1hdGNoIGJ1dCBzZXR0bGUgd2l0aCAzMzQgcmVzcG9uc2UgaW4gZ2VuZXJhbCBhcyBzb21lXG4gICAgICogaG9zdHMgaW52YWxpZGx5IHVzZSBhIGxvbmdlciBtZXNzYWdlIHRoYW4gVlhObGNtNWhiV1U2XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gICAgICovXG4gICAgX2FjdGlvbkFVVEhfTE9HSU5fVVNFUihzdHIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghL14zMzRbIC1dLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIC8vIGV4cGVjdGluZyAnMzM0IFZYTmxjbTVoYldVNidcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdJbnZhbGlkIGxvZ2luIHNlcXVlbmNlIHdoaWxlIHdhaXRpbmcgZm9yIFwiMzM0IFZYTmxjbTVoYldVNlwiJywgJ0VBVVRIJywgc3RyLCAnQVVUSCBMT0dJTicpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKHN0ciA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25BVVRIX0xPR0lOX1BBU1Moc3RyLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKEJ1ZmZlci5mcm9tKHRoaXMuX2F1dGguY3JlZGVudGlhbHMudXNlciArICcnLCAndXRmLTgnKS50b1N0cmluZygnYmFzZTY0JykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgcmVzcG9uc2UgZm9yIEFVVEggQ1JBTS1NRDUgY29tbWFuZC4gV2UgYXJlIGV4cGVjdGluZ1xuICAgICAqICczMzQgPGNoYWxsZW5nZSBzdHJpbmc+Jy4gRGF0YSB0byBiZSBzZW50IGFzIHJlc3BvbnNlIG5lZWRzIHRvIGJlXG4gICAgICogYmFzZTY0IGRlY29kZWQgY2hhbGxlbmdlIHN0cmluZywgTUQ1IGhhc2hlZCB1c2luZyB0aGUgcGFzc3dvcmQgYXNcbiAgICAgKiBhIEhNQUMga2V5LCBwcmVmaXhlZCBieSB0aGUgdXNlcm5hbWUgYW5kIGEgc3BhY2UsIGFuZCBmaW5hbGx5IGFsbFxuICAgICAqIGJhc2U2NCBlbmNvZGVkIGFnYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICAgICAqL1xuICAgIF9hY3Rpb25BVVRIX0NSQU1fTUQ1KHN0ciwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGNoYWxsZW5nZU1hdGNoID0gc3RyLm1hdGNoKC9eMzM0XFxzKyguKykkLyk7XG4gICAgICAgIGxldCBjaGFsbGVuZ2VTdHJpbmcgPSAnJztcblxuICAgICAgICBpZiAoIWNoYWxsZW5nZU1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ0ludmFsaWQgbG9naW4gc2VxdWVuY2Ugd2hpbGUgd2FpdGluZyBmb3Igc2VydmVyIGNoYWxsZW5nZSBzdHJpbmcnLCAnRUFVVEgnLCBzdHIsICdBVVRIIENSQU0tTUQ1JykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hhbGxlbmdlU3RyaW5nID0gY2hhbGxlbmdlTWF0Y2hbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNvZGUgZnJvbSBiYXNlNjRcbiAgICAgICAgbGV0IGJhc2U2NGRlY29kZWQgPSBCdWZmZXIuZnJvbShjaGFsbGVuZ2VTdHJpbmcsICdiYXNlNjQnKS50b1N0cmluZygnYXNjaWknKSxcbiAgICAgICAgICAgIGhtYWNNRDUgPSBjcnlwdG8uY3JlYXRlSG1hYygnbWQ1JywgdGhpcy5fYXV0aC5jcmVkZW50aWFscy5wYXNzKTtcblxuICAgICAgICBobWFjTUQ1LnVwZGF0ZShiYXNlNjRkZWNvZGVkKTtcblxuICAgICAgICBsZXQgcHJlcGVuZGVkID0gdGhpcy5fYXV0aC5jcmVkZW50aWFscy51c2VyICsgJyAnICsgaG1hY01ENS5kaWdlc3QoJ2hleCcpO1xuXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKHN0ciA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25BVVRIX0NSQU1fTUQ1X1BBU1Moc3RyLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKFxuICAgICAgICAgICAgQnVmZmVyLmZyb20ocHJlcGVuZGVkKS50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgICAgICAvLyBoaWRkZW4gaGFzaCBmb3IgbG9nc1xuICAgICAgICAgICAgQnVmZmVyLmZyb20odGhpcy5fYXV0aC5jcmVkZW50aWFscy51c2VyICsgJyAvKiBzZWNyZXQgKi8nKS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSByZXNwb25zZSB0byBDUkFNLU1ENSBhdXRoZW50aWNhdGlvbiwgaWYgdGhlcmUncyBubyBlcnJvcixcbiAgICAgKiB0aGUgdXNlciBjYW4gYmUgY29uc2lkZXJlZCBsb2dnZWQgaW4uIFN0YXJ0IHdhaXRpbmcgZm9yIGEgbWVzc2FnZSB0byBzZW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gICAgICovXG4gICAgX2FjdGlvbkFVVEhfQ1JBTV9NRDVfUEFTUyhzdHIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghc3RyLm1hdGNoKC9eMjM1XFxzKy8pKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ0ludmFsaWQgbG9naW4gc2VxdWVuY2Ugd2hpbGUgd2FpdGluZyBmb3IgXCIyMzVcIicsICdFQVVUSCcsIHN0ciwgJ0FVVEggQ1JBTS1NRDUnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRueDogJ3NtdHAnLFxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB0aGlzLl9hdXRoLnVzZXIsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnYXV0aGVudGljYXRlZCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiB0aGlzLl9hdXRoTWV0aG9kXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ1VzZXIgJXMgYXV0aGVudGljYXRlZCcsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLl9hdXRoLnVzZXIpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgcmVzcG9uc2UgZm9yIEFVVEggTE9HSU4gY29tbWFuZC4gV2UgYXJlIGV4cGVjdGluZ1xuICAgICAqICczMzQgVUdGemMzZHZjbVE2JyAoYmFzZTY0IGZvciAnUGFzc3dvcmQ6JykuIERhdGEgdG8gYmUgc2VudCBhc1xuICAgICAqIHJlc3BvbnNlIG5lZWRzIHRvIGJlIGJhc2U2NCBlbmNvZGVkIHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICAgICAqL1xuICAgIF9hY3Rpb25BVVRIX0xPR0lOX1BBU1Moc3RyLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIS9eMzM0WyAtXS8udGVzdChzdHIpKSB7XG4gICAgICAgICAgICAvLyBleHBlY3RpbmcgJzMzNCBVR0Z6YzNkdmNtUTYnXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ0ludmFsaWQgbG9naW4gc2VxdWVuY2Ugd2hpbGUgd2FpdGluZyBmb3IgXCIzMzQgVUdGemMzZHZjbVE2XCInLCAnRUFVVEgnLCBzdHIsICdBVVRIIExPR0lOJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2goc3RyID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbkFVVEhDb21wbGV0ZShzdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoXG4gICAgICAgICAgICBCdWZmZXIuZnJvbSgodGhpcy5fYXV0aC5jcmVkZW50aWFscy5wYXNzIHx8ICcnKS50b1N0cmluZygpLCAndXRmLTgnKS50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgICAgICAvLyBIaWRkZW4gcGFzcyBmb3IgbG9nc1xuICAgICAgICAgICAgQnVmZmVyLmZyb20oJy8qIHNlY3JldCAqLycsICd1dGYtOCcpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIHJlc3BvbnNlIGZvciBhdXRoZW50aWNhdGlvbiwgaWYgdGhlcmUncyBubyBlcnJvcixcbiAgICAgKiB0aGUgdXNlciBjYW4gYmUgY29uc2lkZXJlZCBsb2dnZWQgaW4uIFN0YXJ0IHdhaXRpbmcgZm9yIGEgbWVzc2FnZSB0byBzZW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gICAgICovXG4gICAgX2FjdGlvbkFVVEhDb21wbGV0ZShzdHIsIGlzUmV0cnksIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIGlzUmV0cnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gaXNSZXRyeTtcbiAgICAgICAgICAgIGlzUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHIuc3Vic3RyKDAsIDMpID09PSAnMzM0Jykge1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2goc3RyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXRyeSB8fCB0aGlzLl9hdXRoTWV0aG9kICE9PSAnWE9BVVRIMicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uQVVUSENvbXBsZXRlKHN0ciwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZldGNoIGEgbmV3IE9BdXRoMiBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2hhbmRsZVhPYXV0aDJUb2tlbih0cnVlLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoJycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMCkgIT09ICcyJykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRueDogJ3NtdHAnLFxuICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogdGhpcy5fYXV0aC51c2VyLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdhdXRoZmFpbCcsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdGhpcy5fYXV0aE1ldGhvZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1VzZXIgJXMgZmFpbGVkIHRvIGF1dGhlbnRpY2F0ZScsXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5fYXV0aC51c2VyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcignSW52YWxpZCBsb2dpbicsICdFQVVUSCcsIHN0ciwgJ0FVVEggJyArIHRoaXMuX2F1dGhNZXRob2QpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG54OiAnc210cCcsXG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IHRoaXMuX2F1dGgudXNlcixcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdhdXRoZW50aWNhdGVkJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMuX2F1dGhNZXRob2RcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnVXNlciAlcyBhdXRoZW50aWNhdGVkJyxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMuX2F1dGgudXNlcilcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHJlc3BvbnNlIGZvciBhIE1BSUwgRlJPTTogY29tbWFuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICAgICAqL1xuICAgIF9hY3Rpb25NQUlMKHN0ciwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UsIGN1clJlY2lwaWVudDtcbiAgICAgICAgaWYgKE51bWJlcihzdHIuY2hhckF0KDApKSAhPT0gMikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VzaW5nU210cFV0ZjggJiYgL141NTAgLy50ZXN0KHN0cikgJiYgL1tcXHg4MC1cXHVGRkZGXS8udGVzdCh0aGlzLl9lbnZlbG9wZS5mcm9tKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAnSW50ZXJuYXRpb25hbGl6ZWQgbWFpbGJveCBuYW1lIG5vdCBhbGxvd2VkJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9ICdNYWlsIGNvbW1hbmQgZmFpbGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcihtZXNzYWdlLCAnRUVOVkVMT1BFJywgc3RyLCAnTUFJTCBGUk9NJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbnZlbG9wZS5yY3B0UXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ0NhblxceDI3dCBzZW5kIG1haWwgLSBubyByZWNpcGllbnRzIGRlZmluZWQnLCAnRUVOVkVMT1BFJywgZmFsc2UsICdBUEknKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZWNpcGllbnRRdWV1ZSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucy5pbmNsdWRlcygnUElQRUxJTklORycpKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2VudmVsb3BlLnJjcHRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyUmVjaXBpZW50ID0gdGhpcy5fZW52ZWxvcGUucmNwdFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY2lwaWVudFF1ZXVlLnB1c2goY3VyUmVjaXBpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2goc3RyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvblJDUFQoc3RyLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnUkNQVCBUTzo8JyArIGN1clJlY2lwaWVudCArICc+JyArIHRoaXMuX2dldERzblJjcHRUb0FyZ3MoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJSZWNpcGllbnQgPSB0aGlzLl9lbnZlbG9wZS5yY3B0UXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNpcGllbnRRdWV1ZS5wdXNoKGN1clJlY2lwaWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2goc3RyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uUkNQVChzdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnUkNQVCBUTzo8JyArIGN1clJlY2lwaWVudCArICc+JyArIHRoaXMuX2dldERzblJjcHRUb0FyZ3MoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcmVzcG9uc2UgZm9yIGEgUkNQVCBUTzogY29tbWFuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICAgICAqL1xuICAgIF9hY3Rpb25SQ1BUKHN0ciwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UsXG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBjdXJSZWNpcGllbnQgPSB0aGlzLl9yZWNpcGllbnRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAoTnVtYmVyKHN0ci5jaGFyQXQoMCkpICE9PSAyKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgc29mdCBlcnJvclxuICAgICAgICAgICAgaWYgKHRoaXMuX3VzaW5nU210cFV0ZjggJiYgL141NTMgLy50ZXN0KHN0cikgJiYgL1tcXHg4MC1cXHVGRkZGXS8udGVzdChjdXJSZWNpcGllbnQpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9ICdJbnRlcm5hdGlvbmFsaXplZCBtYWlsYm94IG5hbWUgbm90IGFsbG93ZWQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gJ1JlY2lwaWVudCBjb21tYW5kIGZhaWxlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9lbnZlbG9wZS5yZWplY3RlZC5wdXNoKGN1clJlY2lwaWVudCk7XG4gICAgICAgICAgICAvLyBzdG9yZSBlcnJvciBmb3IgdGhlIGZhaWxlZCByZWNpcGllbnRcbiAgICAgICAgICAgIGVyciA9IHRoaXMuX2Zvcm1hdEVycm9yKG1lc3NhZ2UsICdFRU5WRUxPUEUnLCBzdHIsICdSQ1BUIFRPJyk7XG4gICAgICAgICAgICBlcnIucmVjaXBpZW50ID0gY3VyUmVjaXBpZW50O1xuICAgICAgICAgICAgdGhpcy5fZW52ZWxvcGUucmVqZWN0ZWRFcnJvcnMucHVzaChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW52ZWxvcGUuYWNjZXB0ZWQucHVzaChjdXJSZWNpcGllbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbnZlbG9wZS5yY3B0UXVldWUubGVuZ3RoICYmICF0aGlzLl9yZWNpcGllbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbnZlbG9wZS5yZWplY3RlZC5sZW5ndGggPCB0aGlzLl9lbnZlbG9wZS50by5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25zZUFjdGlvbnMucHVzaChzdHIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25EQVRBKHN0ciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdEQVRBJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVyciA9IHRoaXMuX2Zvcm1hdEVycm9yKCdDYW5cXHgyN3Qgc2VuZCBtYWlsIC0gYWxsIHJlY2lwaWVudHMgd2VyZSByZWplY3RlZCcsICdFRU5WRUxPUEUnLCBzdHIsICdSQ1BUIFRPJyk7XG4gICAgICAgICAgICAgICAgZXJyLnJlamVjdGVkID0gdGhpcy5fZW52ZWxvcGUucmVqZWN0ZWQ7XG4gICAgICAgICAgICAgICAgZXJyLnJlamVjdGVkRXJyb3JzID0gdGhpcy5fZW52ZWxvcGUucmVqZWN0ZWRFcnJvcnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZW52ZWxvcGUucmNwdFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgY3VyUmVjaXBpZW50ID0gdGhpcy5fZW52ZWxvcGUucmNwdFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLl9yZWNpcGllbnRRdWV1ZS5wdXNoKGN1clJlY2lwaWVudCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25zZUFjdGlvbnMucHVzaChzdHIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvblJDUFQoc3RyLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdSQ1BUIFRPOjwnICsgY3VyUmVjaXBpZW50ICsgJz4nICsgdGhpcy5fZ2V0RHNuUmNwdFRvQXJncygpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSByZXNwb25zZSBmb3IgYSBEQVRBIGNvbW1hbmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgTWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBfYWN0aW9uREFUQShzdHIsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHJlc3BvbnNlIHNob3VsZCBiZSAzNTQgYnV0IGFjY29yZGluZyB0byB0aGlzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVpdGgvZW1haWxqcy9pc3N1ZXMvMjRcbiAgICAgICAgLy8gc29tZSBzZXJ2ZXJzIG1pZ2h0IHVzZSAyNTAgaW5zdGVhZCwgc28gbGV0cyBjaGVjayBmb3IgMiBvciAzIGFzIHRoZSBmaXJzdCBkaWdpdFxuICAgICAgICBpZiAoIS9eWzIzXS8udGVzdChzdHIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ0RhdGEgY29tbWFuZCBmYWlsZWQnLCAnRUVOVkVMT1BFJywgc3RyLCAnREFUQScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGFjY2VwdGVkOiB0aGlzLl9lbnZlbG9wZS5hY2NlcHRlZCxcbiAgICAgICAgICAgIHJlamVjdGVkOiB0aGlzLl9lbnZlbG9wZS5yZWplY3RlZFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLl9laGxvTGluZXMgJiYgdGhpcy5fZWhsb0xpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzcG9uc2UuZWhsbyA9IHRoaXMuX2VobG9MaW5lcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9lbnZlbG9wZS5yZWplY3RlZEVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLnJlamVjdGVkRXJyb3JzID0gdGhpcy5fZW52ZWxvcGUucmVqZWN0ZWRFcnJvcnM7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHJlc3BvbnNlIGZvciBhIERBVEEgc3RyZWFtIHdoZW4gdXNpbmcgU01UUFxuICAgICAqIFdlIGV4cGVjdCBhIHNpbmdsZSByZXNwb25zZSB0aGF0IGRlZmluZXMgaWYgdGhlIHNlbmRpbmcgc3VjY2VlZGVkIG9yIGZhaWxlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICAgICAqL1xuICAgIF9hY3Rpb25TTVRQU3RyZWFtKHN0ciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKE51bWJlcihzdHIuY2hhckF0KDApKSAhPT0gMikge1xuICAgICAgICAgICAgLy8gTWVzc2FnZSBmYWlsZWRcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcignTWVzc2FnZSBmYWlsZWQnLCAnRU1FU1NBR0UnLCBzdHIsICdEQVRBJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTWVzc2FnZSBzZW50IHN1Y2Nlc2Z1bGx5XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgc3RyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSByZXNwb25zZSBmb3IgYSBEQVRBIHN0cmVhbVxuICAgICAqIFdlIGV4cGVjdCBhIHNlcGFyYXRlIHJlc3BvbnNlIGZvciBldmVyeSByZWNpcGllbnQuIEFsbCByZWNpcGllbnRzIGNhbiBlaXRoZXJcbiAgICAgKiBzdWNjZWVkIG9yIGZhaWwgc2VwYXJhdGVseVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlY2lwaWVudCBUaGUgcmVjaXBpZW50IHRoaXMgcmVzcG9uc2UgYXBwbGllcyB0b1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluYWwgSXMgdGhpcyB0aGUgZmluYWwgcmVjaXBpZW50P1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgTWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBfYWN0aW9uTE1UUFN0cmVhbShyZWNpcGllbnQsIGZpbmFsLCBzdHIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmIChOdW1iZXIoc3RyLmNoYXJBdCgwKSkgIT09IDIpIHtcbiAgICAgICAgICAgIC8vIE1lc3NhZ2UgZmFpbGVkXG4gICAgICAgICAgICBlcnIgPSB0aGlzLl9mb3JtYXRFcnJvcignTWVzc2FnZSBmYWlsZWQgZm9yIHJlY2lwaWVudCAnICsgcmVjaXBpZW50LCAnRU1FU1NBR0UnLCBzdHIsICdEQVRBJyk7XG4gICAgICAgICAgICBlcnIucmVjaXBpZW50ID0gcmVjaXBpZW50O1xuICAgICAgICAgICAgdGhpcy5fZW52ZWxvcGUucmVqZWN0ZWQucHVzaChyZWNpcGllbnQpO1xuICAgICAgICAgICAgdGhpcy5fZW52ZWxvcGUucmVqZWN0ZWRFcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX2VudmVsb3BlLmFjY2VwdGVkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VudmVsb3BlLmFjY2VwdGVkW2ldID09PSByZWNpcGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW52ZWxvcGUuYWNjZXB0ZWQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBzdHIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2hhbmRsZVhPYXV0aDJUb2tlbihpc1JldHJ5LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9hdXRoLm9hdXRoMi5nZXRUb2tlbihpc1JldHJ5LCAoZXJyLCBhY2Nlc3NUb2tlbikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3NtdHAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IHRoaXMuX2F1dGgudXNlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2F1dGhmYWlsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdGhpcy5fYXV0aE1ldGhvZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnVXNlciAlcyBmYWlsZWQgdG8gYXV0aGVudGljYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5fYXV0aC51c2VyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKGVyciwgJ0VBVVRIJywgZmFsc2UsICdBVVRIIFhPQVVUSDInKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25zZUFjdGlvbnMucHVzaChzdHIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbkFVVEhDb21wbGV0ZShzdHIsIGlzUmV0cnksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoXG4gICAgICAgICAgICAgICAgJ0FVVEggWE9BVVRIMiAnICsgdGhpcy5fYXV0aC5vYXV0aDIuYnVpbGRYT0F1dGgyVG9rZW4oYWNjZXNzVG9rZW4pLFxuICAgICAgICAgICAgICAgIC8vICBIaWRkZW4gZm9yIGxvZ3NcbiAgICAgICAgICAgICAgICAnQVVUSCBYT0FVVEgyICcgKyB0aGlzLl9hdXRoLm9hdXRoMi5idWlsZFhPQXV0aDJUb2tlbignLyogc2VjcmV0ICovJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0Rlc3Ryb3llZE1lc3NhZ2UoY29tbWFuZCkge1xuICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Nhbm5vdCAnICsgY29tbWFuZCArICcgLSBzbXRwIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBkZXN0cm95ZWQuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdDYW5ub3QgJyArIGNvbW1hbmQgKyAnIC0gc210cCBjb25uZWN0aW9uIHNvY2tldCBpcyBhbHJlYWR5IGRlc3Ryb3llZC4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NvY2tldC53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQ2Fubm90ICcgKyBjb21tYW5kICsgJyAtIHNtdHAgY29ubmVjdGlvbiBzb2NrZXQgaXMgYWxyZWFkeSBoYWxmLWNsb3NlZC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldEhvc3RuYW1lKCkge1xuICAgICAgICAvLyBkZWZhdWwgaG9zdG5hbWUgaXMgbWFjaGluZSBob3N0bmFtZSBvciBbSVBdXG4gICAgICAgIGxldCBkZWZhdWx0SG9zdG5hbWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWZhdWx0SG9zdG5hbWUgPSBvcy5ob3N0bmFtZSgpIHx8ICcnO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGZhaWxzIG9uIHdpbmRvd3MgN1xuICAgICAgICAgICAgZGVmYXVsdEhvc3RuYW1lID0gJ2xvY2FsaG9zdCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZ25vcmUgaWYgbm90IEZRRE5cbiAgICAgICAgaWYgKCFkZWZhdWx0SG9zdG5hbWUgfHwgZGVmYXVsdEhvc3RuYW1lLmluZGV4T2YoJy4nKSA8IDApIHtcbiAgICAgICAgICAgIGRlZmF1bHRIb3N0bmFtZSA9ICdbMTI3LjAuMC4xXSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJUCBzaG91bGQgYmUgZW5jbG9zZWQgaW4gW11cbiAgICAgICAgaWYgKGRlZmF1bHRIb3N0bmFtZS5tYXRjaCgvXlxcZHsxLDN9XFwuXFxkezEsM31cXC5cXGR7MSwzfVxcLlxcZHsxLDN9JC8pKSB7XG4gICAgICAgICAgICBkZWZhdWx0SG9zdG5hbWUgPSAnWycgKyBkZWZhdWx0SG9zdG5hbWUgKyAnXSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdEhvc3RuYW1lO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTTVRQQ29ubmVjdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/smtp-connection/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/smtp-pool/index.js":
/*!********************************************************!*\
  !*** ./node_modules/nodemailer/lib/smtp-pool/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst PoolResource = __webpack_require__(/*! ./pool-resource */ \"(rsc)/./node_modules/nodemailer/lib/smtp-pool/pool-resource.js\");\nconst SMTPConnection = __webpack_require__(/*! ../smtp-connection */ \"(rsc)/./node_modules/nodemailer/lib/smtp-connection/index.js\");\nconst wellKnown = __webpack_require__(/*! ../well-known */ \"(rsc)/./node_modules/nodemailer/lib/well-known/index.js\");\nconst shared = __webpack_require__(/*! ../shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\");\nconst packageData = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/nodemailer/package.json\");\n\n/**\n * Creates a SMTP pool transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options SMTP Connection options\n */\nclass SMTPPool extends EventEmitter {\n    constructor(options) {\n        super();\n\n        options = options || {};\n        if (typeof options === 'string') {\n            options = {\n                url: options\n            };\n        }\n\n        let urlData;\n        let service = options.service;\n\n        if (typeof options.getSocket === 'function') {\n            this.getSocket = options.getSocket;\n        }\n\n        if (options.url) {\n            urlData = shared.parseConnectionUrl(options.url);\n            service = service || urlData.service;\n        }\n\n        this.options = shared.assign(\n            false, // create new object\n            options, // regular options\n            urlData, // url options\n            service && wellKnown(service) // wellknown options\n        );\n\n        this.options.maxConnections = this.options.maxConnections || 5;\n        this.options.maxMessages = this.options.maxMessages || 100;\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-pool'\n        });\n\n        // temporary object\n        let connection = new SMTPConnection(this.options);\n\n        this.name = 'SMTP (pool)';\n        this.version = packageData.version + '[client:' + connection.version + ']';\n\n        this._rateLimit = {\n            counter: 0,\n            timeout: null,\n            waiting: [],\n            checkpoint: false,\n            delta: Number(this.options.rateDelta) || 1000,\n            limit: Number(this.options.rateLimit) || 0\n        };\n        this._closed = false;\n        this._queue = [];\n        this._connections = [];\n        this._connectionCounter = 0;\n\n        this.idling = true;\n\n        setImmediate(() => {\n            if (this.idling) {\n                this.emit('idle');\n            }\n        });\n    }\n\n    /**\n     * Placeholder function for creating proxy sockets. This method immediatelly returns\n     * without a socket\n     *\n     * @param {Object} options Connection options\n     * @param {Function} callback Callback function to run with the socket keys\n     */\n    getSocket(options, callback) {\n        // return immediatelly\n        return setImmediate(() => callback(null, false));\n    }\n\n    /**\n     * Queues an e-mail to be sent using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n    send(mail, callback) {\n        if (this._closed) {\n            return false;\n        }\n\n        this._queue.push({\n            mail,\n            requeueAttempts: 0,\n            callback\n        });\n\n        if (this.idling && this._queue.length >= this.options.maxConnections) {\n            this.idling = false;\n        }\n\n        setImmediate(() => this._processMessages());\n\n        return true;\n    }\n\n    /**\n     * Closes all connections in the pool. If there is a message being sent, the connection\n     * is closed later\n     */\n    close() {\n        let connection;\n        let len = this._connections.length;\n        this._closed = true;\n\n        // clear rate limit timer if it exists\n        clearTimeout(this._rateLimit.timeout);\n\n        if (!len && !this._queue.length) {\n            return;\n        }\n\n        // remove all available connections\n        for (let i = len - 1; i >= 0; i--) {\n            if (this._connections[i] && this._connections[i].available) {\n                connection = this._connections[i];\n                connection.close();\n                this.logger.info(\n                    {\n                        tnx: 'connection',\n                        cid: connection.id,\n                        action: 'removed'\n                    },\n                    'Connection #%s removed',\n                    connection.id\n                );\n            }\n        }\n\n        if (len && !this._connections.length) {\n            this.logger.debug(\n                {\n                    tnx: 'connection'\n                },\n                'All connections removed'\n            );\n        }\n\n        if (!this._queue.length) {\n            return;\n        }\n\n        // make sure that entire queue would be cleaned\n        let invokeCallbacks = () => {\n            if (!this._queue.length) {\n                this.logger.debug(\n                    {\n                        tnx: 'connection'\n                    },\n                    'Pending queue entries cleared'\n                );\n                return;\n            }\n            let entry = this._queue.shift();\n            if (entry && typeof entry.callback === 'function') {\n                try {\n                    entry.callback(new Error('Connection pool was closed'));\n                } catch (E) {\n                    this.logger.error(\n                        {\n                            err: E,\n                            tnx: 'callback',\n                            cid: connection.id\n                        },\n                        'Callback error for #%s: %s',\n                        connection.id,\n                        E.message\n                    );\n                }\n            }\n            setImmediate(invokeCallbacks);\n        };\n        setImmediate(invokeCallbacks);\n    }\n\n    /**\n     * Check the queue and available connections. If there is a message to be sent and there is\n     * an available connection, then use this connection to send the mail\n     */\n    _processMessages() {\n        let connection;\n        let i, len;\n\n        // do nothing if already closed\n        if (this._closed) {\n            return;\n        }\n\n        // do nothing if queue is empty\n        if (!this._queue.length) {\n            if (!this.idling) {\n                // no pending jobs\n                this.idling = true;\n                this.emit('idle');\n            }\n            return;\n        }\n\n        // find first available connection\n        for (i = 0, len = this._connections.length; i < len; i++) {\n            if (this._connections[i].available) {\n                connection = this._connections[i];\n                break;\n            }\n        }\n\n        if (!connection && this._connections.length < this.options.maxConnections) {\n            connection = this._createConnection();\n        }\n\n        if (!connection) {\n            // no more free connection slots available\n            this.idling = false;\n            return;\n        }\n\n        // check if there is free space in the processing queue\n        if (!this.idling && this._queue.length < this.options.maxConnections) {\n            this.idling = true;\n            this.emit('idle');\n        }\n\n        let entry = (connection.queueEntry = this._queue.shift());\n        entry.messageId = (connection.queueEntry.mail.message.getHeader('message-id') || '').replace(/[<>\\s]/g, '');\n\n        connection.available = false;\n\n        this.logger.debug(\n            {\n                tnx: 'pool',\n                cid: connection.id,\n                messageId: entry.messageId,\n                action: 'assign'\n            },\n            'Assigned message <%s> to #%s (%s)',\n            entry.messageId,\n            connection.id,\n            connection.messages + 1\n        );\n\n        if (this._rateLimit.limit) {\n            this._rateLimit.counter++;\n            if (!this._rateLimit.checkpoint) {\n                this._rateLimit.checkpoint = Date.now();\n            }\n        }\n\n        connection.send(entry.mail, (err, info) => {\n            // only process callback if current handler is not changed\n            if (entry === connection.queueEntry) {\n                try {\n                    entry.callback(err, info);\n                } catch (E) {\n                    this.logger.error(\n                        {\n                            err: E,\n                            tnx: 'callback',\n                            cid: connection.id\n                        },\n                        'Callback error for #%s: %s',\n                        connection.id,\n                        E.message\n                    );\n                }\n                connection.queueEntry = false;\n            }\n        });\n    }\n\n    /**\n     * Creates a new pool resource\n     */\n    _createConnection() {\n        let connection = new PoolResource(this);\n\n        connection.id = ++this._connectionCounter;\n\n        this.logger.info(\n            {\n                tnx: 'pool',\n                cid: connection.id,\n                action: 'conection'\n            },\n            'Created new pool resource #%s',\n            connection.id\n        );\n\n        // resource comes available\n        connection.on('available', () => {\n            this.logger.debug(\n                {\n                    tnx: 'connection',\n                    cid: connection.id,\n                    action: 'available'\n                },\n                'Connection #%s became available',\n                connection.id\n            );\n\n            if (this._closed) {\n                // if already closed run close() that will remove this connections from connections list\n                this.close();\n            } else {\n                // check if there's anything else to send\n                this._processMessages();\n            }\n        });\n\n        // resource is terminated with an error\n        connection.once('error', err => {\n            if (err.code !== 'EMAXLIMIT') {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'pool',\n                        cid: connection.id\n                    },\n                    'Pool Error for #%s: %s',\n                    connection.id,\n                    err.message\n                );\n            } else {\n                this.logger.debug(\n                    {\n                        tnx: 'pool',\n                        cid: connection.id,\n                        action: 'maxlimit'\n                    },\n                    'Max messages limit exchausted for #%s',\n                    connection.id\n                );\n            }\n\n            if (connection.queueEntry) {\n                try {\n                    connection.queueEntry.callback(err);\n                } catch (E) {\n                    this.logger.error(\n                        {\n                            err: E,\n                            tnx: 'callback',\n                            cid: connection.id\n                        },\n                        'Callback error for #%s: %s',\n                        connection.id,\n                        E.message\n                    );\n                }\n                connection.queueEntry = false;\n            }\n\n            // remove the erroneus connection from connections list\n            this._removeConnection(connection);\n\n            this._continueProcessing();\n        });\n\n        connection.once('close', () => {\n            this.logger.info(\n                {\n                    tnx: 'connection',\n                    cid: connection.id,\n                    action: 'closed'\n                },\n                'Connection #%s was closed',\n                connection.id\n            );\n\n            this._removeConnection(connection);\n\n            if (connection.queueEntry) {\n                // If the connection closed when sending, add the message to the queue again\n                // if max number of requeues is not reached yet\n                // Note that we must wait a bit.. because the callback of the 'error' handler might be called\n                // in the next event loop\n                setTimeout(() => {\n                    if (connection.queueEntry) {\n                        if (this._shouldRequeuOnConnectionClose(connection.queueEntry)) {\n                            this._requeueEntryOnConnectionClose(connection);\n                        } else {\n                            this._failDeliveryOnConnectionClose(connection);\n                        }\n                    }\n                    this._continueProcessing();\n                }, 50);\n            } else {\n                this._continueProcessing();\n            }\n        });\n\n        this._connections.push(connection);\n\n        return connection;\n    }\n\n    _shouldRequeuOnConnectionClose(queueEntry) {\n        if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {\n            return true;\n        }\n\n        return queueEntry.requeueAttempts < this.options.maxRequeues;\n    }\n\n    _failDeliveryOnConnectionClose(connection) {\n        if (connection.queueEntry && connection.queueEntry.callback) {\n            try {\n                connection.queueEntry.callback(new Error('Reached maximum number of retries after connection was closed'));\n            } catch (E) {\n                this.logger.error(\n                    {\n                        err: E,\n                        tnx: 'callback',\n                        messageId: connection.queueEntry.messageId,\n                        cid: connection.id\n                    },\n                    'Callback error for #%s: %s',\n                    connection.id,\n                    E.message\n                );\n            }\n            connection.queueEntry = false;\n        }\n    }\n\n    _requeueEntryOnConnectionClose(connection) {\n        connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;\n        this.logger.debug(\n            {\n                tnx: 'pool',\n                cid: connection.id,\n                messageId: connection.queueEntry.messageId,\n                action: 'requeue'\n            },\n            'Re-queued message <%s> for #%s. Attempt: #%s',\n            connection.queueEntry.messageId,\n            connection.id,\n            connection.queueEntry.requeueAttempts\n        );\n        this._queue.unshift(connection.queueEntry);\n        connection.queueEntry = false;\n    }\n\n    /**\n     * Continue to process message if the pool hasn't closed\n     */\n    _continueProcessing() {\n        if (this._closed) {\n            this.close();\n        } else {\n            setTimeout(() => this._processMessages(), 100);\n        }\n    }\n\n    /**\n     * Remove resource from pool\n     *\n     * @param {Object} connection The PoolResource to remove\n     */\n    _removeConnection(connection) {\n        let index = this._connections.indexOf(connection);\n\n        if (index !== -1) {\n            this._connections.splice(index, 1);\n        }\n    }\n\n    /**\n     * Checks if connections have hit current rate limit and if so, queues the availability callback\n     *\n     * @param {Function} callback Callback function to run once rate limiter has been cleared\n     */\n    _checkRateLimit(callback) {\n        if (!this._rateLimit.limit) {\n            return callback();\n        }\n\n        let now = Date.now();\n\n        if (this._rateLimit.counter < this._rateLimit.limit) {\n            return callback();\n        }\n\n        this._rateLimit.waiting.push(callback);\n\n        if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {\n            return this._clearRateLimit();\n        } else if (!this._rateLimit.timeout) {\n            this._rateLimit.timeout = setTimeout(() => this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));\n            this._rateLimit.checkpoint = now;\n        }\n    }\n\n    /**\n     * Clears current rate limit limitation and runs paused callback\n     */\n    _clearRateLimit() {\n        clearTimeout(this._rateLimit.timeout);\n        this._rateLimit.timeout = null;\n        this._rateLimit.counter = 0;\n        this._rateLimit.checkpoint = false;\n\n        // resume all paused connections\n        while (this._rateLimit.waiting.length) {\n            let cb = this._rateLimit.waiting.shift();\n            setImmediate(cb);\n        }\n    }\n\n    /**\n     * Returns true if there are free slots in the queue\n     */\n    isIdle() {\n        return this.idling;\n    }\n\n    /**\n     * Verifies SMTP configuration\n     *\n     * @param {Function} callback Callback function\n     */\n    verify(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        let auth = new PoolResource(this).auth;\n\n        this.getSocket(this.options, (err, socketOptions) => {\n            if (err) {\n                return callback(err);\n            }\n\n            let options = this.options;\n            if (socketOptions && socketOptions.connection) {\n                this.logger.info(\n                    {\n                        tnx: 'proxy',\n                        remoteAddress: socketOptions.connection.remoteAddress,\n                        remotePort: socketOptions.connection.remotePort,\n                        destHost: options.host || '',\n                        destPort: options.port || '',\n                        action: 'connected'\n                    },\n                    'Using proxied socket from %s:%s to %s:%s',\n                    socketOptions.connection.remoteAddress,\n                    socketOptions.connection.remotePort,\n                    options.host || '',\n                    options.port || ''\n                );\n                options = shared.assign(false, options);\n                Object.keys(socketOptions).forEach(key => {\n                    options[key] = socketOptions[key];\n                });\n            }\n\n            let connection = new SMTPConnection(options);\n            let returned = false;\n\n            connection.once('error', err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.close();\n                return callback(err);\n            });\n\n            connection.once('end', () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                return callback(new Error('Connection closed'));\n            });\n\n            let finalize = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.quit();\n                return callback(null, true);\n            };\n\n            connection.connect(() => {\n                if (returned) {\n                    return;\n                }\n\n                if (auth && (connection.allowsAuth || options.forceAuth)) {\n                    connection.login(auth, err => {\n                        if (returned) {\n                            return;\n                        }\n\n                        if (err) {\n                            returned = true;\n                            connection.close();\n                            return callback(err);\n                        }\n\n                        finalize();\n                    });\n                } else if (!auth && connection.allowsAuth && options.forceAuth) {\n                    let err = new Error('Authentication info was not provided');\n                    err.code = 'NoAuth';\n\n                    returned = true;\n                    connection.close();\n                    return callback(err);\n                } else {\n                    finalize();\n                }\n            });\n        });\n\n        return promise;\n    }\n}\n\n// expose to the world\nmodule.exports = SMTPPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc210cC1wb29sL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLHNCQUFRO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLHVGQUFpQjtBQUM5Qyx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBb0I7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsOEVBQWU7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHNFQUFXO0FBQ2xDLG9CQUFvQixtQkFBTyxDQUFDLHdFQUFvQjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9zbXRwLXBvb2wvaW5kZXguanM/ZDIzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgUG9vbFJlc291cmNlID0gcmVxdWlyZSgnLi9wb29sLXJlc291cmNlJyk7XG5jb25zdCBTTVRQQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4uL3NtdHAtY29ubmVjdGlvbicpO1xuY29uc3Qgd2VsbEtub3duID0gcmVxdWlyZSgnLi4vd2VsbC1rbm93bicpO1xuY29uc3Qgc2hhcmVkID0gcmVxdWlyZSgnLi4vc2hhcmVkJyk7XG5jb25zdCBwYWNrYWdlRGF0YSA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBTTVRQIHBvb2wgdHJhbnNwb3J0IG9iamVjdCBmb3IgTm9kZW1haWxlclxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgU01UUCBDb25uZWN0aW9uIG9wdGlvbnNcbiAqL1xuY2xhc3MgU01UUFBvb2wgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IG9wdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdXJsRGF0YTtcbiAgICAgICAgbGV0IHNlcnZpY2UgPSBvcHRpb25zLnNlcnZpY2U7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmdldFNvY2tldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5nZXRTb2NrZXQgPSBvcHRpb25zLmdldFNvY2tldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnVybCkge1xuICAgICAgICAgICAgdXJsRGF0YSA9IHNoYXJlZC5wYXJzZUNvbm5lY3Rpb25Vcmwob3B0aW9ucy51cmwpO1xuICAgICAgICAgICAgc2VydmljZSA9IHNlcnZpY2UgfHwgdXJsRGF0YS5zZXJ2aWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gc2hhcmVkLmFzc2lnbihcbiAgICAgICAgICAgIGZhbHNlLCAvLyBjcmVhdGUgbmV3IG9iamVjdFxuICAgICAgICAgICAgb3B0aW9ucywgLy8gcmVndWxhciBvcHRpb25zXG4gICAgICAgICAgICB1cmxEYXRhLCAvLyB1cmwgb3B0aW9uc1xuICAgICAgICAgICAgc2VydmljZSAmJiB3ZWxsS25vd24oc2VydmljZSkgLy8gd2VsbGtub3duIG9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4Q29ubmVjdGlvbnMgPSB0aGlzLm9wdGlvbnMubWF4Q29ubmVjdGlvbnMgfHwgNTtcbiAgICAgICAgdGhpcy5vcHRpb25zLm1heE1lc3NhZ2VzID0gdGhpcy5vcHRpb25zLm1heE1lc3NhZ2VzIHx8IDEwMDtcblxuICAgICAgICB0aGlzLmxvZ2dlciA9IHNoYXJlZC5nZXRMb2dnZXIodGhpcy5vcHRpb25zLCB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMub3B0aW9ucy5jb21wb25lbnQgfHwgJ3NtdHAtcG9vbCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGVtcG9yYXJ5IG9iamVjdFxuICAgICAgICBsZXQgY29ubmVjdGlvbiA9IG5ldyBTTVRQQ29ubmVjdGlvbih0aGlzLm9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdTTVRQIChwb29sKSc7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHBhY2thZ2VEYXRhLnZlcnNpb24gKyAnW2NsaWVudDonICsgY29ubmVjdGlvbi52ZXJzaW9uICsgJ10nO1xuXG4gICAgICAgIHRoaXMuX3JhdGVMaW1pdCA9IHtcbiAgICAgICAgICAgIGNvdW50ZXI6IDAsXG4gICAgICAgICAgICB0aW1lb3V0OiBudWxsLFxuICAgICAgICAgICAgd2FpdGluZzogW10sXG4gICAgICAgICAgICBjaGVja3BvaW50OiBmYWxzZSxcbiAgICAgICAgICAgIGRlbHRhOiBOdW1iZXIodGhpcy5vcHRpb25zLnJhdGVEZWx0YSkgfHwgMTAwMCxcbiAgICAgICAgICAgIGxpbWl0OiBOdW1iZXIodGhpcy5vcHRpb25zLnJhdGVMaW1pdCkgfHwgMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbkNvdW50ZXIgPSAwO1xuXG4gICAgICAgIHRoaXMuaWRsaW5nID0gdHJ1ZTtcblxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRsaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpZGxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBwcm94eSBzb2NrZXRzLiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVsbHkgcmV0dXJuc1xuICAgICAqIHdpdGhvdXQgYSBzb2NrZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aXRoIHRoZSBzb2NrZXQga2V5c1xuICAgICAqL1xuICAgIGdldFNvY2tldChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyByZXR1cm4gaW1tZWRpYXRlbGx5XG4gICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwgZmFsc2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBRdWV1ZXMgYW4gZS1tYWlsIHRvIGJlIHNlbnQgdXNpbmcgdGhlIHNlbGVjdGVkIHNldHRpbmdzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFpbCBNYWlsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgc2VuZChtYWlsLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIG1haWwsXG4gICAgICAgICAgICByZXF1ZXVlQXR0ZW1wdHM6IDAsXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5pZGxpbmcgJiYgdGhpcy5fcXVldWUubGVuZ3RoID49IHRoaXMub3B0aW9ucy5tYXhDb25uZWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5pZGxpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9wcm9jZXNzTWVzc2FnZXMoKSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFsbCBjb25uZWN0aW9ucyBpbiB0aGUgcG9vbC4gSWYgdGhlcmUgaXMgYSBtZXNzYWdlIGJlaW5nIHNlbnQsIHRoZSBjb25uZWN0aW9uXG4gICAgICogaXMgY2xvc2VkIGxhdGVyXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGxldCBjb25uZWN0aW9uO1xuICAgICAgICBsZXQgbGVuID0gdGhpcy5fY29ubmVjdGlvbnMubGVuZ3RoO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIGNsZWFyIHJhdGUgbGltaXQgdGltZXIgaWYgaXQgZXhpc3RzXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yYXRlTGltaXQudGltZW91dCk7XG5cbiAgICAgICAgaWYgKCFsZW4gJiYgIXRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBhdmFpbGFibGUgY29ubmVjdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGlvbnNbaV0gJiYgdGhpcy5fY29ubmVjdGlvbnNbaV0uYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bng6ICdjb25uZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpZDogY29ubmVjdGlvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ3JlbW92ZWQnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdDb25uZWN0aW9uICMlcyByZW1vdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5pZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuICYmICF0aGlzLl9jb25uZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG54OiAnY29ubmVjdGlvbidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdBbGwgY29ubmVjdGlvbnMgcmVtb3ZlZCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgZW50aXJlIHF1ZXVlIHdvdWxkIGJlIGNsZWFuZWRcbiAgICAgICAgbGV0IGludm9rZUNhbGxiYWNrcyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ2Nvbm5lY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdQZW5kaW5nIHF1ZXVlIGVudHJpZXMgY2xlYXJlZCdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbnRyeSA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoZW50cnkgJiYgdHlwZW9mIGVudHJ5LmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuY2FsbGJhY2sobmV3IEVycm9yKCdDb25uZWN0aW9uIHBvb2wgd2FzIGNsb3NlZCcpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycjogRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bng6ICdjYWxsYmFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lkOiBjb25uZWN0aW9uLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbGxiYWNrIGVycm9yIGZvciAjJXM6ICVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBFLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoaW52b2tlQ2FsbGJhY2tzKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGludm9rZUNhbGxiYWNrcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIHF1ZXVlIGFuZCBhdmFpbGFibGUgY29ubmVjdGlvbnMuIElmIHRoZXJlIGlzIGEgbWVzc2FnZSB0byBiZSBzZW50IGFuZCB0aGVyZSBpc1xuICAgICAqIGFuIGF2YWlsYWJsZSBjb25uZWN0aW9uLCB0aGVuIHVzZSB0aGlzIGNvbm5lY3Rpb24gdG8gc2VuZCB0aGUgbWFpbFxuICAgICAqL1xuICAgIF9wcm9jZXNzTWVzc2FnZXMoKSB7XG4gICAgICAgIGxldCBjb25uZWN0aW9uO1xuICAgICAgICBsZXQgaSwgbGVuO1xuXG4gICAgICAgIC8vIGRvIG5vdGhpbmcgaWYgYWxyZWFkeSBjbG9zZWRcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG8gbm90aGluZyBpZiBxdWV1ZSBpcyBlbXB0eVxuICAgICAgICBpZiAoIXRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlkbGluZykge1xuICAgICAgICAgICAgICAgIC8vIG5vIHBlbmRpbmcgam9ic1xuICAgICAgICAgICAgICAgIHRoaXMuaWRsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2lkbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgZmlyc3QgYXZhaWxhYmxlIGNvbm5lY3Rpb25cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5fY29ubmVjdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uc1tpXS5hdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gdGhpcy5fY29ubmVjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbm5lY3Rpb24gJiYgdGhpcy5fY29ubmVjdGlvbnMubGVuZ3RoIDwgdGhpcy5vcHRpb25zLm1heENvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uID0gdGhpcy5fY3JlYXRlQ29ubmVjdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBubyBtb3JlIGZyZWUgY29ubmVjdGlvbiBzbG90cyBhdmFpbGFibGVcbiAgICAgICAgICAgIHRoaXMuaWRsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBmcmVlIHNwYWNlIGluIHRoZSBwcm9jZXNzaW5nIHF1ZXVlXG4gICAgICAgIGlmICghdGhpcy5pZGxpbmcgJiYgdGhpcy5fcXVldWUubGVuZ3RoIDwgdGhpcy5vcHRpb25zLm1heENvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmlkbGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2lkbGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBlbnRyeSA9IChjb25uZWN0aW9uLnF1ZXVlRW50cnkgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpKTtcbiAgICAgICAgZW50cnkubWVzc2FnZUlkID0gKGNvbm5lY3Rpb24ucXVldWVFbnRyeS5tYWlsLm1lc3NhZ2UuZ2V0SGVhZGVyKCdtZXNzYWdlLWlkJykgfHwgJycpLnJlcGxhY2UoL1s8Plxcc10vZywgJycpO1xuXG4gICAgICAgIGNvbm5lY3Rpb24uYXZhaWxhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG54OiAncG9vbCcsXG4gICAgICAgICAgICAgICAgY2lkOiBjb25uZWN0aW9uLmlkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogZW50cnkubWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2Fzc2lnbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnQXNzaWduZWQgbWVzc2FnZSA8JXM+IHRvICMlcyAoJXMpJyxcbiAgICAgICAgICAgIGVudHJ5Lm1lc3NhZ2VJZCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uaWQsXG4gICAgICAgICAgICBjb25uZWN0aW9uLm1lc3NhZ2VzICsgMVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLl9yYXRlTGltaXQubGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JhdGVMaW1pdC5jb3VudGVyKys7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JhdGVMaW1pdC5jaGVja3BvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF0ZUxpbWl0LmNoZWNrcG9pbnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29ubmVjdGlvbi5zZW5kKGVudHJ5Lm1haWwsIChlcnIsIGluZm8pID0+IHtcbiAgICAgICAgICAgIC8vIG9ubHkgcHJvY2VzcyBjYWxsYmFjayBpZiBjdXJyZW50IGhhbmRsZXIgaXMgbm90IGNoYW5nZWRcbiAgICAgICAgICAgIGlmIChlbnRyeSA9PT0gY29ubmVjdGlvbi5xdWV1ZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuY2FsbGJhY2soZXJyLCBpbmZvKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycjogRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bng6ICdjYWxsYmFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lkOiBjb25uZWN0aW9uLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbGxiYWNrIGVycm9yIGZvciAjJXM6ICVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBFLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5xdWV1ZUVudHJ5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcG9vbCByZXNvdXJjZVxuICAgICAqL1xuICAgIF9jcmVhdGVDb25uZWN0aW9uKCkge1xuICAgICAgICBsZXQgY29ubmVjdGlvbiA9IG5ldyBQb29sUmVzb3VyY2UodGhpcyk7XG5cbiAgICAgICAgY29ubmVjdGlvbi5pZCA9ICsrdGhpcy5fY29ubmVjdGlvbkNvdW50ZXI7XG5cbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0bng6ICdwb29sJyxcbiAgICAgICAgICAgICAgICBjaWQ6IGNvbm5lY3Rpb24uaWQsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnY29uZWN0aW9uJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdDcmVhdGVkIG5ldyBwb29sIHJlc291cmNlICMlcycsXG4gICAgICAgICAgICBjb25uZWN0aW9uLmlkXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gcmVzb3VyY2UgY29tZXMgYXZhaWxhYmxlXG4gICAgICAgIGNvbm5lY3Rpb24ub24oJ2F2YWlsYWJsZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG54OiAnY29ubmVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNpZDogY29ubmVjdGlvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnYXZhaWxhYmxlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ0Nvbm5lY3Rpb24gIyVzIGJlY2FtZSBhdmFpbGFibGUnLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uaWRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhbHJlYWR5IGNsb3NlZCBydW4gY2xvc2UoKSB0aGF0IHdpbGwgcmVtb3ZlIHRoaXMgY29ubmVjdGlvbnMgZnJvbSBjb25uZWN0aW9ucyBsaXN0XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSdzIGFueXRoaW5nIGVsc2UgdG8gc2VuZFxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNZXNzYWdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZXNvdXJjZSBpcyB0ZXJtaW5hdGVkIHdpdGggYW4gZXJyb3JcbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdFTUFYTElNSVQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3Bvb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2lkOiBjb25uZWN0aW9uLmlkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdQb29sIEVycm9yIGZvciAjJXM6ICVzJyxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG54OiAncG9vbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaWQ6IGNvbm5lY3Rpb24uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdtYXhsaW1pdCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ01heCBtZXNzYWdlcyBsaW1pdCBleGNoYXVzdGVkIGZvciAjJXMnLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmlkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24ucXVldWVFbnRyeSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ucXVldWVFbnRyeS5jYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyOiBFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ2NhbGxiYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaWQ6IGNvbm5lY3Rpb24uaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ2FsbGJhY2sgZXJyb3IgZm9yICMlczogJXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIEUubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnF1ZXVlRW50cnkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBlcnJvbmV1cyBjb25uZWN0aW9uIGZyb20gY29ubmVjdGlvbnMgbGlzdFxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5fY29udGludWVQcm9jZXNzaW5nKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbm5lY3Rpb24ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG54OiAnY29ubmVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGNpZDogY29ubmVjdGlvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnY2xvc2VkJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ0Nvbm5lY3Rpb24gIyVzIHdhcyBjbG9zZWQnLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uaWRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnF1ZXVlRW50cnkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29ubmVjdGlvbiBjbG9zZWQgd2hlbiBzZW5kaW5nLCBhZGQgdGhlIG1lc3NhZ2UgdG8gdGhlIHF1ZXVlIGFnYWluXG4gICAgICAgICAgICAgICAgLy8gaWYgbWF4IG51bWJlciBvZiByZXF1ZXVlcyBpcyBub3QgcmVhY2hlZCB5ZXRcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2UgbXVzdCB3YWl0IGEgYml0Li4gYmVjYXVzZSB0aGUgY2FsbGJhY2sgb2YgdGhlICdlcnJvcicgaGFuZGxlciBtaWdodCBiZSBjYWxsZWRcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbmV4dCBldmVudCBsb29wXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnF1ZXVlRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG91bGRSZXF1ZXVPbkNvbm5lY3Rpb25DbG9zZShjb25uZWN0aW9uLnF1ZXVlRW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVxdWV1ZUVudHJ5T25Db25uZWN0aW9uQ2xvc2UoY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZhaWxEZWxpdmVyeU9uQ29ubmVjdGlvbkNsb3NlKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRpbnVlUHJvY2Vzc2luZygpO1xuICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGludWVQcm9jZXNzaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25zLnB1c2goY29ubmVjdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfVxuXG4gICAgX3Nob3VsZFJlcXVldU9uQ29ubmVjdGlvbkNsb3NlKHF1ZXVlRW50cnkpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXhSZXF1ZXVlcyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5tYXhSZXF1ZXVlcyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXVlRW50cnkucmVxdWV1ZUF0dGVtcHRzIDwgdGhpcy5vcHRpb25zLm1heFJlcXVldWVzO1xuICAgIH1cblxuICAgIF9mYWlsRGVsaXZlcnlPbkNvbm5lY3Rpb25DbG9zZShjb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnF1ZXVlRW50cnkgJiYgY29ubmVjdGlvbi5xdWV1ZUVudHJ5LmNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ucXVldWVFbnRyeS5jYWxsYmFjayhuZXcgRXJyb3IoJ1JlYWNoZWQgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllcyBhZnRlciBjb25uZWN0aW9uIHdhcyBjbG9zZWQnKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycjogRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ2NhbGxiYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogY29ubmVjdGlvbi5xdWV1ZUVudHJ5Lm1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpZDogY29ubmVjdGlvbi5pZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnQ2FsbGJhY2sgZXJyb3IgZm9yICMlczogJXMnLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmlkLFxuICAgICAgICAgICAgICAgICAgICBFLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdGlvbi5xdWV1ZUVudHJ5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVxdWV1ZUVudHJ5T25Db25uZWN0aW9uQ2xvc2UoY29ubmVjdGlvbikge1xuICAgICAgICBjb25uZWN0aW9uLnF1ZXVlRW50cnkucmVxdWV1ZUF0dGVtcHRzID0gY29ubmVjdGlvbi5xdWV1ZUVudHJ5LnJlcXVldWVBdHRlbXB0cyArIDE7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRueDogJ3Bvb2wnLFxuICAgICAgICAgICAgICAgIGNpZDogY29ubmVjdGlvbi5pZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IGNvbm5lY3Rpb24ucXVldWVFbnRyeS5tZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncmVxdWV1ZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnUmUtcXVldWVkIG1lc3NhZ2UgPCVzPiBmb3IgIyVzLiBBdHRlbXB0OiAjJXMnLFxuICAgICAgICAgICAgY29ubmVjdGlvbi5xdWV1ZUVudHJ5Lm1lc3NhZ2VJZCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uaWQsXG4gICAgICAgICAgICBjb25uZWN0aW9uLnF1ZXVlRW50cnkucmVxdWV1ZUF0dGVtcHRzXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnVuc2hpZnQoY29ubmVjdGlvbi5xdWV1ZUVudHJ5KTtcbiAgICAgICAgY29ubmVjdGlvbi5xdWV1ZUVudHJ5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udGludWUgdG8gcHJvY2VzcyBtZXNzYWdlIGlmIHRoZSBwb29sIGhhc24ndCBjbG9zZWRcbiAgICAgKi9cbiAgICBfY29udGludWVQcm9jZXNzaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX3Byb2Nlc3NNZXNzYWdlcygpLCAxMDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHJlc291cmNlIGZyb20gcG9vbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb24gVGhlIFBvb2xSZXNvdXJjZSB0byByZW1vdmVcbiAgICAgKi9cbiAgICBfcmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuX2Nvbm5lY3Rpb25zLmluZGV4T2YoY29ubmVjdGlvbik7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBjb25uZWN0aW9ucyBoYXZlIGhpdCBjdXJyZW50IHJhdGUgbGltaXQgYW5kIGlmIHNvLCBxdWV1ZXMgdGhlIGF2YWlsYWJpbGl0eSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIG9uY2UgcmF0ZSBsaW1pdGVyIGhhcyBiZWVuIGNsZWFyZWRcbiAgICAgKi9cbiAgICBfY2hlY2tSYXRlTGltaXQoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yYXRlTGltaXQubGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JhdGVMaW1pdC5jb3VudGVyIDwgdGhpcy5fcmF0ZUxpbWl0LmxpbWl0KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JhdGVMaW1pdC53YWl0aW5nLnB1c2goY2FsbGJhY2spO1xuXG4gICAgICAgIGlmICh0aGlzLl9yYXRlTGltaXQuY2hlY2twb2ludCA8PSBub3cgLSB0aGlzLl9yYXRlTGltaXQuZGVsdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGVhclJhdGVMaW1pdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9yYXRlTGltaXQudGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5fcmF0ZUxpbWl0LnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX2NsZWFyUmF0ZUxpbWl0KCksIHRoaXMuX3JhdGVMaW1pdC5kZWx0YSAtIChub3cgLSB0aGlzLl9yYXRlTGltaXQuY2hlY2twb2ludCkpO1xuICAgICAgICAgICAgdGhpcy5fcmF0ZUxpbWl0LmNoZWNrcG9pbnQgPSBub3c7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgY3VycmVudCByYXRlIGxpbWl0IGxpbWl0YXRpb24gYW5kIHJ1bnMgcGF1c2VkIGNhbGxiYWNrXG4gICAgICovXG4gICAgX2NsZWFyUmF0ZUxpbWl0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmF0ZUxpbWl0LnRpbWVvdXQpO1xuICAgICAgICB0aGlzLl9yYXRlTGltaXQudGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JhdGVMaW1pdC5jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fcmF0ZUxpbWl0LmNoZWNrcG9pbnQgPSBmYWxzZTtcblxuICAgICAgICAvLyByZXN1bWUgYWxsIHBhdXNlZCBjb25uZWN0aW9uc1xuICAgICAgICB3aGlsZSAodGhpcy5fcmF0ZUxpbWl0LndhaXRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY2IgPSB0aGlzLl9yYXRlTGltaXQud2FpdGluZy5zaGlmdCgpO1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGNiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgZnJlZSBzbG90cyBpbiB0aGUgcXVldWVcbiAgICAgKi9cbiAgICBpc0lkbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkbGluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBTTVRQIGNvbmZpZ3VyYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgdmVyaWZ5KGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBwcm9taXNlO1xuXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBzaGFyZWQuY2FsbGJhY2tQcm9taXNlKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhdXRoID0gbmV3IFBvb2xSZXNvdXJjZSh0aGlzKS5hdXRoO1xuXG4gICAgICAgIHRoaXMuZ2V0U29ja2V0KHRoaXMub3B0aW9ucywgKGVyciwgc29ja2V0T3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChzb2NrZXRPcHRpb25zICYmIHNvY2tldE9wdGlvbnMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3Byb3h5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IHNvY2tldE9wdGlvbnMuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlUG9ydDogc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uLnJlbW90ZVBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0SG9zdDogb3B0aW9ucy5ob3N0IHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFBvcnQ6IG9wdGlvbnMucG9ydCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2Nvbm5lY3RlZCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ1VzaW5nIHByb3hpZWQgc29ja2V0IGZyb20gJXM6JXMgdG8gJXM6JXMnLFxuICAgICAgICAgICAgICAgICAgICBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uLnJlbW90ZVBvcnQsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaG9zdCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wb3J0IHx8ICcnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gc2hhcmVkLmFzc2lnbihmYWxzZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc29ja2V0T3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSBzb2NrZXRPcHRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjb25uZWN0aW9uID0gbmV3IFNNVFBDb25uZWN0aW9uKG9wdGlvbnMpO1xuICAgICAgICAgICAgbGV0IHJldHVybmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24ub25jZSgnZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gY2xvc2VkJykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxldCBmaW5hbGl6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5xdWl0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhdXRoICYmIChjb25uZWN0aW9uLmFsbG93c0F1dGggfHwgb3B0aW9ucy5mb3JjZUF1dGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ubG9naW4oYXV0aCwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWF1dGggJiYgY29ubmVjdGlvbi5hbGxvd3NBdXRoICYmIG9wdGlvbnMuZm9yY2VBdXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGluZm8gd2FzIG5vdCBwcm92aWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSA9ICdOb0F1dGgnO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG59XG5cbi8vIGV4cG9zZSB0byB0aGUgd29ybGRcbm1vZHVsZS5leHBvcnRzID0gU01UUFBvb2w7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/smtp-pool/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/smtp-pool/pool-resource.js":
/*!****************************************************************!*\
  !*** ./node_modules/nodemailer/lib/smtp-pool/pool-resource.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst SMTPConnection = __webpack_require__(/*! ../smtp-connection */ \"(rsc)/./node_modules/nodemailer/lib/smtp-connection/index.js\");\nconst assign = (__webpack_require__(/*! ../shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\").assign);\nconst XOAuth2 = __webpack_require__(/*! ../xoauth2 */ \"(rsc)/./node_modules/nodemailer/lib/xoauth2/index.js\");\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\n\n/**\n * Creates an element for the pool\n *\n * @constructor\n * @param {Object} options SMTPPool instance\n */\nclass PoolResource extends EventEmitter {\n    constructor(pool) {\n        super();\n\n        this.pool = pool;\n        this.options = pool.options;\n        this.logger = this.pool.logger;\n\n        if (this.options.auth) {\n            switch ((this.options.auth.type || '').toString().toUpperCase()) {\n                case 'OAUTH2': {\n                    let oauth2 = new XOAuth2(this.options.auth, this.logger);\n                    oauth2.provisionCallback = (this.pool.mailer && this.pool.mailer.get('oauth2_provision_cb')) || oauth2.provisionCallback;\n                    this.auth = {\n                        type: 'OAUTH2',\n                        user: this.options.auth.user,\n                        oauth2,\n                        method: 'XOAUTH2'\n                    };\n                    oauth2.on('token', token => this.pool.mailer.emit('token', token));\n                    oauth2.on('error', err => this.emit('error', err));\n                    break;\n                }\n                default:\n                    if (!this.options.auth.user && !this.options.auth.pass) {\n                        break;\n                    }\n                    this.auth = {\n                        type: (this.options.auth.type || '').toString().toUpperCase() || 'LOGIN',\n                        user: this.options.auth.user,\n                        credentials: {\n                            user: this.options.auth.user || '',\n                            pass: this.options.auth.pass,\n                            options: this.options.auth.options\n                        },\n                        method: (this.options.auth.method || '').trim().toUpperCase() || this.options.authMethod || false\n                    };\n            }\n        }\n\n        this._connection = false;\n        this._connected = false;\n\n        this.messages = 0;\n        this.available = true;\n    }\n\n    /**\n     * Initiates a connection to the SMTP server\n     *\n     * @param {Function} callback Callback function to run once the connection is established or failed\n     */\n    connect(callback) {\n        this.pool.getSocket(this.options, (err, socketOptions) => {\n            if (err) {\n                return callback(err);\n            }\n\n            let returned = false;\n            let options = this.options;\n            if (socketOptions && socketOptions.connection) {\n                this.logger.info(\n                    {\n                        tnx: 'proxy',\n                        remoteAddress: socketOptions.connection.remoteAddress,\n                        remotePort: socketOptions.connection.remotePort,\n                        destHost: options.host || '',\n                        destPort: options.port || '',\n                        action: 'connected'\n                    },\n                    'Using proxied socket from %s:%s to %s:%s',\n                    socketOptions.connection.remoteAddress,\n                    socketOptions.connection.remotePort,\n                    options.host || '',\n                    options.port || ''\n                );\n\n                options = assign(false, options);\n                Object.keys(socketOptions).forEach(key => {\n                    options[key] = socketOptions[key];\n                });\n            }\n\n            this.connection = new SMTPConnection(options);\n\n            this.connection.once('error', err => {\n                this.emit('error', err);\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                return callback(err);\n            });\n\n            this.connection.once('end', () => {\n                this.close();\n                if (returned) {\n                    return;\n                }\n                returned = true;\n\n                let timer = setTimeout(() => {\n                    if (returned) {\n                        return;\n                    }\n                    // still have not returned, this means we have an unexpected connection close\n                    let err = new Error('Unexpected socket close');\n                    if (this.connection && this.connection._socket && this.connection._socket.upgrading) {\n                        // starttls connection errors\n                        err.code = 'ETLS';\n                    }\n                    callback(err);\n                }, 1000);\n\n                try {\n                    timer.unref();\n                } catch (E) {\n                    // Ignore. Happens on envs with non-node timer implementation\n                }\n            });\n\n            this.connection.connect(() => {\n                if (returned) {\n                    return;\n                }\n\n                if (this.auth && (this.connection.allowsAuth || options.forceAuth)) {\n                    this.connection.login(this.auth, err => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n\n                        if (err) {\n                            this.connection.close();\n                            this.emit('error', err);\n                            return callback(err);\n                        }\n\n                        this._connected = true;\n                        callback(null, true);\n                    });\n                } else {\n                    returned = true;\n                    this._connected = true;\n                    return callback(null, true);\n                }\n            });\n        });\n    }\n\n    /**\n     * Sends an e-mail to be sent using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n    send(mail, callback) {\n        if (!this._connected) {\n            return this.connect(err => {\n                if (err) {\n                    return callback(err);\n                }\n                return this.send(mail, callback);\n            });\n        }\n\n        let envelope = mail.message.getEnvelope();\n        let messageId = mail.message.messageId();\n\n        let recipients = [].concat(envelope.to || []);\n        if (recipients.length > 3) {\n            recipients.push('...and ' + recipients.splice(2).length + ' more');\n        }\n        this.logger.info(\n            {\n                tnx: 'send',\n                messageId,\n                cid: this.id\n            },\n            'Sending message %s using #%s to <%s>',\n            messageId,\n            this.id,\n            recipients.join(', ')\n        );\n\n        if (mail.data.dsn) {\n            envelope.dsn = mail.data.dsn;\n        }\n\n        this.connection.send(envelope, mail.message.createReadStream(), (err, info) => {\n            this.messages++;\n\n            if (err) {\n                this.connection.close();\n                this.emit('error', err);\n                return callback(err);\n            }\n\n            info.envelope = {\n                from: envelope.from,\n                to: envelope.to\n            };\n            info.messageId = messageId;\n\n            setImmediate(() => {\n                let err;\n                if (this.messages >= this.options.maxMessages) {\n                    err = new Error('Resource exhausted');\n                    err.code = 'EMAXLIMIT';\n                    this.connection.close();\n                    this.emit('error', err);\n                } else {\n                    this.pool._checkRateLimit(() => {\n                        this.available = true;\n                        this.emit('available');\n                    });\n                }\n            });\n\n            callback(null, info);\n        });\n    }\n\n    /**\n     * Closes the connection\n     */\n    close() {\n        this._connected = false;\n        if (this.auth && this.auth.oauth2) {\n            this.auth.oauth2.removeAllListeners();\n        }\n        if (this.connection) {\n            this.connection.close();\n        }\n        this.emit('close');\n    }\n}\n\nmodule.exports = PoolResource;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc210cC1wb29sL3Bvb2wtcmVzb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQW9CO0FBQ25ELGVBQWUsb0dBQTJCO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFZO0FBQ3BDLHFCQUFxQixtQkFBTyxDQUFDLHNCQUFROztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhOztBQUViO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9zbXRwLXBvb2wvcG9vbC1yZXNvdXJjZS5qcz83NTBiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU01UUENvbm5lY3Rpb24gPSByZXF1aXJlKCcuLi9zbXRwLWNvbm5lY3Rpb24nKTtcbmNvbnN0IGFzc2lnbiA9IHJlcXVpcmUoJy4uL3NoYXJlZCcpLmFzc2lnbjtcbmNvbnN0IFhPQXV0aDIgPSByZXF1aXJlKCcuLi94b2F1dGgyJyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVsZW1lbnQgZm9yIHRoZSBwb29sXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBTTVRQUG9vbCBpbnN0YW5jZVxuICovXG5jbGFzcyBQb29sUmVzb3VyY2UgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvb2wpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnBvb2wgPSBwb29sO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBwb29sLm9wdGlvbnM7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gdGhpcy5wb29sLmxvZ2dlcjtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dGgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoKHRoaXMub3B0aW9ucy5hdXRoLnR5cGUgfHwgJycpLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ09BVVRIMic6IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9hdXRoMiA9IG5ldyBYT0F1dGgyKHRoaXMub3B0aW9ucy5hdXRoLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgICAgICAgICAgICAgIG9hdXRoMi5wcm92aXNpb25DYWxsYmFjayA9ICh0aGlzLnBvb2wubWFpbGVyICYmIHRoaXMucG9vbC5tYWlsZXIuZ2V0KCdvYXV0aDJfcHJvdmlzaW9uX2NiJykpIHx8IG9hdXRoMi5wcm92aXNpb25DYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ09BVVRIMicsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyOiB0aGlzLm9wdGlvbnMuYXV0aC51c2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2F1dGgyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnWE9BVVRIMidcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgb2F1dGgyLm9uKCd0b2tlbicsIHRva2VuID0+IHRoaXMucG9vbC5tYWlsZXIuZW1pdCgndG9rZW4nLCB0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICBvYXV0aDIub24oJ2Vycm9yJywgZXJyID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmF1dGgudXNlciAmJiAhdGhpcy5vcHRpb25zLmF1dGgucGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogKHRoaXMub3B0aW9ucy5hdXRoLnR5cGUgfHwgJycpLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSB8fCAnTE9HSU4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjogdGhpcy5vcHRpb25zLmF1dGgudXNlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjogdGhpcy5vcHRpb25zLmF1dGgudXNlciB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzOiB0aGlzLm9wdGlvbnMuYXV0aC5wYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucy5hdXRoLm9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICh0aGlzLm9wdGlvbnMuYXV0aC5tZXRob2QgfHwgJycpLnRyaW0oKS50b1VwcGVyQ2FzZSgpIHx8IHRoaXMub3B0aW9ucy5hdXRoTWV0aG9kIHx8IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSAwO1xuICAgICAgICB0aGlzLmF2YWlsYWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhdGVzIGEgY29ubmVjdGlvbiB0byB0aGUgU01UUCBzZXJ2ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biBvbmNlIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIG9yIGZhaWxlZFxuICAgICAqL1xuICAgIGNvbm5lY3QoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5wb29sLmdldFNvY2tldCh0aGlzLm9wdGlvbnMsIChlcnIsIHNvY2tldE9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJldHVybmVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChzb2NrZXRPcHRpb25zICYmIHNvY2tldE9wdGlvbnMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3Byb3h5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IHNvY2tldE9wdGlvbnMuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlUG9ydDogc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uLnJlbW90ZVBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0SG9zdDogb3B0aW9ucy5ob3N0IHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFBvcnQ6IG9wdGlvbnMucG9ydCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2Nvbm5lY3RlZCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ1VzaW5nIHByb3hpZWQgc29ja2V0IGZyb20gJXM6JXMgdG8gJXM6JXMnLFxuICAgICAgICAgICAgICAgICAgICBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uLnJlbW90ZVBvcnQsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaG9zdCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wb3J0IHx8ICcnXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhc3NpZ24oZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvY2tldE9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gc29ja2V0T3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgU01UUENvbm5lY3Rpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbmNlKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGxldCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBzdGlsbCBoYXZlIG5vdCByZXR1cm5lZCwgdGhpcyBtZWFucyB3ZSBoYXZlIGFuIHVuZXhwZWN0ZWQgY29ubmVjdGlvbiBjbG9zZVxuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyID0gbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNvY2tldCBjbG9zZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uICYmIHRoaXMuY29ubmVjdGlvbi5fc29ja2V0ICYmIHRoaXMuY29ubmVjdGlvbi5fc29ja2V0LnVwZ3JhZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnR0bHMgY29ubmVjdGlvbiBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gJ0VUTFMnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSwgMTAwMCk7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lci51bnJlZigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlLiBIYXBwZW5zIG9uIGVudnMgd2l0aCBub24tbm9kZSB0aW1lciBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRoICYmICh0aGlzLmNvbm5lY3Rpb24uYWxsb3dzQXV0aCB8fCBvcHRpb25zLmZvcmNlQXV0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2luKHRoaXMuYXV0aCwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhbiBlLW1haWwgdG8gYmUgc2VudCB1c2luZyB0aGUgc2VsZWN0ZWQgc2V0dGluZ3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYWlsIE1haWwgb2JqZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBzZW5kKG1haWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChtYWlsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBlbnZlbG9wZSA9IG1haWwubWVzc2FnZS5nZXRFbnZlbG9wZSgpO1xuICAgICAgICBsZXQgbWVzc2FnZUlkID0gbWFpbC5tZXNzYWdlLm1lc3NhZ2VJZCgpO1xuXG4gICAgICAgIGxldCByZWNpcGllbnRzID0gW10uY29uY2F0KGVudmVsb3BlLnRvIHx8IFtdKTtcbiAgICAgICAgaWYgKHJlY2lwaWVudHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgcmVjaXBpZW50cy5wdXNoKCcuLi5hbmQgJyArIHJlY2lwaWVudHMuc3BsaWNlKDIpLmxlbmd0aCArICcgbW9yZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG54OiAnc2VuZCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIGNpZDogdGhpcy5pZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdTZW5kaW5nIG1lc3NhZ2UgJXMgdXNpbmcgIyVzIHRvIDwlcz4nLFxuICAgICAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAgICAgdGhpcy5pZCxcbiAgICAgICAgICAgIHJlY2lwaWVudHMuam9pbignLCAnKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChtYWlsLmRhdGEuZHNuKSB7XG4gICAgICAgICAgICBlbnZlbG9wZS5kc24gPSBtYWlsLmRhdGEuZHNuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmQoZW52ZWxvcGUsIG1haWwubWVzc2FnZS5jcmVhdGVSZWFkU3RyZWFtKCksIChlcnIsIGluZm8pID0+IHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZXMrKztcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmZvLmVudmVsb3BlID0ge1xuICAgICAgICAgICAgICAgIGZyb206IGVudmVsb3BlLmZyb20sXG4gICAgICAgICAgICAgICAgdG86IGVudmVsb3BlLnRvXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW5mby5tZXNzYWdlSWQgPSBtZXNzYWdlSWQ7XG5cbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGVycjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXNzYWdlcyA+PSB0aGlzLm9wdGlvbnMubWF4TWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKCdSZXNvdXJjZSBleGhhdXN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLmNvZGUgPSAnRU1BWExJTUlUJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9vbC5fY2hlY2tSYXRlTGltaXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdmFpbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdhdmFpbGFibGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGluZm8pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmF1dGggJiYgdGhpcy5hdXRoLm9hdXRoMikge1xuICAgICAgICAgICAgdGhpcy5hdXRoLm9hdXRoMi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xSZXNvdXJjZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/smtp-pool/pool-resource.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/smtp-transport/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/nodemailer/lib/smtp-transport/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst SMTPConnection = __webpack_require__(/*! ../smtp-connection */ \"(rsc)/./node_modules/nodemailer/lib/smtp-connection/index.js\");\nconst wellKnown = __webpack_require__(/*! ../well-known */ \"(rsc)/./node_modules/nodemailer/lib/well-known/index.js\");\nconst shared = __webpack_require__(/*! ../shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\");\nconst XOAuth2 = __webpack_require__(/*! ../xoauth2 */ \"(rsc)/./node_modules/nodemailer/lib/xoauth2/index.js\");\nconst packageData = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/nodemailer/package.json\");\n\n/**\n * Creates a SMTP transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options Connection options\n */\nclass SMTPTransport extends EventEmitter {\n    constructor(options) {\n        super();\n\n        options = options || {};\n\n        if (typeof options === 'string') {\n            options = {\n                url: options\n            };\n        }\n\n        let urlData;\n        let service = options.service;\n\n        if (typeof options.getSocket === 'function') {\n            this.getSocket = options.getSocket;\n        }\n\n        if (options.url) {\n            urlData = shared.parseConnectionUrl(options.url);\n            service = service || urlData.service;\n        }\n\n        this.options = shared.assign(\n            false, // create new object\n            options, // regular options\n            urlData, // url options\n            service && wellKnown(service) // wellknown options\n        );\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-transport'\n        });\n\n        // temporary object\n        let connection = new SMTPConnection(this.options);\n\n        this.name = 'SMTP';\n        this.version = packageData.version + '[client:' + connection.version + ']';\n\n        if (this.options.auth) {\n            this.auth = this.getAuth({});\n        }\n    }\n\n    /**\n     * Placeholder function for creating proxy sockets. This method immediatelly returns\n     * without a socket\n     *\n     * @param {Object} options Connection options\n     * @param {Function} callback Callback function to run with the socket keys\n     */\n    getSocket(options, callback) {\n        // return immediatelly\n        return setImmediate(() => callback(null, false));\n    }\n\n    getAuth(authOpts) {\n        if (!authOpts) {\n            return this.auth;\n        }\n\n        let hasAuth = false;\n        let authData = {};\n\n        if (this.options.auth && typeof this.options.auth === 'object') {\n            Object.keys(this.options.auth).forEach(key => {\n                hasAuth = true;\n                authData[key] = this.options.auth[key];\n            });\n        }\n\n        if (authOpts && typeof authOpts === 'object') {\n            Object.keys(authOpts).forEach(key => {\n                hasAuth = true;\n                authData[key] = authOpts[key];\n            });\n        }\n\n        if (!hasAuth) {\n            return false;\n        }\n\n        switch ((authData.type || '').toString().toUpperCase()) {\n            case 'OAUTH2': {\n                if (!authData.service && !authData.user) {\n                    return false;\n                }\n                let oauth2 = new XOAuth2(authData, this.logger);\n                oauth2.provisionCallback = (this.mailer && this.mailer.get('oauth2_provision_cb')) || oauth2.provisionCallback;\n                oauth2.on('token', token => this.mailer.emit('token', token));\n                oauth2.on('error', err => this.emit('error', err));\n                return {\n                    type: 'OAUTH2',\n                    user: authData.user,\n                    oauth2,\n                    method: 'XOAUTH2'\n                };\n            }\n            default:\n                return {\n                    type: (authData.type || '').toString().toUpperCase() || 'LOGIN',\n                    user: authData.user,\n                    credentials: {\n                        user: authData.user || '',\n                        pass: authData.pass,\n                        options: authData.options\n                    },\n                    method: (authData.method || '').trim().toUpperCase() || this.options.authMethod || false\n                };\n        }\n    }\n\n    /**\n     * Sends an e-mail using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n    send(mail, callback) {\n        this.getSocket(this.options, (err, socketOptions) => {\n            if (err) {\n                return callback(err);\n            }\n\n            let returned = false;\n            let options = this.options;\n            if (socketOptions && socketOptions.connection) {\n                this.logger.info(\n                    {\n                        tnx: 'proxy',\n                        remoteAddress: socketOptions.connection.remoteAddress,\n                        remotePort: socketOptions.connection.remotePort,\n                        destHost: options.host || '',\n                        destPort: options.port || '',\n                        action: 'connected'\n                    },\n                    'Using proxied socket from %s:%s to %s:%s',\n                    socketOptions.connection.remoteAddress,\n                    socketOptions.connection.remotePort,\n                    options.host || '',\n                    options.port || ''\n                );\n\n                // only copy options if we need to modify it\n                options = shared.assign(false, options);\n                Object.keys(socketOptions).forEach(key => {\n                    options[key] = socketOptions[key];\n                });\n            }\n\n            let connection = new SMTPConnection(options);\n\n            connection.once('error', err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.close();\n                return callback(err);\n            });\n\n            connection.once('end', () => {\n                if (returned) {\n                    return;\n                }\n\n                let timer = setTimeout(() => {\n                    if (returned) {\n                        return;\n                    }\n                    returned = true;\n                    // still have not returned, this means we have an unexpected connection close\n                    let err = new Error('Unexpected socket close');\n                    if (connection && connection._socket && connection._socket.upgrading) {\n                        // starttls connection errors\n                        err.code = 'ETLS';\n                    }\n                    callback(err);\n                }, 1000);\n\n                try {\n                    timer.unref();\n                } catch (E) {\n                    // Ignore. Happens on envs with non-node timer implementation\n                }\n            });\n\n            let sendMessage = () => {\n                let envelope = mail.message.getEnvelope();\n                let messageId = mail.message.messageId();\n\n                let recipients = [].concat(envelope.to || []);\n                if (recipients.length > 3) {\n                    recipients.push('...and ' + recipients.splice(2).length + ' more');\n                }\n\n                if (mail.data.dsn) {\n                    envelope.dsn = mail.data.dsn;\n                }\n\n                this.logger.info(\n                    {\n                        tnx: 'send',\n                        messageId\n                    },\n                    'Sending message %s to <%s>',\n                    messageId,\n                    recipients.join(', ')\n                );\n\n                connection.send(envelope, mail.message.createReadStream(), (err, info) => {\n                    returned = true;\n                    connection.close();\n                    if (err) {\n                        this.logger.error(\n                            {\n                                err,\n                                tnx: 'send'\n                            },\n                            'Send error for %s: %s',\n                            messageId,\n                            err.message\n                        );\n                        return callback(err);\n                    }\n                    info.envelope = {\n                        from: envelope.from,\n                        to: envelope.to\n                    };\n                    info.messageId = messageId;\n                    try {\n                        return callback(null, info);\n                    } catch (E) {\n                        this.logger.error(\n                            {\n                                err: E,\n                                tnx: 'callback'\n                            },\n                            'Callback error for %s: %s',\n                            messageId,\n                            E.message\n                        );\n                    }\n                });\n            };\n\n            connection.connect(() => {\n                if (returned) {\n                    return;\n                }\n\n                let auth = this.getAuth(mail.data.auth);\n\n                if (auth && (connection.allowsAuth || options.forceAuth)) {\n                    connection.login(auth, err => {\n                        if (auth && auth !== this.auth && auth.oauth2) {\n                            auth.oauth2.removeAllListeners();\n                        }\n                        if (returned) {\n                            return;\n                        }\n\n                        if (err) {\n                            returned = true;\n                            connection.close();\n                            return callback(err);\n                        }\n\n                        sendMessage();\n                    });\n                } else {\n                    sendMessage();\n                }\n            });\n        });\n    }\n\n    /**\n     * Verifies SMTP configuration\n     *\n     * @param {Function} callback Callback function\n     */\n    verify(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        this.getSocket(this.options, (err, socketOptions) => {\n            if (err) {\n                return callback(err);\n            }\n\n            let options = this.options;\n            if (socketOptions && socketOptions.connection) {\n                this.logger.info(\n                    {\n                        tnx: 'proxy',\n                        remoteAddress: socketOptions.connection.remoteAddress,\n                        remotePort: socketOptions.connection.remotePort,\n                        destHost: options.host || '',\n                        destPort: options.port || '',\n                        action: 'connected'\n                    },\n                    'Using proxied socket from %s:%s to %s:%s',\n                    socketOptions.connection.remoteAddress,\n                    socketOptions.connection.remotePort,\n                    options.host || '',\n                    options.port || ''\n                );\n\n                options = shared.assign(false, options);\n                Object.keys(socketOptions).forEach(key => {\n                    options[key] = socketOptions[key];\n                });\n            }\n\n            let connection = new SMTPConnection(options);\n            let returned = false;\n\n            connection.once('error', err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.close();\n                return callback(err);\n            });\n\n            connection.once('end', () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                return callback(new Error('Connection closed'));\n            });\n\n            let finalize = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.quit();\n                return callback(null, true);\n            };\n\n            connection.connect(() => {\n                if (returned) {\n                    return;\n                }\n\n                let authData = this.getAuth({});\n\n                if (authData && (connection.allowsAuth || options.forceAuth)) {\n                    connection.login(authData, err => {\n                        if (returned) {\n                            return;\n                        }\n\n                        if (err) {\n                            returned = true;\n                            connection.close();\n                            return callback(err);\n                        }\n\n                        finalize();\n                    });\n                } else if (!authData && connection.allowsAuth && options.forceAuth) {\n                    let err = new Error('Authentication info was not provided');\n                    err.code = 'NoAuth';\n\n                    returned = true;\n                    connection.close();\n                    return callback(err);\n                } else {\n                    finalize();\n                }\n            });\n        });\n\n        return promise;\n    }\n\n    /**\n     * Releases resources\n     */\n    close() {\n        if (this.auth && this.auth.oauth2) {\n            this.auth.oauth2.removeAllListeners();\n        }\n        this.emit('close');\n    }\n}\n\n// expose to the world\nmodule.exports = SMTPTransport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc210cC10cmFuc3BvcnQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIscUJBQXFCLG1CQUFPLENBQUMsc0JBQVE7QUFDckMsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQW9CO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLDhFQUFlO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVztBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBWTtBQUNwQyxvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBb0I7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9zbXRwLXRyYW5zcG9ydC9pbmRleC5qcz9hMjg2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBTTVRQQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4uL3NtdHAtY29ubmVjdGlvbicpO1xuY29uc3Qgd2VsbEtub3duID0gcmVxdWlyZSgnLi4vd2VsbC1rbm93bicpO1xuY29uc3Qgc2hhcmVkID0gcmVxdWlyZSgnLi4vc2hhcmVkJyk7XG5jb25zdCBYT0F1dGgyID0gcmVxdWlyZSgnLi4veG9hdXRoMicpO1xuY29uc3QgcGFja2FnZURhdGEgPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU01UUCB0cmFuc3BvcnQgb2JqZWN0IGZvciBOb2RlbWFpbGVyXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqL1xuY2xhc3MgU01UUFRyYW5zcG9ydCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBvcHRpb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHVybERhdGE7XG4gICAgICAgIGxldCBzZXJ2aWNlID0gb3B0aW9ucy5zZXJ2aWNlO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5nZXRTb2NrZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U29ja2V0ID0gb3B0aW9ucy5nZXRTb2NrZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgIHVybERhdGEgPSBzaGFyZWQucGFyc2VDb25uZWN0aW9uVXJsKG9wdGlvbnMudXJsKTtcbiAgICAgICAgICAgIHNlcnZpY2UgPSBzZXJ2aWNlIHx8IHVybERhdGEuc2VydmljZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHNoYXJlZC5hc3NpZ24oXG4gICAgICAgICAgICBmYWxzZSwgLy8gY3JlYXRlIG5ldyBvYmplY3RcbiAgICAgICAgICAgIG9wdGlvbnMsIC8vIHJlZ3VsYXIgb3B0aW9uc1xuICAgICAgICAgICAgdXJsRGF0YSwgLy8gdXJsIG9wdGlvbnNcbiAgICAgICAgICAgIHNlcnZpY2UgJiYgd2VsbEtub3duKHNlcnZpY2UpIC8vIHdlbGxrbm93biBvcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5sb2dnZXIgPSBzaGFyZWQuZ2V0TG9nZ2VyKHRoaXMub3B0aW9ucywge1xuICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLm9wdGlvbnMuY29tcG9uZW50IHx8ICdzbXRwLXRyYW5zcG9ydCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGVtcG9yYXJ5IG9iamVjdFxuICAgICAgICBsZXQgY29ubmVjdGlvbiA9IG5ldyBTTVRQQ29ubmVjdGlvbih0aGlzLm9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdTTVRQJztcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gcGFja2FnZURhdGEudmVyc2lvbiArICdbY2xpZW50OicgKyBjb25uZWN0aW9uLnZlcnNpb24gKyAnXSc7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRoKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGggPSB0aGlzLmdldEF1dGgoe30pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIHByb3h5IHNvY2tldHMuIFRoaXMgbWV0aG9kIGltbWVkaWF0ZWxseSByZXR1cm5zXG4gICAgICogd2l0aG91dCBhIHNvY2tldFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIHdpdGggdGhlIHNvY2tldCBrZXlzXG4gICAgICovXG4gICAgZ2V0U29ja2V0KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHJldHVybiBpbW1lZGlhdGVsbHlcbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhudWxsLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIGdldEF1dGgoYXV0aE9wdHMpIHtcbiAgICAgICAgaWYgKCFhdXRoT3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXV0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBoYXNBdXRoID0gZmFsc2U7XG4gICAgICAgIGxldCBhdXRoRGF0YSA9IHt9O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0aCAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmF1dGggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuYXV0aCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGhhc0F1dGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF1dGhEYXRhW2tleV0gPSB0aGlzLm9wdGlvbnMuYXV0aFtrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXV0aE9wdHMgJiYgdHlwZW9mIGF1dGhPcHRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXV0aE9wdHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBoYXNBdXRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdXRoRGF0YVtrZXldID0gYXV0aE9wdHNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNBdXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKChhdXRoRGF0YS50eXBlIHx8ICcnKS50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ09BVVRIMic6IHtcbiAgICAgICAgICAgICAgICBpZiAoIWF1dGhEYXRhLnNlcnZpY2UgJiYgIWF1dGhEYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgb2F1dGgyID0gbmV3IFhPQXV0aDIoYXV0aERhdGEsIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgICAgICAgICBvYXV0aDIucHJvdmlzaW9uQ2FsbGJhY2sgPSAodGhpcy5tYWlsZXIgJiYgdGhpcy5tYWlsZXIuZ2V0KCdvYXV0aDJfcHJvdmlzaW9uX2NiJykpIHx8IG9hdXRoMi5wcm92aXNpb25DYWxsYmFjaztcbiAgICAgICAgICAgICAgICBvYXV0aDIub24oJ3Rva2VuJywgdG9rZW4gPT4gdGhpcy5tYWlsZXIuZW1pdCgndG9rZW4nLCB0b2tlbikpO1xuICAgICAgICAgICAgICAgIG9hdXRoMi5vbignZXJyb3InLCBlcnIgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVycikpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdPQVVUSDInLFxuICAgICAgICAgICAgICAgICAgICB1c2VyOiBhdXRoRGF0YS51c2VyLFxuICAgICAgICAgICAgICAgICAgICBvYXV0aDIsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1hPQVVUSDInXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogKGF1dGhEYXRhLnR5cGUgfHwgJycpLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSB8fCAnTE9HSU4nLFxuICAgICAgICAgICAgICAgICAgICB1c2VyOiBhdXRoRGF0YS51c2VyLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjogYXV0aERhdGEudXNlciB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3M6IGF1dGhEYXRhLnBhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBhdXRoRGF0YS5vcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogKGF1dGhEYXRhLm1ldGhvZCB8fCAnJykudHJpbSgpLnRvVXBwZXJDYXNlKCkgfHwgdGhpcy5vcHRpb25zLmF1dGhNZXRob2QgfHwgZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgYW4gZS1tYWlsIHVzaW5nIHRoZSBzZWxlY3RlZCBzZXR0aW5nc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1haWwgTWFpbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIHNlbmQobWFpbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5nZXRTb2NrZXQodGhpcy5vcHRpb25zLCAoZXJyLCBzb2NrZXRPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByZXR1cm5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoc29ja2V0T3B0aW9ucyAmJiBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bng6ICdwcm94eScsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVBZGRyZXNzOiBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZVBvcnQ6IHNvY2tldE9wdGlvbnMuY29ubmVjdGlvbi5yZW1vdGVQb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdEhvc3Q6IG9wdGlvbnMuaG9zdCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RQb3J0OiBvcHRpb25zLnBvcnQgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdjb25uZWN0ZWQnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdVc2luZyBwcm94aWVkIHNvY2tldCBmcm9tICVzOiVzIHRvICVzOiVzJyxcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uLnJlbW90ZUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldE9wdGlvbnMuY29ubmVjdGlvbi5yZW1vdGVQb3J0LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhvc3QgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucG9ydCB8fCAnJ1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IGNvcHkgb3B0aW9ucyBpZiB3ZSBuZWVkIHRvIG1vZGlmeSBpdFxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBzaGFyZWQuYXNzaWduKGZhbHNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzb2NrZXRPcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHNvY2tldE9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb24gPSBuZXcgU01UUENvbm5lY3Rpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24ub25jZSgnZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGlsbCBoYXZlIG5vdCByZXR1cm5lZCwgdGhpcyBtZWFucyB3ZSBoYXZlIGFuIHVuZXhwZWN0ZWQgY29ubmVjdGlvbiBjbG9zZVxuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyID0gbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNvY2tldCBjbG9zZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLl9zb2NrZXQgJiYgY29ubmVjdGlvbi5fc29ja2V0LnVwZ3JhZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnR0bHMgY29ubmVjdGlvbiBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gJ0VUTFMnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSwgMTAwMCk7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lci51bnJlZigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlLiBIYXBwZW5zIG9uIGVudnMgd2l0aCBub24tbm9kZSB0aW1lciBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZXQgc2VuZE1lc3NhZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGVudmVsb3BlID0gbWFpbC5tZXNzYWdlLmdldEVudmVsb3BlKCk7XG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2VJZCA9IG1haWwubWVzc2FnZS5tZXNzYWdlSWQoKTtcblxuICAgICAgICAgICAgICAgIGxldCByZWNpcGllbnRzID0gW10uY29uY2F0KGVudmVsb3BlLnRvIHx8IFtdKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjaXBpZW50cy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2lwaWVudHMucHVzaCgnLi4uYW5kICcgKyByZWNpcGllbnRzLnNwbGljZSgyKS5sZW5ndGggKyAnIG1vcmUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWFpbC5kYXRhLmRzbikge1xuICAgICAgICAgICAgICAgICAgICBlbnZlbG9wZS5kc24gPSBtYWlsLmRhdGEuZHNuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdTZW5kaW5nIG1lc3NhZ2UgJXMgdG8gPCVzPicsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgcmVjaXBpZW50cy5qb2luKCcsICcpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZChlbnZlbG9wZSwgbWFpbC5tZXNzYWdlLmNyZWF0ZVJlYWRTdHJlYW0oKSwgKGVyciwgaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3NlbmQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnU2VuZCBlcnJvciBmb3IgJXM6ICVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmZvLmVudmVsb3BlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogZW52ZWxvcGUuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBlbnZlbG9wZS50b1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpbmZvLm1lc3NhZ2VJZCA9IG1lc3NhZ2VJZDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnI6IEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ2NhbGxiYWNrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbGxiYWNrIGVycm9yIGZvciAlczogJXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgYXV0aCA9IHRoaXMuZ2V0QXV0aChtYWlsLmRhdGEuYXV0aCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXV0aCAmJiAoY29ubmVjdGlvbi5hbGxvd3NBdXRoIHx8IG9wdGlvbnMuZm9yY2VBdXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmxvZ2luKGF1dGgsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXV0aCAmJiBhdXRoICE9PSB0aGlzLmF1dGggJiYgYXV0aC5vYXV0aDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoLm9hdXRoMi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIFNNVFAgY29uZmlndXJhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICB2ZXJpZnkoY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IHByb21pc2U7XG5cbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHNoYXJlZC5jYWxsYmFja1Byb21pc2UocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nZXRTb2NrZXQodGhpcy5vcHRpb25zLCAoZXJyLCBzb2NrZXRPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKHNvY2tldE9wdGlvbnMgJiYgc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG54OiAncHJveHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uLnJlbW90ZUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVQb3J0OiBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24ucmVtb3RlUG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RIb3N0OiBvcHRpb25zLmhvc3QgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0UG9ydDogb3B0aW9ucy5wb3J0IHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnY29ubmVjdGVkJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnVXNpbmcgcHJveGllZCBzb2NrZXQgZnJvbSAlczolcyB0byAlczolcycsXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldE9wdGlvbnMuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24ucmVtb3RlUG9ydCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ob3N0IHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBvcnQgfHwgJydcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHNoYXJlZC5hc3NpZ24oZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvY2tldE9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gc29ja2V0T3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY29ubmVjdGlvbiA9IG5ldyBTTVRQQ29ubmVjdGlvbihvcHRpb25zKTtcbiAgICAgICAgICAgIGxldCByZXR1cm5lZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjb25uZWN0aW9uLm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24ub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdDb25uZWN0aW9uIGNsb3NlZCcpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZXQgZmluYWxpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ucXVpdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgYXV0aERhdGEgPSB0aGlzLmdldEF1dGgoe30pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF1dGhEYXRhICYmIChjb25uZWN0aW9uLmFsbG93c0F1dGggfHwgb3B0aW9ucy5mb3JjZUF1dGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ubG9naW4oYXV0aERhdGEsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFhdXRoRGF0YSAmJiBjb25uZWN0aW9uLmFsbG93c0F1dGggJiYgb3B0aW9ucy5mb3JjZUF1dGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVyciA9IG5ldyBFcnJvcignQXV0aGVudGljYXRpb24gaW5mbyB3YXMgbm90IHByb3ZpZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gJ05vQXV0aCc7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbGVhc2VzIHJlc291cmNlc1xuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5hdXRoICYmIHRoaXMuYXV0aC5vYXV0aDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aC5vYXV0aDIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH1cbn1cblxuLy8gZXhwb3NlIHRvIHRoZSB3b3JsZFxubW9kdWxlLmV4cG9ydHMgPSBTTVRQVHJhbnNwb3J0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/smtp-transport/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/stream-transport/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/nodemailer/lib/stream-transport/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst packageData = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/nodemailer/package.json\");\nconst shared = __webpack_require__(/*! ../shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\");\n\n/**\n * Generates a Transport object for streaming\n *\n * Possible options can be the following:\n *\n *  * **buffer** if true, then returns the message as a Buffer object instead of a stream\n *  * **newline** either 'windows' or 'unix'\n *\n * @constructor\n * @param {Object} optional config parameter\n */\nclass StreamTransport {\n    constructor(options) {\n        options = options || {};\n\n        this.options = options || {};\n\n        this.name = 'StreamTransport';\n        this.version = packageData.version;\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'stream-transport'\n        });\n\n        this.winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes((options.newline || '').toString().toLowerCase());\n    }\n\n    /**\n     * Compiles a mailcomposer message and forwards it to handler that sends it\n     *\n     * @param {Object} emailMessage MailComposer object\n     * @param {Function} callback Callback function to run when the sending is completed\n     */\n    send(mail, done) {\n        // We probably need this in the output\n        mail.message.keepBcc = true;\n\n        let envelope = mail.data.envelope || mail.message.getEnvelope();\n        let messageId = mail.message.messageId();\n\n        let recipients = [].concat(envelope.to || []);\n        if (recipients.length > 3) {\n            recipients.push('...and ' + recipients.splice(2).length + ' more');\n        }\n        this.logger.info(\n            {\n                tnx: 'send',\n                messageId\n            },\n            'Sending message %s to <%s> using %s line breaks',\n            messageId,\n            recipients.join(', '),\n            this.winbreak ? '<CR><LF>' : '<LF>'\n        );\n\n        setImmediate(() => {\n            let stream;\n\n            try {\n                stream = mail.message.createReadStream();\n            } catch (E) {\n                this.logger.error(\n                    {\n                        err: E,\n                        tnx: 'send',\n                        messageId\n                    },\n                    'Creating send stream failed for %s. %s',\n                    messageId,\n                    E.message\n                );\n                return done(E);\n            }\n\n            if (!this.options.buffer) {\n                stream.once('error', err => {\n                    this.logger.error(\n                        {\n                            err,\n                            tnx: 'send',\n                            messageId\n                        },\n                        'Failed creating message for %s. %s',\n                        messageId,\n                        err.message\n                    );\n                });\n                return done(null, {\n                    envelope: mail.data.envelope || mail.message.getEnvelope(),\n                    messageId,\n                    message: stream\n                });\n            }\n\n            let chunks = [];\n            let chunklen = 0;\n            stream.on('readable', () => {\n                let chunk;\n                while ((chunk = stream.read()) !== null) {\n                    chunks.push(chunk);\n                    chunklen += chunk.length;\n                }\n            });\n\n            stream.once('error', err => {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'send',\n                        messageId\n                    },\n                    'Failed creating message for %s. %s',\n                    messageId,\n                    err.message\n                );\n                return done(err);\n            });\n\n            stream.on('end', () =>\n                done(null, {\n                    envelope: mail.data.envelope || mail.message.getEnvelope(),\n                    messageId,\n                    message: Buffer.concat(chunks, chunklen)\n                })\n            );\n        });\n    }\n}\n\nmodule.exports = StreamTransport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvc3RyZWFtLXRyYW5zcG9ydC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBb0I7QUFDaEQsZUFBZSxtQkFBTyxDQUFDLHNFQUFXOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi9zdHJlYW0tdHJhbnNwb3J0L2luZGV4LmpzPzE1YzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwYWNrYWdlRGF0YSA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpO1xuY29uc3Qgc2hhcmVkID0gcmVxdWlyZSgnLi4vc2hhcmVkJyk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgVHJhbnNwb3J0IG9iamVjdCBmb3Igc3RyZWFtaW5nXG4gKlxuICogUG9zc2libGUgb3B0aW9ucyBjYW4gYmUgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAgKiAqKmJ1ZmZlcioqIGlmIHRydWUsIHRoZW4gcmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIEJ1ZmZlciBvYmplY3QgaW5zdGVhZCBvZiBhIHN0cmVhbVxuICogICogKipuZXdsaW5lKiogZWl0aGVyICd3aW5kb3dzJyBvciAndW5peCdcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVyXG4gKi9cbmNsYXNzIFN0cmVhbVRyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdTdHJlYW1UcmFuc3BvcnQnO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBwYWNrYWdlRGF0YS52ZXJzaW9uO1xuXG4gICAgICAgIHRoaXMubG9nZ2VyID0gc2hhcmVkLmdldExvZ2dlcih0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcy5vcHRpb25zLmNvbXBvbmVudCB8fCAnc3RyZWFtLXRyYW5zcG9ydCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy53aW5icmVhayA9IFsnd2luJywgJ3dpbmRvd3MnLCAnZG9zJywgJ1xcclxcbiddLmluY2x1ZGVzKChvcHRpb25zLm5ld2xpbmUgfHwgJycpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGlsZXMgYSBtYWlsY29tcG9zZXIgbWVzc2FnZSBhbmQgZm9yd2FyZHMgaXQgdG8gaGFuZGxlciB0aGF0IHNlbmRzIGl0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW1haWxNZXNzYWdlIE1haWxDb21wb3NlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgc2VuZGluZyBpcyBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBzZW5kKG1haWwsIGRvbmUpIHtcbiAgICAgICAgLy8gV2UgcHJvYmFibHkgbmVlZCB0aGlzIGluIHRoZSBvdXRwdXRcbiAgICAgICAgbWFpbC5tZXNzYWdlLmtlZXBCY2MgPSB0cnVlO1xuXG4gICAgICAgIGxldCBlbnZlbG9wZSA9IG1haWwuZGF0YS5lbnZlbG9wZSB8fCBtYWlsLm1lc3NhZ2UuZ2V0RW52ZWxvcGUoKTtcbiAgICAgICAgbGV0IG1lc3NhZ2VJZCA9IG1haWwubWVzc2FnZS5tZXNzYWdlSWQoKTtcblxuICAgICAgICBsZXQgcmVjaXBpZW50cyA9IFtdLmNvbmNhdChlbnZlbG9wZS50byB8fCBbXSk7XG4gICAgICAgIGlmIChyZWNpcGllbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIHJlY2lwaWVudHMucHVzaCgnLi4uYW5kICcgKyByZWNpcGllbnRzLnNwbGljZSgyKS5sZW5ndGggKyAnIG1vcmUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRueDogJ3NlbmQnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdTZW5kaW5nIG1lc3NhZ2UgJXMgdG8gPCVzPiB1c2luZyAlcyBsaW5lIGJyZWFrcycsXG4gICAgICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgICAgICByZWNpcGllbnRzLmpvaW4oJywgJyksXG4gICAgICAgICAgICB0aGlzLndpbmJyZWFrID8gJzxDUj48TEY+JyA6ICc8TEY+J1xuICAgICAgICApO1xuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RyZWFtO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0cmVhbSA9IG1haWwubWVzc2FnZS5jcmVhdGVSZWFkU3RyZWFtKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycjogRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdDcmVhdGluZyBzZW5kIHN0cmVhbSBmYWlsZWQgZm9yICVzLiAlcycsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgRS5tZXNzYWdlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShFKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRueDogJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgY3JlYXRpbmcgbWVzc2FnZSBmb3IgJXMuICVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUobnVsbCwge1xuICAgICAgICAgICAgICAgICAgICBlbnZlbG9wZTogbWFpbC5kYXRhLmVudmVsb3BlIHx8IG1haWwubWVzc2FnZS5nZXRFbnZlbG9wZSgpLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHN0cmVhbVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY2h1bmtzID0gW107XG4gICAgICAgICAgICBsZXQgY2h1bmtsZW4gPSAwO1xuICAgICAgICAgICAgc3RyZWFtLm9uKCdyZWFkYWJsZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY2h1bms7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChjaHVuayA9IHN0cmVhbS5yZWFkKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzdHJlYW0ub25jZSgnZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0bng6ICdzZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIGNyZWF0aW5nIG1lc3NhZ2UgZm9yICVzLiAlcycsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PlxuICAgICAgICAgICAgICAgIGRvbmUobnVsbCwge1xuICAgICAgICAgICAgICAgICAgICBlbnZlbG9wZTogbWFpbC5kYXRhLmVudmVsb3BlIHx8IG1haWwubWVzc2FnZS5nZXRFbnZlbG9wZSgpLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBjaHVua2xlbilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbVRyYW5zcG9ydDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/stream-transport/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/well-known/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/nodemailer/lib/well-known/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst services = __webpack_require__(/*! ./services.json */ \"(rsc)/./node_modules/nodemailer/lib/well-known/services.json\");\nconst normalized = {};\n\nObject.keys(services).forEach(key => {\n    let service = services[key];\n\n    normalized[normalizeKey(key)] = normalizeService(service);\n\n    [].concat(service.aliases || []).forEach(alias => {\n        normalized[normalizeKey(alias)] = normalizeService(service);\n    });\n\n    [].concat(service.domains || []).forEach(domain => {\n        normalized[normalizeKey(domain)] = normalizeService(service);\n    });\n});\n\nfunction normalizeKey(key) {\n    return key.replace(/[^a-zA-Z0-9.-]/g, '').toLowerCase();\n}\n\nfunction normalizeService(service) {\n    let filter = ['domains', 'aliases'];\n    let response = {};\n\n    Object.keys(service).forEach(key => {\n        if (filter.indexOf(key) < 0) {\n            response[key] = service[key];\n        }\n    });\n\n    return response;\n}\n\n/**\n * Resolves SMTP config for given key. Key can be a name (like 'Gmail'), alias (like 'Google Mail') or\n * an email address (like 'test@googlemail.com').\n *\n * @param {String} key [description]\n * @returns {Object} SMTP config or false if not found\n */\nmodule.exports = function (key) {\n    key = normalizeKey(key.split('@').pop());\n    return normalized[key] || false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvd2VsbC1rbm93bi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlbWFya2V0Ly4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL3dlbGwta25vd24vaW5kZXguanM/NmZiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNlcnZpY2VzID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy5qc29uJyk7XG5jb25zdCBub3JtYWxpemVkID0ge307XG5cbk9iamVjdC5rZXlzKHNlcnZpY2VzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgbGV0IHNlcnZpY2UgPSBzZXJ2aWNlc1trZXldO1xuXG4gICAgbm9ybWFsaXplZFtub3JtYWxpemVLZXkoa2V5KV0gPSBub3JtYWxpemVTZXJ2aWNlKHNlcnZpY2UpO1xuXG4gICAgW10uY29uY2F0KHNlcnZpY2UuYWxpYXNlcyB8fCBbXSkuZm9yRWFjaChhbGlhcyA9PiB7XG4gICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplS2V5KGFsaWFzKV0gPSBub3JtYWxpemVTZXJ2aWNlKHNlcnZpY2UpO1xuICAgIH0pO1xuXG4gICAgW10uY29uY2F0KHNlcnZpY2UuZG9tYWlucyB8fCBbXSkuZm9yRWFjaChkb21haW4gPT4ge1xuICAgICAgICBub3JtYWxpemVkW25vcm1hbGl6ZUtleShkb21haW4pXSA9IG5vcm1hbGl6ZVNlcnZpY2Uoc2VydmljZSk7XG4gICAgfSk7XG59KTtcblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkucmVwbGFjZSgvW15hLXpBLVowLTkuLV0vZywgJycpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlcnZpY2Uoc2VydmljZSkge1xuICAgIGxldCBmaWx0ZXIgPSBbJ2RvbWFpbnMnLCAnYWxpYXNlcyddO1xuICAgIGxldCByZXNwb25zZSA9IHt9O1xuXG4gICAgT2JqZWN0LmtleXMoc2VydmljZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoZmlsdGVyLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICAgICAgICAgIHJlc3BvbnNlW2tleV0gPSBzZXJ2aWNlW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBTTVRQIGNvbmZpZyBmb3IgZ2l2ZW4ga2V5LiBLZXkgY2FuIGJlIGEgbmFtZSAobGlrZSAnR21haWwnKSwgYWxpYXMgKGxpa2UgJ0dvb2dsZSBNYWlsJykgb3JcbiAqIGFuIGVtYWlsIGFkZHJlc3MgKGxpa2UgJ3Rlc3RAZ29vZ2xlbWFpbC5jb20nKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm5zIHtPYmplY3R9IFNNVFAgY29uZmlnIG9yIGZhbHNlIGlmIG5vdCBmb3VuZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5LnNwbGl0KCdAJykucG9wKCkpO1xuICAgIHJldHVybiBub3JtYWxpemVkW2tleV0gfHwgZmFsc2U7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/well-known/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/xoauth2/index.js":
/*!******************************************************!*\
  !*** ./node_modules/nodemailer/lib/xoauth2/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\nconst nmfetch = __webpack_require__(/*! ../fetch */ \"(rsc)/./node_modules/nodemailer/lib/fetch/index.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst shared = __webpack_require__(/*! ../shared */ \"(rsc)/./node_modules/nodemailer/lib/shared/index.js\");\n\n/**\n * XOAUTH2 access_token generator for Gmail.\n * Create client ID for web applications in Google API console to use it.\n * See Offline Access for receiving the needed refreshToken for an user\n * https://developers.google.com/accounts/docs/OAuth2WebServer#offline\n *\n * Usage for generating access tokens with a custom method using provisionCallback:\n * provisionCallback(user, renew, callback)\n *   * user is the username to get the token for\n *   * renew is a boolean that if true indicates that existing token failed and needs to be renewed\n *   * callback is the callback to run with (error, accessToken [, expires])\n *     * accessToken is a string\n *     * expires is an optional expire time in milliseconds\n * If provisionCallback is used, then Nodemailer does not try to attempt generating the token by itself\n *\n * @constructor\n * @param {Object} options Client information for token generation\n * @param {String} options.user User e-mail address\n * @param {String} options.clientId Client ID value\n * @param {String} options.clientSecret Client secret value\n * @param {String} options.refreshToken Refresh token for an user\n * @param {String} options.accessUrl Endpoint for token generation, defaults to 'https://accounts.google.com/o/oauth2/token'\n * @param {String} options.accessToken An existing valid accessToken\n * @param {String} options.privateKey Private key for JSW\n * @param {Number} options.expires Optional Access Token expire time in ms\n * @param {Number} options.timeout Optional TTL for Access Token in seconds\n * @param {Function} options.provisionCallback Function to run when a new access token is required\n */\nclass XOAuth2 extends Stream {\n    constructor(options, logger) {\n        super();\n\n        this.options = options || {};\n\n        if (options && options.serviceClient) {\n            if (!options.privateKey || !options.user) {\n                setImmediate(() => this.emit('error', new Error('Options \"privateKey\" and \"user\" are required for service account!')));\n                return;\n            }\n\n            let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);\n            this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;\n        }\n\n        this.logger = shared.getLogger(\n            {\n                logger\n            },\n            {\n                component: this.options.component || 'OAuth2'\n            }\n        );\n\n        this.provisionCallback = typeof this.options.provisionCallback === 'function' ? this.options.provisionCallback : false;\n\n        this.options.accessUrl = this.options.accessUrl || 'https://accounts.google.com/o/oauth2/token';\n        this.options.customHeaders = this.options.customHeaders || {};\n        this.options.customParams = this.options.customParams || {};\n\n        this.accessToken = this.options.accessToken || false;\n\n        if (this.options.expires && Number(this.options.expires)) {\n            this.expires = this.options.expires;\n        } else {\n            let timeout = Math.max(Number(this.options.timeout) || 0, 0);\n            this.expires = (timeout && Date.now() + timeout * 1000) || 0;\n        }\n    }\n\n    /**\n     * Returns or generates (if previous has expired) a XOAuth2 token\n     *\n     * @param {Boolean} renew If false then use cached access token (if available)\n     * @param {Function} callback Callback function with error object and token string\n     */\n    getToken(renew, callback) {\n        if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {\n            return callback(null, this.accessToken);\n        }\n\n        let generateCallback = (...args) => {\n            if (args[0]) {\n                this.logger.error(\n                    {\n                        err: args[0],\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'renew'\n                    },\n                    'Failed generating new Access Token for %s',\n                    this.options.user\n                );\n            } else {\n                this.logger.info(\n                    {\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'renew'\n                    },\n                    'Generated new Access Token for %s',\n                    this.options.user\n                );\n            }\n            callback(...args);\n        };\n\n        if (this.provisionCallback) {\n            this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires) => {\n                if (!err && accessToken) {\n                    this.accessToken = accessToken;\n                    this.expires = expires || 0;\n                }\n                generateCallback(err, accessToken);\n            });\n        } else {\n            this.generateToken(generateCallback);\n        }\n    }\n\n    /**\n     * Updates token values\n     *\n     * @param {String} accessToken New access token\n     * @param {Number} timeout Access token lifetime in seconds\n     *\n     * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}\n     */\n    updateToken(accessToken, timeout) {\n        this.accessToken = accessToken;\n        timeout = Math.max(Number(timeout) || 0, 0);\n        this.expires = (timeout && Date.now() + timeout * 1000) || 0;\n\n        this.emit('token', {\n            user: this.options.user,\n            accessToken: accessToken || '',\n            expires: this.expires\n        });\n    }\n\n    /**\n     * Generates a new XOAuth2 token with the credentials provided at initialization\n     *\n     * @param {Function} callback Callback function with error object and token string\n     */\n    generateToken(callback) {\n        let urlOptions;\n        let loggedUrlOptions;\n        if (this.options.serviceClient) {\n            // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount\n            let iat = Math.floor(Date.now() / 1000); // unix time\n            let tokenData = {\n                iss: this.options.serviceClient,\n                scope: this.options.scope || 'https://mail.google.com/',\n                sub: this.options.user,\n                aud: this.options.accessUrl,\n                iat,\n                exp: iat + this.options.serviceRequestTimeout\n            };\n            let token;\n            try {\n                token = this.jwtSignRS256(tokenData);\n            } catch (err) {\n                return callback(new Error('Can\\x27t generate token. Check your auth options'));\n            }\n\n            urlOptions = {\n                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                assertion: token\n            };\n\n            loggedUrlOptions = {\n                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                assertion: tokenData\n            };\n        } else {\n            if (!this.options.refreshToken) {\n                return callback(new Error('Can\\x27t create new access token for user'));\n            }\n\n            // web app - https://developers.google.com/identity/protocols/OAuth2WebServer\n            urlOptions = {\n                client_id: this.options.clientId || '',\n                client_secret: this.options.clientSecret || '',\n                refresh_token: this.options.refreshToken,\n                grant_type: 'refresh_token'\n            };\n\n            loggedUrlOptions = {\n                client_id: this.options.clientId || '',\n                client_secret: (this.options.clientSecret || '').substr(0, 6) + '...',\n                refresh_token: (this.options.refreshToken || '').substr(0, 6) + '...',\n                grant_type: 'refresh_token'\n            };\n        }\n\n        Object.keys(this.options.customParams).forEach(key => {\n            urlOptions[key] = this.options.customParams[key];\n            loggedUrlOptions[key] = this.options.customParams[key];\n        });\n\n        this.logger.debug(\n            {\n                tnx: 'OAUTH2',\n                user: this.options.user,\n                action: 'generate'\n            },\n            'Requesting token using: %s',\n            JSON.stringify(loggedUrlOptions)\n        );\n\n        this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body) => {\n            let data;\n\n            if (error) {\n                return callback(error);\n            }\n\n            try {\n                data = JSON.parse(body.toString());\n            } catch (E) {\n                return callback(E);\n            }\n\n            if (!data || typeof data !== 'object') {\n                this.logger.debug(\n                    {\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'post'\n                    },\n                    'Response: %s',\n                    (body || '').toString()\n                );\n                return callback(new Error('Invalid authentication response'));\n            }\n\n            let logData = {};\n            Object.keys(data).forEach(key => {\n                if (key !== 'access_token') {\n                    logData[key] = data[key];\n                } else {\n                    logData[key] = (data[key] || '').toString().substr(0, 6) + '...';\n                }\n            });\n\n            this.logger.debug(\n                {\n                    tnx: 'OAUTH2',\n                    user: this.options.user,\n                    action: 'post'\n                },\n                'Response: %s',\n                JSON.stringify(logData)\n            );\n\n            if (data.error) {\n                // Error Response : https://tools.ietf.org/html/rfc6749#section-5.2\n                let errorMessage = data.error;\n                if (data.error_description) {\n                    errorMessage += ': ' + data.error_description;\n                }\n                if (data.error_uri) {\n                    errorMessage += ' (' + data.error_uri + ')';\n                }\n                return callback(new Error(errorMessage));\n            }\n\n            if (data.access_token) {\n                this.updateToken(data.access_token, data.expires_in);\n                return callback(null, this.accessToken);\n            }\n\n            return callback(new Error('No access token'));\n        });\n    }\n\n    /**\n     * Converts an access_token and user id into a base64 encoded XOAuth2 token\n     *\n     * @param {String} [accessToken] Access token string\n     * @return {String} Base64 encoded token for IMAP or SMTP login\n     */\n    buildXOAuth2Token(accessToken) {\n        let authData = ['user=' + (this.options.user || ''), 'auth=Bearer ' + (accessToken || this.accessToken), '', ''];\n        return Buffer.from(authData.join('\\x01'), 'utf-8').toString('base64');\n    }\n\n    /**\n     * Custom POST request handler.\n     * This is only needed to keep paths short in Windows – usually this module\n     * is a dependency of a dependency and if it tries to require something\n     * like the request module the paths get way too long to handle for Windows.\n     * As we do only a simple POST request we do not actually require complicated\n     * logic support (no redirects, no nothing) anyway.\n     *\n     * @param {String} url Url to POST to\n     * @param {String|Buffer} payload Payload to POST\n     * @param {Function} callback Callback function with (err, buff)\n     */\n    postRequest(url, payload, params, callback) {\n        let returned = false;\n\n        let chunks = [];\n        let chunklen = 0;\n\n        let req = nmfetch(url, {\n            method: 'post',\n            headers: params.customHeaders,\n            body: payload,\n            allowErrorResponse: true\n        });\n\n        req.on('readable', () => {\n            let chunk;\n            while ((chunk = req.read()) !== null) {\n                chunks.push(chunk);\n                chunklen += chunk.length;\n            }\n        });\n\n        req.once('error', err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(err);\n        });\n\n        req.once('end', () => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(null, Buffer.concat(chunks, chunklen));\n        });\n    }\n\n    /**\n     * Encodes a buffer or a string into Base64url format\n     *\n     * @param {Buffer|String} data The data to convert\n     * @return {String} The encoded string\n     */\n    toBase64URL(data) {\n        if (typeof data === 'string') {\n            data = Buffer.from(data);\n        }\n\n        return data\n            .toString('base64')\n            .replace(/[=]+/g, '') // remove '='s\n            .replace(/\\+/g, '-') // '+' → '-'\n            .replace(/\\//g, '_'); // '/' → '_'\n    }\n\n    /**\n     * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)\n     *\n     * @param {Object} payload The payload to include in the generated token\n     * @return {String} The generated and signed token\n     */\n    jwtSignRS256(payload) {\n        payload = ['{\"alg\":\"RS256\",\"typ\":\"JWT\"}', JSON.stringify(payload)].map(val => this.toBase64URL(val)).join('.');\n        let signature = crypto.createSign('RSA-SHA256').update(payload).sign(this.options.privateKey);\n        return payload + '.' + this.toBase64URL(signature);\n    }\n}\n\nmodule.exports = XOAuth2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIveG9hdXRoMi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG9EQUF3QjtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBVTtBQUNsQyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLHNFQUFXOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZW1hcmtldC8uL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL2xpYi94b2F1dGgyL2luZGV4LmpzPzgwOGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW07XG5jb25zdCBubWZldGNoID0gcmVxdWlyZSgnLi4vZmV0Y2gnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3Qgc2hhcmVkID0gcmVxdWlyZSgnLi4vc2hhcmVkJyk7XG5cbi8qKlxuICogWE9BVVRIMiBhY2Nlc3NfdG9rZW4gZ2VuZXJhdG9yIGZvciBHbWFpbC5cbiAqIENyZWF0ZSBjbGllbnQgSUQgZm9yIHdlYiBhcHBsaWNhdGlvbnMgaW4gR29vZ2xlIEFQSSBjb25zb2xlIHRvIHVzZSBpdC5cbiAqIFNlZSBPZmZsaW5lIEFjY2VzcyBmb3IgcmVjZWl2aW5nIHRoZSBuZWVkZWQgcmVmcmVzaFRva2VuIGZvciBhbiB1c2VyXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9hY2NvdW50cy9kb2NzL09BdXRoMldlYlNlcnZlciNvZmZsaW5lXG4gKlxuICogVXNhZ2UgZm9yIGdlbmVyYXRpbmcgYWNjZXNzIHRva2VucyB3aXRoIGEgY3VzdG9tIG1ldGhvZCB1c2luZyBwcm92aXNpb25DYWxsYmFjazpcbiAqIHByb3Zpc2lvbkNhbGxiYWNrKHVzZXIsIHJlbmV3LCBjYWxsYmFjaylcbiAqICAgKiB1c2VyIGlzIHRoZSB1c2VybmFtZSB0byBnZXQgdGhlIHRva2VuIGZvclxuICogICAqIHJlbmV3IGlzIGEgYm9vbGVhbiB0aGF0IGlmIHRydWUgaW5kaWNhdGVzIHRoYXQgZXhpc3RpbmcgdG9rZW4gZmFpbGVkIGFuZCBuZWVkcyB0byBiZSByZW5ld2VkXG4gKiAgICogY2FsbGJhY2sgaXMgdGhlIGNhbGxiYWNrIHRvIHJ1biB3aXRoIChlcnJvciwgYWNjZXNzVG9rZW4gWywgZXhwaXJlc10pXG4gKiAgICAgKiBhY2Nlc3NUb2tlbiBpcyBhIHN0cmluZ1xuICogICAgICogZXhwaXJlcyBpcyBhbiBvcHRpb25hbCBleHBpcmUgdGltZSBpbiBtaWxsaXNlY29uZHNcbiAqIElmIHByb3Zpc2lvbkNhbGxiYWNrIGlzIHVzZWQsIHRoZW4gTm9kZW1haWxlciBkb2VzIG5vdCB0cnkgdG8gYXR0ZW1wdCBnZW5lcmF0aW5nIHRoZSB0b2tlbiBieSBpdHNlbGZcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENsaWVudCBpbmZvcm1hdGlvbiBmb3IgdG9rZW4gZ2VuZXJhdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudXNlciBVc2VyIGUtbWFpbCBhZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5jbGllbnRJZCBDbGllbnQgSUQgdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmNsaWVudFNlY3JldCBDbGllbnQgc2VjcmV0IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5yZWZyZXNoVG9rZW4gUmVmcmVzaCB0b2tlbiBmb3IgYW4gdXNlclxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYWNjZXNzVXJsIEVuZHBvaW50IGZvciB0b2tlbiBnZW5lcmF0aW9uLCBkZWZhdWx0cyB0byAnaHR0cHM6Ly9hY2NvdW50cy5nb29nbGUuY29tL28vb2F1dGgyL3Rva2VuJ1xuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYWNjZXNzVG9rZW4gQW4gZXhpc3RpbmcgdmFsaWQgYWNjZXNzVG9rZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnByaXZhdGVLZXkgUHJpdmF0ZSBrZXkgZm9yIEpTV1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZXhwaXJlcyBPcHRpb25hbCBBY2Nlc3MgVG9rZW4gZXhwaXJlIHRpbWUgaW4gbXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnRpbWVvdXQgT3B0aW9uYWwgVFRMIGZvciBBY2Nlc3MgVG9rZW4gaW4gc2Vjb25kc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5wcm92aXNpb25DYWxsYmFjayBGdW5jdGlvbiB0byBydW4gd2hlbiBhIG5ldyBhY2Nlc3MgdG9rZW4gaXMgcmVxdWlyZWRcbiAqL1xuY2xhc3MgWE9BdXRoMiBleHRlbmRzIFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgbG9nZ2VyKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNlcnZpY2VDbGllbnQpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcml2YXRlS2V5IHx8ICFvcHRpb25zLnVzZXIpIHtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignT3B0aW9ucyBcInByaXZhdGVLZXlcIiBhbmQgXCJ1c2VyXCIgYXJlIHJlcXVpcmVkIGZvciBzZXJ2aWNlIGFjY291bnQhJykpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBzZXJ2aWNlUmVxdWVzdFRpbWVvdXQgPSBNYXRoLm1pbihNYXRoLm1heChOdW1iZXIodGhpcy5vcHRpb25zLnNlcnZpY2VSZXF1ZXN0VGltZW91dCkgfHwgMCwgMCksIDM2MDApO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNlcnZpY2VSZXF1ZXN0VGltZW91dCA9IHNlcnZpY2VSZXF1ZXN0VGltZW91dCB8fCA1ICogNjA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvZ2dlciA9IHNoYXJlZC5nZXRMb2dnZXIoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcy5vcHRpb25zLmNvbXBvbmVudCB8fCAnT0F1dGgyJ1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucHJvdmlzaW9uQ2FsbGJhY2sgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnByb3Zpc2lvbkNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gdGhpcy5vcHRpb25zLnByb3Zpc2lvbkNhbGxiYWNrIDogZmFsc2U7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmFjY2Vzc1VybCA9IHRoaXMub3B0aW9ucy5hY2Nlc3NVcmwgfHwgJ2h0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi90b2tlbic7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jdXN0b21IZWFkZXJzID0gdGhpcy5vcHRpb25zLmN1c3RvbUhlYWRlcnMgfHwge307XG4gICAgICAgIHRoaXMub3B0aW9ucy5jdXN0b21QYXJhbXMgPSB0aGlzLm9wdGlvbnMuY3VzdG9tUGFyYW1zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSB0aGlzLm9wdGlvbnMuYWNjZXNzVG9rZW4gfHwgZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHBpcmVzICYmIE51bWJlcih0aGlzLm9wdGlvbnMuZXhwaXJlcykpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwaXJlcyA9IHRoaXMub3B0aW9ucy5leHBpcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHRpbWVvdXQgPSBNYXRoLm1heChOdW1iZXIodGhpcy5vcHRpb25zLnRpbWVvdXQpIHx8IDAsIDApO1xuICAgICAgICAgICAgdGhpcy5leHBpcmVzID0gKHRpbWVvdXQgJiYgRGF0ZS5ub3coKSArIHRpbWVvdXQgKiAxMDAwKSB8fCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvciBnZW5lcmF0ZXMgKGlmIHByZXZpb3VzIGhhcyBleHBpcmVkKSBhIFhPQXV0aDIgdG9rZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVuZXcgSWYgZmFsc2UgdGhlbiB1c2UgY2FjaGVkIGFjY2VzcyB0b2tlbiAoaWYgYXZhaWxhYmxlKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHdpdGggZXJyb3Igb2JqZWN0IGFuZCB0b2tlbiBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXRUb2tlbihyZW5ldywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFyZW5ldyAmJiB0aGlzLmFjY2Vzc1Rva2VuICYmICghdGhpcy5leHBpcmVzIHx8IHRoaXMuZXhwaXJlcyA+IERhdGUubm93KCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdGhpcy5hY2Nlc3NUb2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZ2VuZXJhdGVDYWxsYmFjayA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXJnc1swXSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnI6IGFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0bng6ICdPQVVUSDInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjogdGhpcy5vcHRpb25zLnVzZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdyZW5ldydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCBnZW5lcmF0aW5nIG5ldyBBY2Nlc3MgVG9rZW4gZm9yICVzJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnVzZXJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bng6ICdPQVVUSDInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjogdGhpcy5vcHRpb25zLnVzZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdyZW5ldydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ0dlbmVyYXRlZCBuZXcgQWNjZXNzIFRva2VuIGZvciAlcycsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy51c2VyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLnByb3Zpc2lvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnByb3Zpc2lvbkNhbGxiYWNrKHRoaXMub3B0aW9ucy51c2VyLCAhIXJlbmV3LCAoZXJyLCBhY2Nlc3NUb2tlbiwgZXhwaXJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXJyICYmIGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBpcmVzID0gZXhwaXJlcyB8fCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUNhbGxiYWNrKGVyciwgYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlVG9rZW4oZ2VuZXJhdGVDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRva2VuIHZhbHVlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFjY2Vzc1Rva2VuIE5ldyBhY2Nlc3MgdG9rZW5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCBBY2Nlc3MgdG9rZW4gbGlmZXRpbWUgaW4gc2Vjb25kc1xuICAgICAqXG4gICAgICogRW1pdHMgJ3Rva2VuJzogeyB1c2VyOiBVc2VyIGVtYWlsLWFkZHJlc3MsIGFjY2Vzc1Rva2VuOiB0aGUgbmV3IGFjY2Vzc1Rva2VuLCB0aW1lb3V0OiBUVEwgaW4gc2Vjb25kc31cbiAgICAgKi9cbiAgICB1cGRhdGVUb2tlbihhY2Nlc3NUb2tlbiwgdGltZW91dCkge1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gICAgICAgIHRpbWVvdXQgPSBNYXRoLm1heChOdW1iZXIodGltZW91dCkgfHwgMCwgMCk7XG4gICAgICAgIHRoaXMuZXhwaXJlcyA9ICh0aW1lb3V0ICYmIERhdGUubm93KCkgKyB0aW1lb3V0ICogMTAwMCkgfHwgMDtcblxuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VuJywge1xuICAgICAgICAgICAgdXNlcjogdGhpcy5vcHRpb25zLnVzZXIsXG4gICAgICAgICAgICBhY2Nlc3NUb2tlbjogYWNjZXNzVG9rZW4gfHwgJycsXG4gICAgICAgICAgICBleHBpcmVzOiB0aGlzLmV4cGlyZXNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IFhPQXV0aDIgdG9rZW4gd2l0aCB0aGUgY3JlZGVudGlhbHMgcHJvdmlkZWQgYXQgaW5pdGlhbGl6YXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHdpdGggZXJyb3Igb2JqZWN0IGFuZCB0b2tlbiBzdHJpbmdcbiAgICAgKi9cbiAgICBnZW5lcmF0ZVRva2VuKGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCB1cmxPcHRpb25zO1xuICAgICAgICBsZXQgbG9nZ2VkVXJsT3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZXJ2aWNlQ2xpZW50KSB7XG4gICAgICAgICAgICAvLyBzZXJ2aWNlIGFjY291bnQgLSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9pZGVudGl0eS9wcm90b2NvbHMvT0F1dGgyU2VydmljZUFjY291bnRcbiAgICAgICAgICAgIGxldCBpYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTsgLy8gdW5peCB0aW1lXG4gICAgICAgICAgICBsZXQgdG9rZW5EYXRhID0ge1xuICAgICAgICAgICAgICAgIGlzczogdGhpcy5vcHRpb25zLnNlcnZpY2VDbGllbnQsXG4gICAgICAgICAgICAgICAgc2NvcGU6IHRoaXMub3B0aW9ucy5zY29wZSB8fCAnaHR0cHM6Ly9tYWlsLmdvb2dsZS5jb20vJyxcbiAgICAgICAgICAgICAgICBzdWI6IHRoaXMub3B0aW9ucy51c2VyLFxuICAgICAgICAgICAgICAgIGF1ZDogdGhpcy5vcHRpb25zLmFjY2Vzc1VybCxcbiAgICAgICAgICAgICAgICBpYXQsXG4gICAgICAgICAgICAgICAgZXhwOiBpYXQgKyB0aGlzLm9wdGlvbnMuc2VydmljZVJlcXVlc3RUaW1lb3V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuand0U2lnblJTMjU2KHRva2VuRGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdDYW5cXHgyN3QgZ2VuZXJhdGUgdG9rZW4uIENoZWNrIHlvdXIgYXV0aCBvcHRpb25zJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cmxPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGdyYW50X3R5cGU6ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Z3JhbnQtdHlwZTpqd3QtYmVhcmVyJyxcbiAgICAgICAgICAgICAgICBhc3NlcnRpb246IHRva2VuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsb2dnZWRVcmxPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGdyYW50X3R5cGU6ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Z3JhbnQtdHlwZTpqd3QtYmVhcmVyJyxcbiAgICAgICAgICAgICAgICBhc3NlcnRpb246IHRva2VuRGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0NhblxceDI3dCBjcmVhdGUgbmV3IGFjY2VzcyB0b2tlbiBmb3IgdXNlcicpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2ViIGFwcCAtIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2lkZW50aXR5L3Byb3RvY29scy9PQXV0aDJXZWJTZXJ2ZXJcbiAgICAgICAgICAgIHVybE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLm9wdGlvbnMuY2xpZW50SWQgfHwgJycsXG4gICAgICAgICAgICAgICAgY2xpZW50X3NlY3JldDogdGhpcy5vcHRpb25zLmNsaWVudFNlY3JldCB8fCAnJyxcbiAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuOiB0aGlzLm9wdGlvbnMucmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbG9nZ2VkVXJsT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMub3B0aW9ucy5jbGllbnRJZCB8fCAnJyxcbiAgICAgICAgICAgICAgICBjbGllbnRfc2VjcmV0OiAodGhpcy5vcHRpb25zLmNsaWVudFNlY3JldCB8fCAnJykuc3Vic3RyKDAsIDYpICsgJy4uLicsXG4gICAgICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogKHRoaXMub3B0aW9ucy5yZWZyZXNoVG9rZW4gfHwgJycpLnN1YnN0cigwLCA2KSArICcuLi4nLFxuICAgICAgICAgICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5jdXN0b21QYXJhbXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHVybE9wdGlvbnNba2V5XSA9IHRoaXMub3B0aW9ucy5jdXN0b21QYXJhbXNba2V5XTtcbiAgICAgICAgICAgIGxvZ2dlZFVybE9wdGlvbnNba2V5XSA9IHRoaXMub3B0aW9ucy5jdXN0b21QYXJhbXNba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG54OiAnT0FVVEgyJyxcbiAgICAgICAgICAgICAgICB1c2VyOiB0aGlzLm9wdGlvbnMudXNlcixcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdnZW5lcmF0ZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnUmVxdWVzdGluZyB0b2tlbiB1c2luZzogJXMnLFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobG9nZ2VkVXJsT3B0aW9ucylcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBvc3RSZXF1ZXN0KHRoaXMub3B0aW9ucy5hY2Nlc3NVcmwsIHVybE9wdGlvbnMsIHRoaXMub3B0aW9ucywgKGVycm9yLCBib2R5KSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YTtcblxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShib2R5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhFKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bng6ICdPQVVUSDInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjogdGhpcy5vcHRpb25zLnVzZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdwb3N0J1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnUmVzcG9uc2U6ICVzJyxcbiAgICAgICAgICAgICAgICAgICAgKGJvZHkgfHwgJycpLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0ludmFsaWQgYXV0aGVudGljYXRpb24gcmVzcG9uc2UnKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBsb2dEYXRhID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2FjY2Vzc190b2tlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RhdGFba2V5XSA9IChkYXRhW2tleV0gfHwgJycpLnRvU3RyaW5nKCkuc3Vic3RyKDAsIDYpICsgJy4uLic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG54OiAnT0FVVEgyJyxcbiAgICAgICAgICAgICAgICAgICAgdXNlcjogdGhpcy5vcHRpb25zLnVzZXIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ3Bvc3QnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnUmVzcG9uc2U6ICVzJyxcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShsb2dEYXRhKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBSZXNwb25zZSA6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NzQ5I3NlY3Rpb24tNS4yXG4gICAgICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGRhdGEuZXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3JfZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICc6ICcgKyBkYXRhLmVycm9yX2Rlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5lcnJvcl91cmkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICcgKCcgKyBkYXRhLmVycm9yX3VyaSArICcpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUb2tlbihkYXRhLmFjY2Vzc190b2tlbiwgZGF0YS5leHBpcmVzX2luKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdGhpcy5hY2Nlc3NUb2tlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbicpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gYWNjZXNzX3Rva2VuIGFuZCB1c2VyIGlkIGludG8gYSBiYXNlNjQgZW5jb2RlZCBYT0F1dGgyIHRva2VuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2FjY2Vzc1Rva2VuXSBBY2Nlc3MgdG9rZW4gc3RyaW5nXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBCYXNlNjQgZW5jb2RlZCB0b2tlbiBmb3IgSU1BUCBvciBTTVRQIGxvZ2luXG4gICAgICovXG4gICAgYnVpbGRYT0F1dGgyVG9rZW4oYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgbGV0IGF1dGhEYXRhID0gWyd1c2VyPScgKyAodGhpcy5vcHRpb25zLnVzZXIgfHwgJycpLCAnYXV0aD1CZWFyZXIgJyArIChhY2Nlc3NUb2tlbiB8fCB0aGlzLmFjY2Vzc1Rva2VuKSwgJycsICcnXTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGF1dGhEYXRhLmpvaW4oJ1xceDAxJyksICd1dGYtOCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gUE9TVCByZXF1ZXN0IGhhbmRsZXIuXG4gICAgICogVGhpcyBpcyBvbmx5IG5lZWRlZCB0byBrZWVwIHBhdGhzIHNob3J0IGluIFdpbmRvd3Mg4oCTIHVzdWFsbHkgdGhpcyBtb2R1bGVcbiAgICAgKiBpcyBhIGRlcGVuZGVuY3kgb2YgYSBkZXBlbmRlbmN5IGFuZCBpZiBpdCB0cmllcyB0byByZXF1aXJlIHNvbWV0aGluZ1xuICAgICAqIGxpa2UgdGhlIHJlcXVlc3QgbW9kdWxlIHRoZSBwYXRocyBnZXQgd2F5IHRvbyBsb25nIHRvIGhhbmRsZSBmb3IgV2luZG93cy5cbiAgICAgKiBBcyB3ZSBkbyBvbmx5IGEgc2ltcGxlIFBPU1QgcmVxdWVzdCB3ZSBkbyBub3QgYWN0dWFsbHkgcmVxdWlyZSBjb21wbGljYXRlZFxuICAgICAqIGxvZ2ljIHN1cHBvcnQgKG5vIHJlZGlyZWN0cywgbm8gbm90aGluZykgYW55d2F5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVcmwgdG8gUE9TVCB0b1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gcGF5bG9hZCBQYXlsb2FkIHRvIFBPU1RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB3aXRoIChlcnIsIGJ1ZmYpXG4gICAgICovXG4gICAgcG9zdFJlcXVlc3QodXJsLCBwYXlsb2FkLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCByZXR1cm5lZCA9IGZhbHNlO1xuXG4gICAgICAgIGxldCBjaHVua3MgPSBbXTtcbiAgICAgICAgbGV0IGNodW5rbGVuID0gMDtcblxuICAgICAgICBsZXQgcmVxID0gbm1mZXRjaCh1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ3Bvc3QnLFxuICAgICAgICAgICAgaGVhZGVyczogcGFyYW1zLmN1c3RvbUhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBwYXlsb2FkLFxuICAgICAgICAgICAgYWxsb3dFcnJvclJlc3BvbnNlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcS5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2h1bms7XG4gICAgICAgICAgICB3aGlsZSAoKGNodW5rID0gcmVxLnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgY2h1bmtsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEub25jZSgnZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcS5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgQnVmZmVyLmNvbmNhdChjaHVua3MsIGNodW5rbGVuKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYSBidWZmZXIgb3IgYSBzdHJpbmcgaW50byBCYXNlNjR1cmwgZm9ybWF0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGVuY29kZWQgc3RyaW5nXG4gICAgICovXG4gICAgdG9CYXNlNjRVUkwoZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICAgICAgLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1s9XSsvZywgJycpIC8vIHJlbW92ZSAnPSdzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwrL2csICctJykgLy8gJysnIOKGkiAnLSdcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJ18nKTsgLy8gJy8nIOKGkiAnXydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgSlNPTiBXZWIgVG9rZW4gc2lnbmVkIHdpdGggUlMyNTYgKFNIQTI1NiArIFJTQSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIFRoZSBwYXlsb2FkIHRvIGluY2x1ZGUgaW4gdGhlIGdlbmVyYXRlZCB0b2tlblxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGdlbmVyYXRlZCBhbmQgc2lnbmVkIHRva2VuXG4gICAgICovXG4gICAgand0U2lnblJTMjU2KHBheWxvYWQpIHtcbiAgICAgICAgcGF5bG9hZCA9IFsne1wiYWxnXCI6XCJSUzI1NlwiLFwidHlwXCI6XCJKV1RcIn0nLCBKU09OLnN0cmluZ2lmeShwYXlsb2FkKV0ubWFwKHZhbCA9PiB0aGlzLnRvQmFzZTY0VVJMKHZhbCkpLmpvaW4oJy4nKTtcbiAgICAgICAgbGV0IHNpZ25hdHVyZSA9IGNyeXB0by5jcmVhdGVTaWduKCdSU0EtU0hBMjU2JykudXBkYXRlKHBheWxvYWQpLnNpZ24odGhpcy5vcHRpb25zLnByaXZhdGVLZXkpO1xuICAgICAgICByZXR1cm4gcGF5bG9hZCArICcuJyArIHRoaXMudG9CYXNlNjRVUkwoc2lnbmF0dXJlKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWE9BdXRoMjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/xoauth2/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/lib/well-known/services.json":
/*!**************************************************************!*\
  !*** ./node_modules/nodemailer/lib/well-known/services.json ***!
  \**************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"126":{"host":"smtp.126.com","port":465,"secure":true},"163":{"host":"smtp.163.com","port":465,"secure":true},"1und1":{"host":"smtp.1und1.de","port":465,"secure":true,"authMethod":"LOGIN"},"Aliyun":{"domains":["aliyun.com"],"host":"smtp.aliyun.com","port":465,"secure":true},"AOL":{"domains":["aol.com"],"host":"smtp.aol.com","port":587},"Bluewin":{"host":"smtpauths.bluewin.ch","domains":["bluewin.ch"],"port":465},"DebugMail":{"host":"debugmail.io","port":25},"DynectEmail":{"aliases":["Dynect"],"host":"smtp.dynect.net","port":25},"Ethereal":{"aliases":["ethereal.email"],"host":"smtp.ethereal.email","port":587},"FastMail":{"domains":["fastmail.fm"],"host":"smtp.fastmail.com","port":465,"secure":true},"Forward Email":{"aliases":["FE","ForwardEmail"],"domains":["forwardemail.net"],"host":"smtp.forwardemail.net","port":465,"secure":true},"GandiMail":{"aliases":["Gandi","Gandi Mail"],"host":"mail.gandi.net","port":587},"Gmail":{"aliases":["Google Mail"],"domains":["gmail.com","googlemail.com"],"host":"smtp.gmail.com","port":465,"secure":true},"Godaddy":{"host":"smtpout.secureserver.net","port":25},"GodaddyAsia":{"host":"smtp.asia.secureserver.net","port":25},"GodaddyEurope":{"host":"smtp.europe.secureserver.net","port":25},"hot.ee":{"host":"mail.hot.ee"},"Hotmail":{"aliases":["Outlook","Outlook.com","Hotmail.com"],"domains":["hotmail.com","outlook.com"],"host":"smtp-mail.outlook.com","port":587},"iCloud":{"aliases":["Me","Mac"],"domains":["me.com","mac.com"],"host":"smtp.mail.me.com","port":587},"Infomaniak":{"host":"mail.infomaniak.com","domains":["ik.me","ikmail.com","etik.com"],"port":587},"mail.ee":{"host":"smtp.mail.ee"},"Mail.ru":{"host":"smtp.mail.ru","port":465,"secure":true},"Mailcatch.app":{"host":"sandbox-smtp.mailcatch.app","port":2525},"Maildev":{"port":1025,"ignoreTLS":true},"Mailgun":{"host":"smtp.mailgun.org","port":465,"secure":true},"Mailjet":{"host":"in.mailjet.com","port":587},"Mailosaur":{"host":"mailosaur.io","port":25},"Mailtrap":{"host":"smtp.mailtrap.io","port":2525},"Mandrill":{"host":"smtp.mandrillapp.com","port":587},"Naver":{"host":"smtp.naver.com","port":587},"One":{"host":"send.one.com","port":465,"secure":true},"OpenMailBox":{"aliases":["OMB","openmailbox.org"],"host":"smtp.openmailbox.org","port":465,"secure":true},"Outlook365":{"host":"smtp.office365.com","port":587,"secure":false},"OhMySMTP":{"host":"smtp.ohmysmtp.com","port":587,"secure":false},"Postmark":{"aliases":["PostmarkApp"],"host":"smtp.postmarkapp.com","port":2525},"qiye.aliyun":{"host":"smtp.mxhichina.com","port":"465","secure":true},"QQ":{"domains":["qq.com"],"host":"smtp.qq.com","port":465,"secure":true},"QQex":{"aliases":["QQ Enterprise"],"domains":["exmail.qq.com"],"host":"smtp.exmail.qq.com","port":465,"secure":true},"SendCloud":{"host":"smtp.sendcloud.net","port":2525},"SendGrid":{"host":"smtp.sendgrid.net","port":587},"SendinBlue":{"aliases":["Brevo"],"host":"smtp-relay.brevo.com","port":587},"SendPulse":{"host":"smtp-pulse.com","port":465,"secure":true},"SES":{"host":"email-smtp.us-east-1.amazonaws.com","port":465,"secure":true},"SES-US-EAST-1":{"host":"email-smtp.us-east-1.amazonaws.com","port":465,"secure":true},"SES-US-WEST-2":{"host":"email-smtp.us-west-2.amazonaws.com","port":465,"secure":true},"SES-EU-WEST-1":{"host":"email-smtp.eu-west-1.amazonaws.com","port":465,"secure":true},"SES-AP-SOUTH-1":{"host":"email-smtp.ap-south-1.amazonaws.com","port":465,"secure":true},"SES-AP-NORTHEAST-1":{"host":"email-smtp.ap-northeast-1.amazonaws.com","port":465,"secure":true},"SES-AP-NORTHEAST-2":{"host":"email-smtp.ap-northeast-2.amazonaws.com","port":465,"secure":true},"SES-AP-NORTHEAST-3":{"host":"email-smtp.ap-northeast-3.amazonaws.com","port":465,"secure":true},"SES-AP-SOUTHEAST-1":{"host":"email-smtp.ap-southeast-1.amazonaws.com","port":465,"secure":true},"SES-AP-SOUTHEAST-2":{"host":"email-smtp.ap-southeast-2.amazonaws.com","port":465,"secure":true},"Sparkpost":{"aliases":["SparkPost","SparkPost Mail"],"domains":["sparkpost.com"],"host":"smtp.sparkpostmail.com","port":587,"secure":false},"Tipimail":{"host":"smtp.tipimail.com","port":587},"Yahoo":{"domains":["yahoo.com"],"host":"smtp.mail.yahoo.com","port":465,"secure":true},"Yandex":{"domains":["yandex.ru"],"host":"smtp.yandex.ru","port":465,"secure":true},"Zoho":{"host":"smtp.zoho.com","port":465,"secure":true,"authMethod":"LOGIN"}}');

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer/package.json":
/*!**********************************************!*\
  !*** ./node_modules/nodemailer/package.json ***!
  \**********************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"nodemailer","version":"6.9.13","description":"Easy as cake e-mail sending from your Node.js applications","main":"lib/nodemailer.js","scripts":{"test":"node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js","test:coverage":"c8 node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js","lint":"eslint .","update":"rm -rf node_modules/ package-lock.json && ncu -u && npm install"},"repository":{"type":"git","url":"https://github.com/nodemailer/nodemailer.git"},"keywords":["Nodemailer"],"author":"Andris Reinman","license":"MIT-0","bugs":{"url":"https://github.com/nodemailer/nodemailer/issues"},"homepage":"https://nodemailer.com/","devDependencies":{"@aws-sdk/client-ses":"3.529.1","bunyan":"1.8.15","c8":"9.1.0","eslint":"8.57.0","eslint-config-nodemailer":"1.2.0","eslint-config-prettier":"9.1.0","libbase64":"1.3.0","libmime":"5.3.4","libqp":"2.1.0","nodemailer-ntlm-auth":"1.0.4","proxy":"1.0.2","proxy-test-server":"1.0.0","smtp-server":"3.13.3"},"engines":{"node":">=6.0.0"}}');

/***/ })

};
;